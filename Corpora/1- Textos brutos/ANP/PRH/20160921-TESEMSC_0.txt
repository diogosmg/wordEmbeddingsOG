DISSERTAÇÃO DE MESTRADO

INVERSÃO SÍSMICA DE
CAMPOS DE VELOCIDADES
PARAMETRIZADOS POR SÉRIE
ONDALETA CHAPÉU
MEXICANO BIDIMENSIONAL

MARCUS VINICIUS TELES DE MELLO

SALVADOR – BAHIA
DEZEMBRO – 2015

Documento preparado com o sistema LATEX.

Documento elaborado com os recursos gráﬁcos e de informática do CPGG/UFBA

Inversão Sísmica de Campos de Velocidades Parametrizados por

Série Ondaleta Chapéu Mexicano Bidimensional

por

Marcus Vinicius Teles de Mello

Lic. Física (Universidade Federal da Bahia – 2009)

Orientador: Prof. Dr. Wilson Mouzer Figueiró

DISSERTAÇÃO DE MESTRADO

Submetida em satisfação parcial dos requisitos ao grau de

MESTRE EM CIÊNCIAS

EM

GEOFÍSICA

ao

Conselho Acadêmico de Ensino

da

Universidade Federal da Bahia

Comissão Examinadora

Dr. Wilson Mouzer Figueiró (orientador)

Dr. Eduardo Telmo Fonseca Santos

Dr. Juarez dos Santos Azevedo

Aprovada em 15 de dezembro de 2015

A presente pesquisa foi desenvolvida no Centro de Pesquisa em Geofísica e Geologia da UFBA,

com recursos da ANP.

M527 Mello, Marcus Vinicius Teles de,

Inversão Sísmica de Campos de Velocidades Parametrizados
por Série Ondaleta Chapéu Mexicano Bidimensional / Marcus
Vinicius Teles de Mello. — Salvador, 2015.

76 f.: il.

Orientador: Prof. Dr. Wilson Mouzer Figueiró
Dissertação (Mestrado) - Pós-Graduação em Geofísica. Insti-

tuto de Geociências da Universidade Federal da Bahia, 2015.

1. Ondaleta. 2. Parametrização. 3. Campos de velocidades Sísmi-
cas. 4. Inversão. I. Figueiró, Wilson Mouzer. II. Universidade Federal
da Bahia, Instituto de Geociências, Programa de Pós Graduação em
Geofísica. III. Título

550.3(134.3)(081)

Resumo

Modelos geológicos são objetos teóricos de alta complexidade e de caráter qualitativo. Neste
trabalho está apresentada uma forma de representar um dos seus aspectos, as velocidades
das ondas sísmicas compressionais, de forma quantitativa, através de uma parametrização
por série ondaleta chapéu mexicano bidimensional. A modelagem direta por traçamento
de raios foi implementada em campos de velocidades assim parametrizados, atestando a
eﬁcácia da técnica no que concerne à obtenção de tempos de transito por tomograﬁa sísmica.
A quantidade reduzida de parâmetros utilizados, quando comparada à tradicional e bem
estabelecida parametrização por blocos, acarretou uma redução dos custos computacionais
na realização desta tarefa. A investigação da composição da subsuperfície, a partir dos
dados de resposta de métodos não invasivos - modelagem inversa - depende diretamente
da técnica de parametrização utilizada, exatamente porque os algoritmos consagrados de
inversão (escopos global e local) se baseiam em iterações que requerem a repetição sistemática
da modelagem direta. Assim sendo, quanto menor a quantidade de parâmetros, mais rápido
será o processamento. Foi usada uma combinação dos algoritmos de Monte Carlo (escopo
global) e Gauss-Newton (escopo local) para o procedimento de inversão, tendo sido obtidos
bons resultados. O uso da ferramenta do processamento em paralelo também é constante ao
longo do trabalho.

i

Abstract

Geological models are theoretical objects of high complexity and qualitative. This work
presents a way of representing one of its aspects, the velocities of compressional seismic
waves in a quantitative manner, using a two-dimensional wavelet parameterization series.
The forward modeling by ray tracing has been implemented on so parameterized velocity
ﬁelds, attesting the eﬀectiveness of the technique in respect to achieving transit time for
seismic tomography. The reduced number of parameters used when compared to traditional
and well-established parameterization for blocks, led to a reduction in computational costs in
carrying out this task. The investigation of the composition of the subsurface, from the non-
invasive methods response data - inverse modeling - depends directly on the parameterization
technique, precisely because the reversal of established algorithms (global and local scope)
are based on iterations that require repetition systematic direct modeling. Thus, the smaller
the number of parameters, the faster processing. It was used a combination of Monte Carlo
algorithms (global scope) and Gauss-Newton (local scope) for the reversal procedure, having
obtained good results. The use of parallel processing tool is also constant throughout the
study.

ii

Índice

Resumo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Abstract . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Índice . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Índice de Tabelas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

i

ii

iii

vi

Índice de Figuras . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . viii

Introdução . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

1 Parametrização . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.1 Introdução às Ondaletas . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.1.1 Função ondaleta
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.1.2 Propriedades das Ondaletas . . . . . . . . . . . . . . . . . . . . . . .
1.1.3 A função Escala . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.2 Alguns exemplos de Ondaletas . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.2.1 Ondaleta Haar
1.2.2 Ondaleta Morlet
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.2.3 Ondaleta Shannon . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.2.4 Ondaleta Chapéu Mexicano . . . . . . . . . . . . . . . . . . . . . . .
1.3 Ondaletas Bidimensionais
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.4 Metodologia da Parametrização . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . .
1.5 Parametrização Unidimensional
1.6 O método dos Mínimos Quadrados
. . . . . . . . . . . . . . . . . . . . . . .
1.7 Etapas do Processamento numérico . . . . . . . . . . . . . . . . . . . . . . .
1.8 Parametrização Bidimensional . . . . . . . . . . . . . . . . . . . . . . . . . .
1.9 Parametrização de Campos de Velocidades Sísmicas . . . . . . . . . . . . . .
1.10 Geração do campo de Velocidade Sísmica em Subsuperfície . . . . . . . . . .
1.11 Parametrização do Campo de Velocidade . . . . . . . . . . . . . . . . . . . .

1

3
3
3
4
5
6
6
7
8
9
10
11
12
12
13
14
16
17
18

iii

Índice

2 Modelagem Direta . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.1 Introdução . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.2 A Teoria do Raio . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.3 Cálculo do Tempo de Trânsito ao longo do Raio Sísmico . . . . . . . . . . .
2.4 Metodologia empregada na Modelagem Direta dos Tempos de Trânsito . . .
2.4.1 Geometria . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2 Ligação Fonte-Receptor
. . . . . . . . . . . . . . . . . . . . . . . . .
2.4.3 Primeiras Chegadas e Processamento Paralelo . . . . . . . . . . . . .

3 Modelagem Inversa . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.1 Introdução . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.2 Problemas não Lineares
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.3 A Função Erro Objetivo . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.4 Método de Monte Carlo . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.5 Método de Gauss-Newton . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.6 Metodologia Empregada na Inversão . . . . . . . . . . . . . . . . . . . . . .
3.6.1 Monte Carlo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.6.1.1 Cálculo do Erro . . . . . . . . . . . . . . . . . . . . . . . . .
3.6.1.2 Perturbação do Modelo e Range Sísmico . . . . . . . . . . .
3.6.1.3 Critérios de Parada . . . . . . . . . . . . . . . . . . . . . . .
3.6.2 Gauss-Newton . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.6.2.1 A matriz Sensibilidade . . . . . . . . . . . . . . . . . . . . .

4.1 Parametrização Unidimensional

4 Resultados Preliminares . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . .
4.1.1 Primeira Parametrização . . . . . . . . . . . . . . . . . . . . . . . . .
4.1.2 Segunda Parametrização . . . . . . . . . . . . . . . . . . . . . . . . .
4.1.3 Terceira Parametrização . . . . . . . . . . . . . . . . . . . . . . . . .
4.2 Parametrização Bidimensional . . . . . . . . . . . . . . . . . . . . . . . . . .

5.1 Modelo da Falha Distensional

5 Resultados para Modelos de Campos de Velocidades . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . .
5.1.1 Parametrizações . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.1.2 Modelagem Direta: Traçamento de Raios . . . . . . . . . . . . . . . .
Inversão . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.1.3
5.2 Modelo do Domo Salino . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.2.1 Parametrizações . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.2.2 Modelagem Direta: Traçamento de Raios . . . . . . . . . . . . . . . .

iv

20
20
21
23
24
24
25
25

27
27
28
29
29
31
33
33
34
35
35
37
37

40
40
41
41
42
42

44
44
45
48
48
53
54
54

Índice

5.2.3

Inversão . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.3 Modelo do Intrusão de Alta Velocidade . . . . . . . . . . . . . . . . . . . . .
5.3.1 Parametrizações . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.3.2 Modelagem Direta: Traçamento de Raios . . . . . . . . . . . . . . . .
5.3.3
Inversão . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

6 Conclusões . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Agradecimentos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Apêndice A Tabelas de Coeﬁcientes da Parametrização do Modelo Domo

Salino . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
A.1 Modelo Alvo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
A.2 Modelo Inicial . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
A.3 Modelo Invertido . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Apêndice B Tabelas de Coeﬁcientes da Parametrização do Modelo com

. . . . . . . . . . . . . . . . . . . . . . . . . .
Intrusão de Alta Velocidade
B.1 Modelo Alvo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
B.2 Modelo Inicial . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
B.3 Modelo Invertido . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Anexo I

Programação em Paralelo - OpenMP . . . . . . . . . . . . . . . .

v

55
58
59
62
64

73

75

77
78
80
82

84
85
87
89

91

Índice de Tabelas

tensional,

cial, Mo1,

5.1 Relação de índices e coeﬁcientes utilizados na parametrização da Falha Dis-
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.2 Relação de índices e coeﬁcientes utilizados na parametrização do Modelo Ini-
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.3 Comportamento dos algoritmos de inversão - Falha Distensional. . . . . . . .
5.4 Relação de índices obtidos para o Modelo Invertido, M1,I. . . . . . . . . . . .
5.5 Comportamento dos algoritmos de inversão - Domo Salino. . . . . . . . . . .
5.6 Comportamento dos algoritmos de inversão - Intrusão de alta velocidade.
. .

A.1 Coeﬁcientes utilizados na parametrização do modelo do domo salino, M2,P1,
1a parte. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
A.2 Coeﬁcientes utilizados na parametrização do modelo do domo salino, M2,P1,
2a parte. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
A.3 Coeﬁcientes utilizados na parametrização do modelo inicial, Mo2, utilizado
na inversão do domo salino. 1a parte. . . . . . . . . . . . . . . . . . . . . . .
A.4 Coeﬁcientes utilizados na parametrização do modelo inicial, Mo2, utilizado
na inversão do domo salino. 2a parte. . . . . . . . . . . . . . . . . . . . . . .
A.5 Coeﬁcientes da parametrização do modelo domo salino, M2,I, obtidos na in-
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
A.6 Coeﬁcientes da parametrização do modelo domo salino, M2,I, obtidos na in-
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

versão. 1a parte.

versão. 2a parte.

B.1 Coeﬁcientes utilizados na parametrização do modelo da intrusão de alta velo-
cidade, M3,P1, 1a parte. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
B.2 Coeﬁcientes utilizados na parametrização do modelo da intrusão de alta velo-
cidade, M3,P1, 2a parte. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
B.3 Coeﬁcientes utilizados na parametrização do modelo inicial, Mo3, utilizado
na inversão da intrusão de alta velocidade. 1a parte. . . . . . . . . . . . . . .
B.4 Coeﬁcientes utilizados na parametrização do modelo inicial, Mo3, utilizado
na inversão da intrusão de alta velocidade. 2a parte. . . . . . . . . . . . . . .

vi

45

49
52
53
58
66

78

79

80

81

82

83

85

86

87

88

Índice de Tabelas

obtidos na inversão. 1a parte.

B.5 Coeﬁcientes da parametrização do modelo intrusão de alta velocidade, M3,I,
. . . . . . . . . . . . . . . . . . . . . . . . . .
B.6 Coeﬁcientes da parametrização do modelo intrusão de alta velocidade, M3,I,
. . . . . . . . . . . . . . . . . . . . . . . . . .

obtidos na inversão. 2a parte.

vii

89

90

Índice de Figuras

. . . . . . . . . . . . . . . . . . . . . .
1.1 A ondaleta Haar e sua função escala.
1.2 Parte real da função ondaleta Morlet, Re( M (t)).
. . . . . . . . . . . . . . .
1.3 Função ondaleta Shannon,  S(t) . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . .
1.4 Ondaleta chapéu mexicano normalizada,  (t).
1.5 Função ondaleta chapéu mexicano,  j,k(t), para k > 0.
. . . . . . . . . . . .
1.6 Gráﬁco de uma parábola restrita. Os valores de f (x) são nulos fora do domínio
[0, 3]. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.7 Gráﬁco de uma sela restrita. Os valores de f (x, y) são nulos fora do domínio
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.8 Modelo da falha distensional.
. . . . . . . . . . . . . . . . . . . . . . . . . .
1.9 Modelo da falha distensional com malha retangular. . . . . . . . . . . . . . .

[ 2, 2] ⇥ [ 2, 2].

2.1 Relação entre modelo e dados. . . . . . . . . . . . . . . . . . . . . . . . . . .
2.2 Distribuição das fontes (Si) em poços e receptores (Rj) ﬁxos na superfície do
modelo da falha distensional. . . . . . . . . . . . . . . . . . . . . . . . . . . .

3.1 Comportamento de uma função erro hipotética em relação aos modelos (Sen
e Stoﬀa, 2013). Os pontos 1, 2 e 3 representam modelos iniciais; também são
. . . . . . . . . . . . . . . . . . . . . .
indicados os mínimos global e locais.
. . . . . . .
3.2 Modelo inicial m0: homogêneo com velocidade igual a 3, 0 km/s.
3.3 Fluxograma do algoritmo de Monte Carlo, adaptado ao trabalho aqui desen-
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

volvido.

4.1 Gráﬁco de uma parábola restrita. Os valores de f (x) são nulos fora do domínio
[0, 3]. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.2 Parábola restrita parametrizada por série ondaleta unidimensional com 39
. . . . . . . . . . . . . . . . . . . . .
4.3 Parábola restrita parametrizada por série ondaleta unidimensional com 39
coeﬁcientes, amostrada em 50 pontos. . . . . . . . . . . . . . . . . . . . . . .

coeﬁcientes, amostrada em 100 pontos.

7
8
8
9
10

12

15
17
17

21

24

31
34

36

40

41

41

viii

Índice de Figuras

ix

4.4 Parábola restrita parametrizada por série ondaleta unidimensional com 27
coeﬁcientes, amostrada em 35 pontos . . . . . . . . . . . . . . . . . . . . . .

42
4.5 Sela restrita. Os valores de f (x, y) são nulos fora do domínio [ 2, 2] ⇥ [ 2, 2]. 42
43
4.6 Função sela restrita parametrizada com 1.521 coeﬁcientes.

. . . . . . . . . .

mensional chapéu mexicano, com 160 coeﬁcientes.

mensional chapéu mexicano, com 640 coeﬁcientes.

coeﬁcientes (M1,P1). Foram usados 2.000 raios por fonte.

44

46

47

47

48

49

50
51

51

52

53

54

55

56
56

57

57

(M1,P1). Os tempos nulos são associados a receptores não iluminados.

raios partindo de cada fonte. Modelo parametrizado com 27 coeﬁcientes.

. . . . . . . . . . . . . . . . . . . . . . .
5.1 Modelo da falha distensional (M1).
5.2 Parametrização do modelo da falha distensional (M1,P1) com ondaleta bidi-
mensional chapéu mexicano, com 27 coeﬁcientes. . . . . . . . . . . . . . . . .
5.3 Parametrização do modelo da falha distensional (M1,P2) com ondaleta bidi-
mensional chapéu mexicano, com 40 coeﬁcientes. . . . . . . . . . . . . . . . .
5.4 Parametrização do modelo da falha distensional (M1,P3) com ondaleta bidi-
. . . . . . . . . . . . . . .
5.5 Parametrização do modelo da falha distensional (M1,P4) com ondaleta bidi-
. . . . . . . . . . . . . . .
5.6 Traçamento de raios no modelo da falha distensional parametrizado por 27
. . . . . . . . . . .
5.7 Perﬁs de tempos de trânsito sintéticos para o modelo da falha distensional
. . . .
5.8 Mo1, modelo inicial: bloco de velocidade única, 3, 0 km/s.
. . . . . . . . . .
5.9 Traçamento de raios no modelo inicial Mo1; novamente, foram utilizados 2.000
. .
5.10 Perﬁs de tempos de trânsito sintéticos para o modelo inicial (Mo1). Os tempos
. . . . . . . . . . . . . . .
5.11 Modelo Invertido, M1,I, obtido através dos algoritmos de Monte Carlo e Gauss-
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.12 Traçado de raios para o modelo da falha distensional, M1,I, obtido por inver-
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.13 Perﬁs de tempos de trânsito sintéticos para o modelo da falha distensional
obtido por inversão (M1,I). Os tempos nulos são associados a receptores não
iluminados.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.14 Diferença relativa entre as velocidades do modelo invertido, M1,I e alvo para-
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.15 Domo salino.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.16 Parametrização do modelo do domo salino (M2,P1) com ondaleta bidimensional
chapéu mexicano, com 216 coeﬁcientes. . . . . . . . . . . . . . . . . . . . . .
5.17 Parametrização do modelo do domo salino (M2,P2) com ondaleta bidimensional
chapéu mexicano, com 600 coeﬁcientes. . . . . . . . . . . . . . . . . . . . . .

Newton combinados.

são; 2.000 raios por fonte.

nulos são associados a receptores não iluminados.

metrizado, M1,P1.

Índice de Figuras

Os tempos nulos são associados a receptores não iluminados.

5.18 Traçamento de raios no modelo do domo salino parametrizado por 216 coeﬁ-
cientes (M2,P1). Foram usados 5.000 raios por fonte. . . . . . . . . . . . . . .
5.19 Perﬁs de tempos de trânsito sintéticos para o modelo do domo salino (M2,P1).
. . . . . . . . .
5.20 Mo2, modelo inicial: bloco de velocidade única, 2, 2 km/s com uma intrusão
de alta velocidade 6, 0 km/s . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.21 Traçamento de raios no modelo inicial Mo2; novamente, foram utilizados 5.000
raios partindo de cada fonte. Modelo parametrizado com 216 coeﬁcientes. . .
5.22 Perﬁs de tempos de trânsito sintéticos para o modelo inicial (Mo2). Os tempos
. . . . . . . . . . . . . . .
5.23 Modelo Invertido, M2,I, obtido através dos algoritmos de Monte Carlo e Gauss-
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.24 Traçado de raios para o modelo do domo salino, M2,I, obtido por inversão;
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.25 Perﬁs de tempos de trânsito sintéticos para o modelo do domo salino obtido

nulos são associados a receptores não iluminados.

Newton combinados.

5.000 raios por fonte.

x

58

59

60

60

61

62

62

por inversão (M2,I). Os tempos nulos são associados a receptores não iluminados. 63

escala de cores.

5.26 Diferença relativa entre as velocidades do modelo invertido, M2,I e alvo para-
metrizado, M2,P1, para o domo salino. . . . . . . . . . . . . . . . . . . . . . .
5.27 Campo de velocidades original do modelo da intrusão de alta velocidade em
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.28 Parametrização do modelo da intrusão de alta velocidade (M3,P1) com onda-
. . . . . . . . . .
5.29 Parametrização do modelo da intrusão de alta velocidade (M3,P2) com onda-
. . . . . . . . . .
5.30 Traçamento de raios no modelo da intrusão de alta velocidade parametrizado
por 180 coeﬁcientes (M3,P1). Foram usados 1.000 raios por fonte. . . . . . . .
5.31 Perﬁs de tempos de trânsito sintéticos para o modelo da intrusão de alta

leta bidimensional chapéu mexicano, com 180 coeﬁcientes.

leta bidimensional chapéu mexicano, com 405 coeﬁcientes.

64

64

65

65

66

velocidade (M3,P1). Os tempos nulos são associados a receptores não iluminados. 67

5.32 Mo3, modelo inicial: bloco de velocidade única, 2, 6 km/s com uma intrusão
de alta velocidade 6, 0 km/s. . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.33 Traçamento de raios no modelo inicial Mo3; novamente, foram utilizados 1.000
raios partindo de cada fonte. Modelo parametrizado com 180 coeﬁcientes. . .
5.34 Perﬁs de tempos de trânsito sintéticos para o modelo inicial (Mo3). Os tempos
. . . . . . . . . . . . . . .
5.35 Modelo Invertido, M3,I, obtido através dos algoritmos de Monte Carlo e Gauss-
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

nulos são associados a receptores não iluminados.

Newton combinados.

68

68

69

70

Índice de Figuras

por inversão; 1.000 raios por fonte.

5.36 Traçado de raios para o modelo da intrusão de alta velocidade, M3,I, obtido
. . . . . . . . . . . . . . . . . . . . . . .
5.37 Perﬁs de tempos de trânsito sintéticos para o modelo da intrusão de alta
velocidade obtido por inversão (M3,I). Os tempos nulos são associados a
receptores não iluminados.
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.38 Diferença relativa entre as velocidades do modelo invertido, M3,I e alvo para-
. . . . . . . . . . . . .

metrizado, M3,P1, para a intrusão de alta velocidade.

xi

70

71

72

Introdução

As ondaletas (wavelets, em inglês) são funções matemáticas capazes de decompor, repre-
sentar ou descrever outras funções, de forma a permitir uma análise destas em diferentes
escalas. Em certo sentido, a análise de uma função por série ondaleta guarda alguma seme-
lhança com a análise em série de Fourier entretanto, se mostra muito mais eﬁcaz no trato
de sinais estacionários (Morettin, 1999). A aplicação das ondaletas é vasta; devida à sua
capacidade em decompor funções - tanto no domínio do tempo, quanto no da escala - as
ondaletas são ferramentas poderosas no processamento de sinais. Aplicam-se muito bem
também à compressão de dados, processamento de imagens (Ponti, 2011), medicina (Traina
et al., 2003), meteorologia, economia e estatística.

Neste trabalho, é mostrada uma aplicação das séries ondaletas: conferir uma função mate-
mática que correlacione eﬁcazmente dados discretos de um domínio com os valores de suas
imagens. Particularmente, é usada a ondaleta do tipo “chapéu mexicano” para esta tarefa. A
ideia é que, em um certo modelo geológico, para cada ponto (x, z) existe uma função v(x, z)
que é a velocidade das ondas sísmicas em subsuperfície. Admite-se que se conhecem x, z
e v(x, z) (como uma distribuição discreta de valores), mas não a sua relação matemática.
Conhecer essa relação, através da análise por série ondaleta, é um dos objetivos do trabalho.
Outros trabalhos, em geofísica, já possuem abordagens parecidas - tais como ondaletas dos
tipos Haar e Morlet, por exemplo - nestes, os campos de velocidades são parametrizados por
séries ondaletas unidimensionais (Martinez e Figueiró, Perin e Figueiró, 2011); o que há de
novo aqui é:

1. O tipo de série ondaleta usada, a chapéu mexicano; e

2. A implementação da série ondaleta bidimensional.

No início do trabalho é feita uma apresentação da fundamentação teórica geral e da meto-
dologia, no que concerne às ondaletas, apresentando sua formulação básica, alguns de seus
tipos com um enfoque àquela denominada chapéu mexicano e à sua versão bidimensional.
Também são discutidos a teoria concernente ao traçamento de raios sísmicos e seu papel na

1

Introdução

2

modelagem direta de tempos de trânsito e, por ﬁm, uma abordagem da modelagem inversa
em geofísica, e particularmente dos algoritmos de Monte Carlo e Gauss-Newton, utilizados na
pesquisa. Em seguida serão apresentados os resultados alcançados e as conclusões baseadas
nestes.

1

Parametrização

1.1

Introdução às Ondaletas

As ondaletas podem ser pensadas como alternativas a outros sistemas de funções, usados
como bases para representação de funções (Morettin, 1999) pertencentes a certos espaços
(como senos e cossenos, polinômios ortogonais, funções de Haar, Walsh, etc).
Bases de Fourier (compostas por funções trigonométricas) são localizadas na frequência, mas
não no tempo; já as ondaletas localizam-se no tempo (ou no espaço), o que as torna ideais
para analisar sinais não estacionários. A ﬁlosoﬁa, tanto na análise usando a série ondaleta,
quanto a de Fourier (ou qualquer outra base) é aproximar uma função por combinações
lineares de funções que constituem a respectiva base. Comparativamente, são necessárias
menos ondaletas do que senos e cossenos (como no caso da análise de Fourier) para aproximar
funções com picos e descontinuidades, obtendo assim, via de regra, resultados mais acurados
com menor custo computacional.

1.1.1 Função ondaleta

Funções periódicas, de períodos 2⇡ e quadrado integráveis, L2(0, 2⇡), são geradas (na análise
de Fourier) por superposições de exponenciais complexas,  n(x) = einx, n 2 Z, obtidas por
compressões da função  (x) = eix ou seja,  n(x) =  (nx). A ideia é aplicar este raciocínio
para todo o L2(R), quer dizer, gerar este espaço partindo de uma única função,  . Isso pode
ser conseguido através de translações e compressões (ou dilatações) de  , tais como:

(1.1)

 a,b(x) = |a| 1/2 ✓x   b

a ◆ a, b 2 R, a 6= 0.

3

Parametrização

4

A função   é conhecida como função ondaleta (ondaleta-mãe); os parâmetros a e b que
aparecem na Eq. (1.1) são, usualmente, substituídos por valores especiais:

e

o que resulta, fazendo-se x = t em:

a = 2j,

b = k2j,

 j,k(t) = 2 j/2 (2 jt   k); j, k 2 Z.

(1.2)

(1.3)

(1.4)

Retomando a ideia principal, quer-se escrever uma função qualquer f (t) 2 L2(R) como
combinação linear das ondaletas que formam a base gerada pelas funções dadas pela Eq.
(1.4). Com o auxilio de um escalar cj,k, pode-se escrever esta combinação por meio de
somatórios, dado por:

f (t) =

1Xj= 1

1Xk= 1

cj,k j,k(t).

(1.5)

Diz-se que a Eq. (1.5) é uma série ondaleta de f(t). É de óbvio interesse, a obtenção dos
valores dos cj,k, chamados coeﬁcientes da série ondaleta; e, quando a base de funções  j,k é
ortonormal, eles são dados por:

cj,k = hf,  j,ki =

1Z 1

f (t) j,k(t)dt.

(1.6)

1.1.2 Propriedades das Ondaletas

A função  (t) (e  j,k(t): ondaletas ﬁlhas) goza de certas propriedades. Vale mencionar:

Propriedade 01: Admissibilidade ou média zero

1Z 1

 (t)dt = 0.

(1.7)

Parametrização

Propriedade 02: Energia Finita

Propriedade 03:

1Z 1
   b (!)   
1Z 1

|!|

| (t)|2 dt < 1

2

d!< 1,

5

(1.8)

(1.9)

admitindo que b (!) é a transformada de Fourier da função  (t), e que b (0) = 0 (o que

equivale, matematicamente, à Propriedade 01).

1.1.3 A função Escala

As ondaletas, em geral, possuem uma função associada, conhecida como função escala, ou
ondaleta-pai,  . Esta função é importante por poder servir de base para geração de ondaletas.
A função escala,  , é uma solução da função

 (t) = p2Xk

`k (2t   k).

A função   gera uma família ortonormal em L2(R),

 j,k(t) = 2 j/2 (2 jt   k), j, k 2 Z.

A função  , pode ser obtida da função   por

 (t) = p2Xk

A relação entre h e ` é dada por:

hk (2t   k).

hk = ( 1)k`1 k,

(1.10)

(1.11)

(1.12)

(1.13)

que é conhecido como quadrature mirror ﬁlter relation (Morettin, 1999). Em verdade, `k e
hk são coeﬁcientes de ﬁltro passa-baixa e passa-alta, respectivamente, usados para calcular a
transformada de ondaleta discreta (Morettin, 1999). A obtenção de `k e hk se faz da seguinte
maneira:

e

`k = p2

hk = p2

1Z 1
1Z 1

 (t) (2t   k)dt,

 (t) (2t   k)dt.

(1.14)

(1.15)

Parametrização

As Eqs. (1.10) e (1.12) são conhecidas como equações de dilatação. Se o sistema

{ j,k(t),  j,k(t)}, j, k 2 Z

é ortonormal, f (t) 2 L2(R) é escrita como:

6

(1.16)

f (t) =

1Xk = 1

cjo,k jo,k(t) +

1Xj jo

1Xk = 1

dj,k j,k(t),

(1.17)

onde os coeﬁcientes cjo,k e dj,k podem ser obtidos por:

cjo,k = hf,  jo,ki =

dj,k = hf,  j,ki =

1Z 1
1Z 1

f (t) jo,k(t)dt

f (t) j,k(t)dt

(1.18)

(1.19)

A esta altura, é importante fazer duas observações:

1. Os limites que aparecem nos somatórios das Eqs. (1.5) e (1.17) para j e k não podem
ser, em aplicações práticas, inﬁnitos. Na realidade, a escolha cuidadosa dos valores
mínimos e máximos de j e k pode diminuir a quantidade de coeﬁcientes e aumentar a
acurácia da representação de f (t) por série ondaleta.

2. A obtenção dos coeﬁcientes cj,k através da Eq. (1.6) só é possível quando a função
ondaleta, escolhida produz uma base ortonormal de funções dadas pela Eq. (1.4). A
ondaleta do tipo chapéu mexicano - que é usada neste trabalho - não forma uma base
ortonormal (Misiti et al., 2013). Portanto, uma outra estratégia deve ser adotada para
o cálculo dos coeﬁcientes cj,k. Tal estratégia consiste no uso do Método dos Mínimos
Quadrados (MMQ), que é discutida mais adiante.

1.2 Alguns exemplos de Ondaletas

Nesta seção serão apresentadas, apenas em caráter ilustrativo, algumas funções ondaletas,
 (t), acompanhadas de seus gráﬁcos, eventualmente, as respectivas funções escalas,  (t).

1.2.1 Ondaleta Haar

A ondaleta Haar é a mais antiga e de formulação mais simples. A sua função ondaleta é:

Parametrização

 H(t) =

ao passo que sua função escala é:

8>>>>>>>><>>>>>>>>:

1

+1, se t 2 <1 =0;
2
; 1
 1, se t 2 <2 =1

2

0, se t /2 < = <1 [ <2 ;

 H(t) = ⇢ 1 se t 2 < = [0, 1[

0 se t /2 < .

7

(1.20)

(1.21)

Os gráﬁcos de  H(t) e  H(t) são mostrados nas Figs. 1.1(a) e 1.1(b), respectivamente.

(a) Função ondaleta Haar,  H(t).

(b) Função escala Haar,  H(t).

Figura 1.1: A ondaleta Haar e sua função escala.

1.2.2 Ondaleta Morlet

A ondaleta Morlet é dada pela seguinte função complexa:

 M (t) = ei!ote t2/2,

(1.22)

cujo gráﬁco da parte real é mostrado na Fig. 1.2.

Parametrização

8

Figura 1.2: Parte real da função ondaleta Morlet, Re( M (t)).

1.2.3 Ondaleta Shannon

A função ondaleta Shannon consiste de uma função cosseno que oscila com amplitudes
limitadas por uma função sinc, tal como:

 S(t) =

sin✓⇡t
2◆

⇡t
2

cos✓3⇡t

2 ◆ = sinc⇣n⇡

2 ⌘ · cos✓3⇡t
2 ◆ .

(1.23)

Ela é graﬁcamente mostrada na Fig. 1.3.

Figura 1.3: Função ondaleta Shannon,  S(t)

Parametrização

9

1.2.4 Ondaleta Chapéu Mexicano

É obtida pela segunda derivada normalizada negativa da função densidade de probabilidade
gaussiana. É contínua (diferentemente da Haar), suave, simétrica em relação ao eixo vertical
(t = 0) e tende assintoticamente para zero quando t !±1 . Sua função ondaleta é:

 CM (t) = (1   t2)e t2/2.

(1.24)

Por simplicidade e por não haver perigo de confusão, o superescrito CM será omitido na
notação que segue. Neste trabalho, foram usados fatores
e  2 para correção da
expressão de  (t), resultando 1 em:

⇡1/4 p3 

2

 (t) =

2

⇡1/4p3 ✓1  

t2

 2◆ e  t2

2 2 .

(1.25)

Em teoria estatística, a função densidade de probabilidade gaussiana contém dois parâme-
tros, µ e  . O primeiro, µ, representa a média dos valores (aqui µ = 0, resultando que t = 0
torna-se o eixo de simetria do gráﬁco da função); já o segundo parâmetro,  , simboliza o
desvio padrão dos dados. Neste trabalho, entretanto, o valor de   foi arbitrado em 1,22 (este
valor produziu melhores resultados); note-se que   = 1, levaria à função chapéu mexicano
que aparece comumente em outros textos como em (Morettin, 1999).

O gráﬁco da ondaleta chapéu mexicano normalizada é mostrado na Fig. 1.4.

Figura 1.4: Ondaleta chapéu mexicano normalizada,  (t).

1Estes fatores, bem como a expressão da Eq.

(1.25), constam de um trabalho obtido no sítio da
Shangai Mathematical Society, disponível em: < http://sms.math.ecnu.edu.cn/lu/Lecture%20Notes/Notes_
Wavelets.pdf > Acesso em: 13 Setembro 2013.

Parametrização

10

Combinando-se as Eqs. (1.25) e (1.4), chega-se à função elementar pertencente à base que é
largamente utilizada no desenvolvimento desta pesquisa, a saber:

cujo gráﬁco, para k > 0 é mostrado na ﬁgura 1.5

(2 jt   k)2

 2

◆ e  (2 j t k)2

2 2

,

(1.26)

 j,k(t) = 2 j/2

2

⇡1/4p3 ✓1  

Figura 1.5: Função ondaleta chapéu mexicano,  j,k(t), para k > 0.

1.3 Ondaletas Bidimensionais

Alguns trabalhos em geofísica, que se propõe a parametrizar campos de velocidades uti-
lizando ondaletas, fazem uso das ondaletas unidimensionais, tal qual apresentado na Eq.
(1.5). No presente trabalho, propõe-se a utilização das ondaletas em sua forma bidimensi-
onal, cujo formalismo (Morettin, 1999) é apresentado a seguir. Admitindo que uma função
bidimensional f (x, y) possa ser representada por uma série ondaleta, também bidimensional,
µI(x, y), pode-se escrever, em analogia com a Eq. (1.5), o seguinte:

onde I é um vetor de índices dado por:

f (x, y) = XI

dIµI(x, y),

I = (j1, j2, k1, k2).

(1.27)

(1.28)

Parametrização

11

A ondaleta bidimensional µI(x, y) é escrita como:

(1.29)
Se a base   = {µI(x, y) , I = (j1, j2, k1, k2)} for ortonormal, então os coeﬁcientes dI que
aparecem na Eq. (1.27) podem ser obtidos do seguinte modo:

µI(x, y) =  j1,k1(x) j2,k2(y).

dI = hf, µIi = ZZ<

f (x, y)µI(x, y)dxdy,

(1.30)

onde < é o domínio de deﬁnição de f (x, y). Entretanto, no caso da chapéu mexicano,
utilizada neste trabalho, a base formada não é ortonormal. Sendo assim, os coeﬁcientes dI
serão calculados com a técnica dos mínimos quadrados, isto é:

onde

D =  MT M  1 MT F,

D = [dI1 dI2 ··· dIi ··· dIN ]T ,

Mi = ⇥ µIi(x1, y1) µIi(x1, y2)

é a i-ésima coluna da matriz M e

··· µIi(xp, yq)

··· µIi(xP , yQ) ⇤T

(1.31)

(1.32)

(1.33)

F = ⇥ f (x1, y1) f (x1, y2)

(1.34)
sendo (xp, yq) um nó genérico da malha (de P ⇥ Q nós) colocada sobre <, e N é o número
máximo de vetores de índices (I) usados na série dada pela Eq. (1.27).

f (xP , yQ) ⇤T ,

···

f (xp, yq)

···

1.4 Metodologia da Parametrização

Esta etapa do trabalho consiste, basicamente, em desdobrar as Eqs. (1.5), (1.27) e (1.31) a
ﬁm de criar algoritmos numéricos capazes de gerar séries ondaleta (tanto uni quanto bidi-
mensional) que representem eﬁcazmente funções, bem como campos de velocidades sísmicas
provenientes de modelos geológicos propostos.

Parametrização

12

1.5 Parametrização Unidimensional

Com o objetivo de realizar um primeiro teste de validação da ondaleta chapéu mexicano,
propõe-se veriﬁcar sua eﬁcácia em parametrizar uma função matemática conhecida. Trata-se
da parábola restrita:

f (x) = ⇢ x(3   x)

0

se x 2 [0, 3]
se x /2 [0, 3]

.

(1.35)

O gráﬁco desta função pode ser visto na Fig. 1.6:

Figura 1.6: Gráﬁco de uma parábola restrita. Os valores de f (x) são nulos fora do

domínio [0, 3].

A escolha não foi por acaso: este tipo de função se assemelha aos eventos naturais que têm
duração e energia ﬁnitas.

A estratégia é “colher” da função alguns valores de x e suas respectivas imagens f (x), for-
mando pares ordenados (x, f (x)). Esses pontos servirão de partida para a obtenção da série
ondaleta que representa a função.

1.6 O método dos Mínimos Quadrados

A partir daqui, não será possível avançar sem antes discutir como são obtidos os coeﬁcientes
cj,k da Eq. (1.5), através do método dos mínimos quadrados, que é deﬁnido pela equação:

C =   T    1  T F,

(1.36)

Parametrização

13

onde F é o vetor que contem as n imagens de valores assumidos pela função f (x), ou seja:

F = ⇥ f (x1) f (x2)

···

f (xn) ⇤T ,

(1.37)

a matriz   é a aquela em que cada elemento é o resultado da Eq. (1.26) resolvida pra cada
um dos valores de j e k: fazendo-se t = xi, com i 2{ 1, 2,··· , n}, para os n valores de x
nos quais a função f é amostrada. Sendo assim:

 = 2664

 jm,km(x1)  jm,km+1(x1)
 jm,km(x2)  jm,km+1(x2)

. . .   jm,kM (x1)  jm+1,km(x1)
. . .   jm,kM (x2)  jm+1,km(x2)

...

. . .   jM ,kM (x1)
. . .   jM ,kM (x2)

 jm,km(xn)  jm,km+1(xn)

. . .   jm,kM (xn)  jm+1,km(xn)

. . .   jM ,kM (xn)

3775 (1.38)

As notações foram sintetizadas, de forma que jm, jM, km, kM representam, respectivamente,
os valores mínimos e máximos assumidos por j e k.
Nesse contexto, C é o vetor dos coeﬁcientes cj,k. Isto é,

C =

c1
c2
...

cl

26666666664

37777777775

=

26666666664

cjm,km
cjm,km+1

...

cjm,kM

cjm+1,km...

cjM ,kM

,

37777777775

(1.39)

é um vetor com l coeﬁcientes, onde

l = (|jM   jm| + 1) · (|kM   km| + 1).

(1.40)

Assim sendo, a escolha dos valores mínimos e máximos de j e k deve ser apropriada, a ﬁm
de garantir boa representação da função, com o menor custo computacional.

1.7 Etapas do Processamento numérico

O uso do método dos mínimos quadrados, Eq. (1.36), pode envolver grandes matrizes (de-
pendendo do tamanho destas, basicamente, da quantidade n de pares ordenados tomados

Parametrização

14

da função e dos valores escolhidos para j e k). O uso da computação é indispensável para
tanto. Nesta pesquisa, vêm sendo utilizados programas de computador, autorais, escritos na
linguagem FORTRAN 90.

As etapas do processamento para representar a função dada pela Eq. (1.35) por série onda-
leta na forma dada pela Eq. (1.5) são, basicamente:

• Colecionar os n valores de x e f (x) a partir da função a ser representada, construindo-se

o vetor F segundo a Eq. (1.37);

• Montar a matriz  , seguindo o ordenamento de linhas e colunas, bem como a progressão
dos valores de j e k, tal como mostrado na Eq. (1.38). Para tanto, utilizam-se os n
valores de x (nos quais a função é amostrada), j e k, que comparecem na Eq. (1.5),
para alimentar as funções  j,k(x);

• De posse da matriz  , e do vetor F, obter o vetor C dos coeﬁcientes cj,k, resolvendo-
(1.36). É a etapa mais pesada do processo, já que envolve transposição,

se a Eq.
multiplicação e inversão de matrizes.

• De posse dos coeﬁcientes cj,k, estes são utilizados na Eq. (1.5) a ﬁm de representar a

função f (x) por uma série ondaleta.

1.8 Parametrização Bidimensional

Conforme será mostrado, o primeiro teste da série ondaleta chapéu mexicano mostrou-se
eﬁcaz na parametrização de funções unidimensionais. Assim sendo, o passo natural é avançar
na parametrização de funções bidimensionais. Neste sentido, antes de testar a técnica em
modelos geológicos teóricos, o que se fez foi escolher uma função matemática bidimensional
bem conhecida, a sela restrita:

f (x, y) = ⇢ x · y se [x, y] 2 U = [ 2, 2] ⇥ [ 2, 2]

se [x, y] /2 U .

0

(1.41)

O gráﬁco desta função (na realidade um mapa de contorno) pode ser visto na Fig. 1.7:

Parametrização

15

Figura 1.7: Gráﬁco de uma sela restrita. Os valores de f (x, y) são nulos fora do

domínio [ 2, 2] ⇥ [ 2, 2].

(1.27) é verdadeira para somatório inﬁnito ou seja, para os valores dos índices
A Eq.
j1, j2, k1, k2 variando de  1 à 1. Na prática, uma escolha de valores convenientes para
os índices diminui a quantidade de coeﬁcientes dI e garante, com boa aproximação, que estas
equações ainda serão válidas. O processo de escolha destes índices, neste trabalho, foi em-
pírica. Para a parametrização (eﬁcaz) desta função, sela restrita, foram usados os seguintes
índices:

(j1m =  1, j1M = 1, j2m =  1, j2M = 1

k1m =  6, k1M = 6, k2m =  6, k2M = 6

.

As notações m e M simbolizam, respectivamente, os valores mínimos e máximos de cada
índice. Esta mesma notação será bastante conveniente adiante.
A quantidade de coeﬁcientes dI obtida depende da escolha dos índices, e é dada por:

⇢ = (|j1M   j1m| + 1) ⇥···⇥ (|k2M   k2m| + 1).

(1.42)

Assim sendo, no exemplo dado anteriormente, ⇢ = 1.521 coeﬁcientes.
O ponto chave do trabalho é a obtenção dos coeﬁcientes dI; deste modo, a formação das
matrizes M e F é de importância crucial, pois elas constituirão a base para o processamento
numérico da Eq. (1.31).

A matriz F é na realidade um vetor coluna que contém os valores f (xp, yq), imagens dos
pontos (xp, yq), p 2{ 1, 2,··· , P} e q 2{ 1, 2,··· , Q} calculadas pela Eq. (1.41) nos P ⇥ Q
nós da malha colocada sobre o domínio < da função dada. Sendo assim:

Parametrização

16

(1.43)

F =

f (x1, y1)
f (x1, y2)

...

f (x1, yQ)
f (x2, y1)

...

f (xP , yQ)

26666666664

.

37777777775

Já a matriz M tem uma formatação um pouco mais complexa que a matriz   vista na Eq.
(1.38), conforme segue, sobretudo devido ao seu grande tamanho: P · Q linhas ⇥ ⇢ colunas.
Portanto:

M =

26666666664

 j1m,k1m(x1) ·  j2m,k2m(y1)
 j1m,k1m(x1) ·  j2m,k2m(y2)

 j1m,k1m(x1) ·  j2m,k2m(yQ)
 j1m,k1m(x2) ·  j2m,k2m(y1)

 j1m,k1m(xP ) ·  j2m,k2m(yQ)

···  j1M ,k1M (x1) ·  j2M ,k2M (y1)
···  j1M ,k1M (x1) ·  j2M ,k2M (y2)
...
···  j1M ,k1M (x1) ·  j2M ,k2M (yQ)
···  j1M ,k1M (x2) ·  j2M ,k2M (y1)
...
···  j1M ,k1M (xP ) ·  j2M ,k2M (yQ)

37777777775

.

(1.44)

O modo como os índices j1, j2, k1, k2 variam dos valores mínimos aos máximos na matriz
dada pela Eq. (1.44) também é importante. Isto porque cada coeﬁciente dI, obtido pela Eq.
(1.31), é indexado e deve ser multiplicado por cada termo µI(x, y) de mesmo índice, tal como
mostrado na Eq. (1.27). A escolha aqui é variar os índices de modo sequencial crescente,
nos seguintes conjuntos: j1 2{ j1m,··· , j1M}, j2 2{ j2m,··· , j2M}, k1 2{ k1m,··· , k1M},
k2 2{ k2m,··· , k2M}.

1.9 Parametrização de Campos de Velocidades Sísmicas

O passo crucial na etapa de parametrização (fundamental ao prosseguimento do trabalho) é
aplicar a técnica da seção anterior (Teste da Parametrização Bidimensional) em campos de
velocidades sísmicas compressionais provenientes de modelos geológicos. Inicialmente o teste
será feito sobre o modelo da falha distensional, mostrado na Fig. 1.8. Um detalhamento
do modelo, bem como o resultado da aplicação da técnica, encontram-se no Capítulo dos
resultados.

Parametrização

17

Figura 1.8: Modelo da falha distensional.

1.10 Geração do campo de Velocidade Sísmica em Sub-

superfície

Uma vez deﬁnido o modelo geológico a ser trabalhado, diante do fato de que, a característica
de interesse é o campo de velocidades sísmicas compressionais em subsuperfície, o primeiro
passo é gerar este campo. Para tanto, usualmente parte-se de um modelo geológico qualita-
tivo 2D, em escala (que em geral é composto por camadas, planas ou não, podendo ou não
apresentar outras feições geológicas) e são arbitrados valores típicos de velocidade para cada
camada. A partir de então, é colocada uma malha de pontos sobre o domínio do modelo,
como na Fig. 1.9, tendo cada ponto uma coordenada horizontal (x, que simboliza a distância
em superfície), uma coordenada vertical (z, que simboliza a profundidade do ponto) e uma
velocidade sísmica associada, v(x, z).

Figura 1.9: Modelo da falha distensional com malha retangular.

A técnica desenvolvida nesta pesquisa buscou otimizar esta etapa; a ﬁgura representativa
do modelo foi trabalhada em softwares de tratamento de imagem a ﬁm de uniformizar e
realçar as cores das camadas. Depois, a ﬁgura foi “lida” no Octave (software open source

Parametrização

18

de modelagem numérica). Neste processo, a cada pixel da imagem é associado um valor
correspondente à sua cor na escala RGB. Uma matriz de 3 colunas e r · s linhas é então
obtida como saída desta etapa (r é a quantidade de pixels na horizontal e s na vertical).
Note-se que a malha pode ser tão reﬁnada quanto à quantidade de pixels da imagem.

A matriz de saída do octave é então processada em um pequeno programa escrito em FOR-
TRAN 90 a ﬁm de que números inteiros associados aos endereços dos pixels sejam trans-
formados em distâncias, conforme o tamanho do modelo, e os valores associados às cores
de cada pixel sejam transformados nas velocidades sísmicas correspondentes. Isto cria um
método sistemático para obtenção das velocidade sísmica através de uma malha, garantindo
bom reﬁnamento, redução de trabalho manual, e economia incomparável de tempo.

1.11 Parametrização do Campo de Velocidade

De posse dos valores da velocidades sísmicas nos pontos de interesse do modelo, e com base
nas Eqs. (1.27) e (1.29), o objetivo é obter uma série ondaleta que descreva a velocidade
sísmica, v(x, z), como função da distância x e da profundidade z, ou seja:

onde I é um vetor de índices:

v(x, z) = XI

dIµI(x, z),

I = (j1, j2, k1, k2).

Na Eq. (1.45) a ondaleta µI(x, z) é dada por:

µI(x, z) =  j1,k1(x) j2,k2(z),

(1.45)

(1.46)

(1.47)

ou seja, todo o trato é semelhante ao desenvolvido pelas Eqs.
apenas substituir y por z e f (x, y) por v(x, z).
Novamente, note-se que a Eq. (1.45) também é verdadeira para somatório inﬁnito ou seja,
para os valores dos índices j1, j2, k1, k2 variando de  1 à 1. Aqui também valerá a ideia da
escolha conveniente dos valores para os índices; na prática, uma quantidade muito pequena

(1.27) e (1.29), bastando

Parametrização

19

de índices têm conseguido parametrizar de forma satisfatória alguns modelos. Numa das
parametrizações da falha distensional, os índices usados foram:

(j1m = 1, j1M = 1, j2m = 1, j2M = 1

k1m = 0, k1M = 8, k2m = 0, k2M = 2.

A quantidade de coeﬁcientes dI obtida depende da escolha dos índices, e é dada pela Eq.
(1.42). Assim sendo, no exemplo dado anteriormente, ⇢ = 27 coeﬁcientes.
Aqui, também, o objetivo principal é a obtenção dos coeﬁcientes dI, ou seja, obter as matrizes
M e V é essencial para o cálculo da Eq. (1.48), que é uma aplicação da Eq. (1.31):

D =  MT M  1 MT V.

(1.48)

A matriz V é na realidade um vetor coluna que contém as v(xp, zq), velocidades sísmicas nos
pontos (xp, zq) do modelo, obtidas numa malha de P ⇥ Q nós, isto é:

V =

v(x1, z1)
v(x1, z2)

...

v(x1, zQ)
v(x2, z1)

...

v(xP , zQ)

26666666664

.

37777777775

(1.49)

Já a matriz M, presente na Eq. (1.48), tem uma formatação análoga à Eq. (1.44):

M =

26666666664

 j1m,k1m(x1) ·  j2m,k2m(z1)
 j1m,k1m(x1) ·  j2m,k2m(z2)

 j1m,k1m(x1) ·  j2m,k2m(zQ)
 j1m,k1m(x2) ·  j2m,k2m(z1)

 j1m,k1m(xP ) ·  j2m,k2m(zQ)

···  j1M ,k1M (x1) ·  j2M ,k2M (z1)
···  j1M ,k1M (x1) ·  j2M ,k2M (z2)
...
···  j1M ,k1M (x1) ·  j2M ,k2M (zQ)
···  j1M ,k1M (x2) ·  j2M ,k2M (z1)
...
···  j1M ,k1M (xP ) ·  j2M ,k2M (zQ)

37777777775

.

(1.50)

2

Modelagem Direta

2.1

Introdução

A geofísica pode ser entendida como uma tecno-ciência que busca levantar característica de
subsuperfície a partir de dados obtidos por métodos empregados em superfície, em poços,
ou mesmo no ar. Por outro lado, a física envolvida nestes métodos é tal que apenas se
conhecem os dados de resposta, os quais, supostamente, advêm de algum modelo único,
porém desconhecido, que representa a subsuperfície. De maneira geral, o dados geofísicos
são discretizados, havendo óbvia relação entre estes e o modelo. Admitindo que esta relação
é linear, pode-se escrever:

d = Gm.

(2.1)

Nesta equação, d simboliza o vetor de dados d = [d1 d2 ··· dM ]T , m representa o vetor
de parâmetros do modelo m = [m1 m2 ··· mN ]T . A matriz GM⇥N dá a correlação entre o
vetor de dados d e o vetor de parâmetros do modelo m. Quando se conhece o modelo m
e, a partir deste, se obtém os dados d, a operação é conhecida como modelagem direta; se,
por outro lado, são conhecidos os dados d e, a partir destes, se objetiva descobrir o modelo
m que os geram, então a operação é conhecida como modelagem inversa (ou, simplesmente,
inversão). Isto está ilustrado na Fig. 2.1.

20

Modelagem Direta

21

Figura 2.1: Relação entre modelo e dados.

Neste trabalho, o vetor m de parâmetros compreende o conjunto dos coeﬁcientes da série
ondaleta que representa o modelo de subsuperfície, ao passo que o vetor de dados d é a coleção
dos tempos de trânsito das ondas sísmicas compressionais (apenas as primeiras chegadas
foram computadas, como será explicado adiante). A modelagem direta foi amplamente
utilizada, tanto para a obtenção dos tempos de trânsito dos raios sísmicos no modelo alvo
(sintético), como para a obtenção dos tempos trânsito nos modelos correntes, trabalhados
nos algoritmos de inversão; o processo de obtenção destes tempos de trânsito é descrito a
seguir.

2.2 A Teoria do Raio

O traçamento de raios é uma técnica utilizada na modelagem direta dos tempos de trânsito
das ondas sísmicas em subsuperfície. Fundamenta-se na teoria do raio sísmico, o qual tem
origem na propagação de ondas sísmicas (sejam ondas compressionais ou cisalhantes) em
subsuperfície nos meios heterogêneos. A teoria do raio resulta da suposição de existência da
solução de altas frequências para a equação elastodinâmica e, assim sendo, a solução obtida
para a propagação das ondas nos meios elásticos não é exata (Martinez e Figueiró, 2011);
ainda assim, este recurso reproduz com boa ﬁdelidade as linhas perpendiculares às frentes
de onda em meios isotrópicos, que são as trajetórias dos raios sísmicos. No que concerne aos
problemas práticos relacionados à prospecção e exploração de hidrocarbonetos, tal suposição
encontra boa aplicabilidade.

A parte relativa aos aspectos práticos do traçamento de raios está transcrita do trabalho
de (Dos Santos, 2009) e é a seguir apresentada.

O traçamento de raios usa uma solução particular do sistema de equações do raio (ˆCervenˆy,
2001):

Modelagem Direta

22

(2.2)

d ~X(u)

du

= (pkpk)

n

2  1 · ~P (u)

d ~P (u)

du

=

1
n · ~r[

1
vn ]

.

dT
du

= (pkpk)

n

2 = v n

Neste sistema, ~X(u) = (x(u), z(u)) simboliza o vetor posição; já ~P (u) = (p1(u), p2(u))
representa o vetor vagarosidade que, em meios isotrópicos, é um vetor perpendicular à frente
de onda (ou, de forma equivalente, tangente à trajetória do raio), portanto fornecerá a dire-
ção de propagação ondulatória em cada ponto do meio. Não obstante, v = v(x, z) é o valor
da velocidade da onda sísmica em cada ponto (x, z) do meio.

O sistema de Eqs. (2.2) pode ser reescrito por uma mudança da variável u correspondendo
a diferentes valores de n. No presente trabalho, é utilizado o valor de n = 2 e o parâmetro
u é substituído por ⌧, resultando na Eq. (2.3):

8>>>>>>>>>><>>>>>>>>>>:

8>>>>>>>>>>><>>>>>>>>>>>:

d ~X(⌧ )

d⌧

= ~P (⌧ )

d ~P (⌧ )

d⌧

=

1

2 · ~r

1

v2(x, z) 

,

dT
d⌧

=

1

v2(x, z)

⌧ = Z T

0

v2(x, z)dT.

(2.3)

(2.4)

na qual o parâmetro ⌧, é dado por:

Não existe signiﬁcado físico para a variável ⌧, no entanto a mesma possui dimensão L2 · T  1,
de sorte que, no Sistema Internacional de Medidas (SI), possui a unidade de m2 · s 1. Na
Eq. (2.4), T é o tempo de trânsito da onda sísmica ao longo da trajetória descrita pelo raio
e dT é o elemento de integração temporal.

Objetivando-se obter um algoritmo que permita o traçamento numérico das trajetórias dos
raios, expande-se as Eqs.
(2.3) em série de Taylor, truncando-as a partir dos termos de

Modelagem Direta

segunda ordem (Dos Santos, 2009), o que resulta em:

~X(⌧ +  ⌧ ) = ~X(⌧ ) +

d ~X(⌧ )

·  ⌧ = ~X(⌧ ) + ~P (⌧ ) ·  ⌧

~P (⌧ +  ⌧ ) = ~P (⌧ ) +

d ~P (⌧ )

d⌧

d⌧
·  ⌧ = ~P (⌧ ) +

1

2 · ~r

1

v2(x, z)  ·  ⌧.

23

(2.5)

O vetor vagarosidade é atualizado, constantemente, através da Eq. (2.6) para satisfazer a
condição da equação iconal, em cada nó da poligonal na trajetória do raio, isto é:

       ~P       = qP 2

1 + P 2

2 =

1

v(x, z)

.

(2.6)

O sistema de Eqs. (2.5) é, em última análise, a base para um algoritmo que permite calcular
numericamente a trajetória do raio sísmico, bem como o tempo de trânsito das ondas sísmicas
ao longo destas trajetórias. Assim, foi possível escrever um programa (linguagem fortran),
que foi usado para simular a propagação de ondas sísmicas compressionais em campos de
velocidades sísmicas.

2.3 Cálculo do Tempo de Trânsito ao longo do Raio Sís-

mico

O tempo de trânsito da onda sísmica é calculado de maneira iterativa durante o traçamento
do raio, à medida que este caminha de um ponto (xN , zN ) a outro (xN +1, zN +1). Para isto,
leva-se em consideração as velocidades das ondas em cada ponto por onde o raio passa, de
maneira que o tempo do deslocamento entre os pontos (xN , zN ) e (xN +1, zN +1) é calculado
com boa aproximação através da Eq. (2.7):

T (xN +1, zN +1) =

NXi=0

1

vi · p(xi+1   xi)2 + (zi+1   zi)2.

(2.7)

Um ponto da malha (xi, zi) apresenta velocidade vi, que não é necessariamente igual à veloci-
dade do ponto (xi+1, zi+1), daí o fato de que a Eq. (2.7) ser, na realidade, uma aproximação,
podendo ser reescrita como segue:

T (xN +1, zN +1) = T (xN , zN ) +

1

vN · p(xN +1   xN )2 + (zN +1   zN )2.

(2.8)

Modelagem Direta

24

Note-se que o termo T (xN , zN ) representa o tempo de trânsito da onda sísmica (acumulado)

até a N-ésima iteração; o termo p(xN +1   xN )2 + (zN +1   zN )2 claramente representa a

distância entre os pontos (xN , zN ) e (xN +1, zN +1), de sorte que a razão entre esta distância
e a velocidade vN resulta no tempo de deslocamento da onda entre estes dois pontos (tempo
da (N + 1)-ésima iteração).

2.4 Metodologia empregada na Modelagem Direta dos

Tempos de Trânsito

2.4.1 Geometria

Para a implementação do traçamento de raios, bem como para a obtenção dos tempos de
trânsito, a geometria de aquisição foi pensada com 4 fontes distribuídas em 2 poços verticais
no modelo (x = 0, 0 e x = L, sendo L o comprimento do modelo) e 20 receptores ﬁxos,
distribuídos de maneira equidistante na superfície, conforme a Fig. 2.2. Sabe-se que este
arranjo pode até não ter grande aplicabilidade prática (há o perigo de implosão dos poços
que contém fontes detonáveis, além, é claro, do alto custo) mas, neste trabalho, teve dois
objetivos principais:

1. A clara melhoria na iluminação do modelo;

2. Redução do tempo de processamento, uma vez que, com 4 fontes e 20 receptores, são
formados (considerando-se apenas as primeiras chegadas) no máximo 80 pares fonte-
receptor (deve-se levar em conta que alguns receptores não são iluminados).

Figura 2.2: Distribuição das fontes (Si) em poços e receptores (Rj) ﬁxos na super-

fície do modelo da falha distensional.

Modelagem Direta

25

2.4.2 Ligação Fonte-Receptor

Um problema concernente à aplicação da teoria do traçamento de raios é conseguir conectar
posições de fontes e receptores, conhecido como Two-Point Ray Tracing Problem; há algumas
formas de resolver este problema, como:

1. Tentativa e erro, até encontrar o ângulo correto de saída do raio, que conecta fonte e

receptor. Método de fácil implementação, porém com alto custo de processamento;

2. Aplicar o algoritmo da bisseção a ﬁm de encontrar o ângulo de saída do raio. Tem
uma implementação um pouco menos simples, requer menos iterações que a primeira
solução. Por outro lado, deve-se levar em consideração que pequenas variações no
ângulo de saída do raio podem resultar em grandes afastamentos dos pontos de chegada
deste à superfície;

3. Aplicação do algoritmo de Newton-Raphson; este surge como um melhoramento ao
método da bisseção, tendo convergência mais rápida e, portanto, é mais eﬁciente do
ponto de vista computacional. Por outro lado, não é capaz de resolver o problema
quando o campo de velocidades apresenta pontos cáusticos;

4. Lançar uma quantidade constante e razoável de raios de cada fonte, com ângulos
igualmente espaçados entre eles, e considerar que o raio atinge certo receptor quando
este chega em posição aproximada daquela na qual o receptor realmente se encontra.
É um método de caráter aproximado, de fácil implementação e de número de iterações
controlado, ou seja, pode-se prever e regular seu custo computacional.

Neste trabalho foram testadas as soluções descritas nos itens 3 e 4, tendo sido adotada a
última. A razão disto, além da obtenção de maior taxa de sucesso, é que foi possível realizar
o traçamento de raios em poucos segundos (os tempos de processamento giram em torno de
alguns décimos até 6 segundos). Como tolerância na separação entre a posição do receptor
e o ponto de chegada do raio, foi adotada 1
5

do espaçamento entre receptores.

2.4.3 Primeiras Chegadas e Processamento Paralelo

Por uma questão de simpliﬁcação, tanto de implementação quanto do processamento, ape-
nas os tempos das primeiras chegadas foram considerados. O algoritmo foi concebido de
tal maneira que todo raio que chega à superfície é associado ao receptor mais próximo; este

Modelagem Direta

26

raio é substituído por outro, caso este se aproxime ainda mais do receptor. Se dois ou mais
raios são associados ao mesmo receptor (mesma distância em relação à este) será considerado
aquele de menor tempo de trânsito ou seja, são computadas apenas primeiras chegadas. A
quantidade de raios que parte de cada fonte variou ao longo de diversas experimentações
feitas no trabalho, de 75 a 5.000; obviamente isto inﬂuencia no tempo de processamento.

O uso de processamento paralelo 1 foi intenso em todo o trabalho; no traçamento de raios,
não foi diferente. Como cada fonte independe da outra, o processamento dos raios se deu
de forma paralela, ou seja, cada fonte teve seus raios traçados num núcleo independente
do processador, totalizando 4 núcleos de processamento. Isto signiﬁca que o traçamento de
raios foi feito com uma velocidade aproximadamente 4 vezes maior do que se fosse feito de
modo serial (note-se que há partes do código que não são paralelizáveis).

1A programação em paralelo, neste trabalho, consistiu na inserção das diretivas OpenMP nos códigos

originais. Uma apresentação destas diretivas encontra-se no Anexo I.

3

Modelagem Inversa

3.1

Introdução

Conforme foi discutido no capítulo anterior, em levantamentos geofísicos apenas se conhecem
os dados de resposta dos métodos empregados. Assim sendo, de acordo com a Fig. 2.1, deve-
se aplicar a modelagem inversa, a ﬁm de determinar o modelo que representa a subsuperfície,
a partir destes dados. Em outras palavras, trabalhar a equação matricial que aparece na
Eq. (2.1) de modo a obter m; se a matriz GM⇥N é conhecida e inversível, salvo diﬁculdades
inerentes à tarefa de inversão computacional de uma matriz que possui inversa, do ponto de
vista estritamente teórico, a obtenção da solução da equação torna-se uma tarefa simples:
m = G 1d. Entretanto, de maneira geral, esta matriz não é inversível, fato que requer
tratamentos matemáticos mais rigorosos. Mesmo no caso dela não ser singular, o trabalho
de obtenção de sua inversa pode ser muito penoso.

Os problemas geofísicos mais comuns, via de regra, possuem uma maior quantidade, M,
de dados do que, N, de parâmetros (incógnitas); o sistema m = G 1d é, assim, dito sobre-
determinado. Não obstante, é também possível encontrar sistemas determinados (M = N)
ou subdeterminados (M < N). A solução destes sistemas perpassa pela satisfação de 3
critérios:

• Existência: O sistema linear deve possuir solução;

• Unicidade: A solução deve ser única. Como não se conhece de fato a subsuperfície,
é possível obter-se mais de um modelo que leve às mesmas respostas físicas obtidas a
partir do modelo verdadeiro, o que conﬁguraria uma ambiguidade da solução. Dito de

27

Modelagem Inversa

28

modo mais simples: diferentes modelos podem gerar o mesmo dado; e

• Estabilidade: A solução deve ser robusta à ponto de não ser facilmente perturbada a

partir de pequenas variações (presença de ruído) nos dados de entrada.

O problema é dito mal posto quando não atende à pelo menos um destes critérios sendo que,
no geral, inversões geofísicas são problemas mal postos, exatamente por falharem no crité-
rio da unicidade ou estabilidade (Rodrigues, 2015). Informações a priori, dados geofísicos
obtidos por outros métodos, dados geológicos e tratamentos numéricos tendem a reduzir a
ambiguidade e melhorar a estabilidade do problema.

3.2 Problemas não Lineares

A maior parte dos problemas geofísicos guarda uma relação não linear entre o vetor de dados,
d, e o modelo, m, podendo a Eq. (2.1) ser reescrita como segue:

d = g(m),

(3.1)

na qual g é o operador de modelagem direta (Sen e Stoﬀa, 2013). Neste sentido, a busca
pelo modelo m que satisfaça à Eq. 3.1 para um vetor de dados, d, conhecido, passa a ser
uma tarefa ainda mais difícil quando comparada com o caso linear.

Os métodos de modelagem inversa (ou, simplesmente, inversão) usados com este objetivo
podem ser classiﬁcados em dois grandes grupos:

• Métodos de escopo global: de maneira geral carregam nos seus algoritmos o uso de
alguma técnica envolvendo aleatoriedade, na busca por um mínimo global da função
erro objetivo. Como vantagem, apresentam uma menor dependência do modelo inicial,
porém, sua convergência é mais demorada e menos acurada. Os métodos de escopo
global mais conhecidos são: Monte Carlo (usado neste trabalho), Simulated Annealing,
Algoritmo Genético, Redes Neurais, e etc.

• Métodos de escopo local: a busca pelo mínimo da função erro objetivo se restringe
ao mínimo local; exatamente por isso, guardam maior dependência do modelo inicial.
Tem convergência muito mais rápida que os algoritmos de escopo global, entretanto
o modelo corrente não pode estar muito longe do mínimo global ou do domínio de
convergência do método. Os métodos de escopo local mais conhecidos são: “Steepest
Descent”, Newton e o de Gauss-Newton (que foi utilizado nesta pesquisa).

Modelagem Inversa

29

Diante do exposto, evidencia-se a comum associação entre os métodos: os de escopo global
prestam-se a aproximar o modelo corrente do mínimo global, garantindo um bom modelo
inicial para uso num método de escopo local.

3.3 A Função Erro Objetivo

1 dobs
2

Seja dobs = ⇥dobs
geofísico empregado). No caso sintético, tal dado é obtido a partir de um modelo m =
[m1 m2 ··· mN ]T . Da Eq. (3.1) pode-se escrever:

M⇤ o vetor dos dados observados (respostas de campo do método

··· dobs

dobs = g(m).

(3.2)

Por outro lado, a partir de um modelo estimado mest = ⇥mest
obter-se um vetor de dados calculados, dcalc = ⇥dcalc

, dcalc

, mest
2

, ..., mest

N ⇤T é possível
M ⇤, por modelagem direta,

de tal modo que, tomando novamente como base a Eq. (3.1), surge claramente a relação
entre dcalc e mest :

, ..., dcalc

1

2

1

dcalc = g(mest).

(3.3)

A função erro utilizada nesta pesquisa, tanto para o método de Monte Carlo, quanto para o
de Gauss-Newton foi o erro RMS (Root-Mean-Square ou, em livre tradução, Raiz Quadrática
Média). Sendo E o símbolo empregado para esta função, então:

E(dcalc

j

,

(3.4)

) = vuuuuut

i   dobs

i=MPi=1 dcalc
i  2
i=MPi=1 dobs
i  2

na qual E(dcalc
mest
j

.

j

) é o erro RMS associado ao vetor de dados dcalc

do j-ésimo modelo estimado,

j

3.4 Método de Monte Carlo

Método de escopo global cuja ﬁlosoﬁa básica consiste numa busca aleatória de um modelo,
dentro do espaço de modelos (Sen e Stoﬀa, 2013), para o qual os dados calculados através
da Eq. (3.3) minimizem a função erro objetivo.

Modelagem Inversa

30

A operação do método consiste em partir de um modelo inicial, mI = ⇥mI

calcular os dados a partir deste modelo pela Eq. (3.3). De posse destes dados calculados e
dos dados observados, calcula-se o erro entre estes, por alguma função objetivo (norma L2,
erro RMS, e etc).

N⇤T e

2 ··· mI

1 mI

Logo em seguida, são criadas perturbações aleatórias nos parâmetros, a ﬁm obter-se um

novo modelo (provisório), mP = ⇥mP
1 ±  mI

mP =⇥mI

1 mP

2 ··· mP

1 mI

2 ±  mI

N⇤T , tal que:
2 ··· mI

N⇤T .
N ±  mI

(3.5)

As perturbações aleatórias  mI
modo:

n que aparecem na Eq. (3.5) podem ser geradas do seguinte

1. Parte-se se um número (pseudo) aleatório 0  A  1;
2. Normaliza-se este número A para um valor a dentro de uma faixa pretendida de per-

turbação relativa, por exemplo, entre 0, 1% e 8, 0%. Neste caso, 0, 001  a  0, 08;

3. A perturbação absoluta, em cada parâmetro, será então o produto de a pelo respectivo

parâmetro:  mI

n.
n = a · mI

De posse do modelo provisório mP , o próximo passo é gerar o vetor de dados calculados,
novamente pela Eq.
(3.3). Calcula-se então o erro associado a este modelo provisório e
compara-se com o erro anterior. Se o erro baixar, o modelo provisório é aceito e novas per-
turbações serão feitas, a partir dele; caso contrário, o modelo é rejeitado e nova perturbação
é feita no modelo inicial. O processo se repete, até que se atinja um valor ideal para o erro
(critério de parada).

Ocorre, por outro lado, o risco de ser atingido um mínimo local da função erro objetivo
(vide Fig. 3.1), levando a um modelo ﬁnal não conveniente. Uma forma de fazer o algoritmo
“escapar” de um mínimo local, é usando uma função probabilidade.

Modelagem Inversa

31

Figura 3.1: Comportamento de uma função erro hipotética em relação aos modelos
(Sen e Stoﬀa, 2013). Os pontos 1, 2 e 3 representam modelos iniciais;
também são indicados os mínimos global e locais.

Um modelo que seria originalmente descartado pelo critério de minimização do erro, pode
ser aproveitado se satisﬁzer algum outro critério, dado por uma função probabilidade. Um
exemplo de função probabilidade é a exponencial do erro:

A <

e E[dcalc(mp)]
e E[dcalc(mest)]

,

(3.6)

onde A é um número (pseudo) aleatório, 0  A  1; E é a função erro objetivo; dcalc é
o vetor de dados calculados para o modelo provisório (numerador) ou para o modelo cor-
rente (denominador). Sendo a Eq. (3.6) verdadeira, o modelo mP é aceito, caso contrário,
rejeitado. Mais uma vez, todo o processo se repete, até ser atingido algum critério de parada.

Uma descrição esquemática, com algumas adaptações, para a metodologia que foi empregada
neste trabalho, pode ser encontrada na Fig. 3.3.

3.5 Método de Gauss-Newton

Método de escopo local, também conhecido como inversão linearizada, parte do pressuposto
de que os dados variam linearmente com os parâmetros do modelo na região próxima a este
(Rodrigues, 2015). Por isto, é um método altamente dependente do modelo inicial. Na Fig.

Modelagem Inversa

32

3.1, por exemplo, se os modelos iniciais adotados fossem o 2 ou 3, fatalmente o método
faria a função erro convergir em um mínimo local e, consequentemente, daria como solução
modelos distantes do modelo alvo.

Seja dobs o vetor de dados observados (tempos de trânsito obtidos a partir do modelo alvo
sintético, m) e dcalc o vetor de dados calculados para um modelo estimado mest de tal sorte
que, supondo válida a premissa acima:

e

dobs = Gm,

dcalc = Gmest.

(3.7)

(3.8)

Por questões de sintetização de notação, o modelo estimado, mest, será simbolizado apenas
por ml, que é um modelo qualquer, corrente, na l-ésima iteração. A função erro residual,
neste caso é dada por (Dos Santos e Figueiró, 2011):

 d(ml) = dobs   dcalc(ml).

Expandindo a Eq. (3.9) numa série de Taylor até a primeira ordem, vem:

 d(ml) ⇡  d(m0) + S(m0) ml.

O termo  ml que a parece na Eq. (3.10) é a diferença:

 ml = ml   m0,

(3.9)

(3.10)

(3.11)

na qual m0 é um modelo de referência, não necessariamente o inicial (Dos Santos e Figueiró,
2011). A matriz S é conhecida como matriz sensibilidade e pode ser calculada para um
l-ésimo modelo corrente qualquer. A matriz S(ml) tem suas entradas sp,q calculadas do
seguinte modo:

sp,q(ml) =

@dcalc

(ml)

p
@mq

.

(3.12)

Modelagem Inversa

33

Resolvendo a expressão contida na Eq. (3.10), para  ml, obtém-se:

 ml =n[S(ml)]T S(ml)o 1

[S(ml)]T  d(ml).

(3.13)

A Eq. (3.13) pode ser entendida como o núcleo do algoritmo de Gauss-Newton, uma vez
que se pode obter um fator de atualização,  ml, do modelo corrente, ml, a partir da matriz
sensibilidade, S(ml) e do vetor erro residual,  d(ml). Neste sentido, a parte mais impor-
tante do método é, sem dúvida, a construção da matriz sensibilidade em cada iteração.

Os modelos podem então ser constantemente atualizados; um novo modelo é obtido a partir
do atual, ml e do fator de atualização,  ml. Para tanto, basta um rearranjo na Eq. (3.11),
resultando em:

ml+1 = ml +  ml.

(3.14)

O processo se repete, até que algum critério de parada seja atingido. O modelo invertido
será, portanto, o mais atualizado ao ﬁm do algoritmo.

3.6 Metodologia Empregada na Inversão

3.6.1 Monte Carlo

O início do processo de inversão se dá com a aplicação do algoritmo de Monte Carlo. Para
tanto, o programa concebido tem como insumos os coeﬁcientes das séries ondaleta que para-
metrizam os modelos alvo, m e inicial m0, este último representado na Fig. 3.2. É importante
que a quantidade de coeﬁcientes seja a mesma, já que se pretende chegar ao modelo alvo a
partir do inicial. Além disso, a mesma geometria de aquisição foi usada para a obtenção dos
tempos de trânsito sintéticos.

Modelagem Inversa

34

Figura 3.2: Modelo inicial m0: homogêneo com velocidade igual a 3, 0 km/s.

Uma vez dentro do programa, os coeﬁcientes servem ao cálculo dos tempos de trânsito tanto
para o modelo alvo (sendo criado o vetor Tobs) como para o modelo inicial (o vetor T1 é
calculado), conforme consta na Fig. 3.3.

Os vetores Tobs e T1 são respectivamente:

e

···
sendo N a quantidade de pares fonte-receptor.

1

t1
2

1

Tobs =⇥ tobs
T1 =⇥ t1

tobs
2

···

tobs
i

. . .

t1
i

. . .

t1

tobs

N ⇤T
N ⇤T ,

(3.15)

(3.16)

3.6.1.1 Cálculo do Erro

O erro da iteração w-ésima é calculado, com a aplicação da Eq. (3.4) substituindo o vetor
de dados calculados, dcalc, pelo vetor Tw e o vetor de dados observados, dobs, por Tobs, ou
seja:

de sorte que o vetor Tw é :

Ew = vuuuuut
Tw =⇥ tw

tw
2

1

i   tobs

i=NPi=1 tw
i  2
i=NPi=1 tobs
i  2

,

···

tw
i

. . .

tw

N ⇤T .

(3.17)

(3.18)

Vale a ressalva de que os somatórios, tanto no numerador quanto no denominador da Eq.

Modelagem Inversa

35

(3.4), somente são atualizados se tw

i e tobs

i

são não nulos (receptores iluminados).

3.6.1.2 Perturbação do Modelo e Range Sísmico

Na Eq. (1.45) os coeﬁcientes foram notados por dI; a ﬁm de evitar confusão com o símbolo d,
reservado ao vetor de dados como na Eq. (2.1), estes coeﬁcientes serão simbolizados apenas
por c, sendo cn o n-ésimo coeﬁciente do vetor de coeﬁcientes C = [c1 c2 ··· cn ··· cN ]T . A
perturbação no modelo é feita de coeﬁciente em coeﬁciente, como segue:

1. Uma faixa de perturbação é adotada, por exemplo de 0, 1% à 8, 0%;

2. Um número (pseudo) aleatório A é obtido e este é normalizado a ﬁm de que se torne

um valor dentro da faixa adotada;

3. Este valor é então multiplicado pelo coeﬁciente cn obtendo-se a perturbação absoluta

 cn;

4. Um outro número aleatório B é obtido, desta vez para determinar se a perturbação
 cn será adicionada o subtraída do coeﬁciente cn. Se B   0, 5 então exp = 1, caso
contrário, exp = 2;

5. Por ﬁm o coeﬁciente é atualizado, cn = [( 1)exp] ·  cn + cn;
6. O processo é repetido a partir do passo 2, até que todos os coeﬁcientes tenham sido

alterados e se crie assim, um novo modelo.

Uma importante adaptação em relação ao algoritmo original foi a rejeição de modelos cujas
velocidades produzidas não sejam características das ondas sísmicas, como, por exemplo,
velocidades abaixo de 1, 5 km/s ou acima de 10, 0 km/s .
Isto representa uma economia
enorme de processamento, haja vista que o traçamento de raios, para a obtenção dos tempos
de trânsito do modelo corrente, é a parte mais custosa do algoritmo.

3.6.1.3 Critérios de Parada

No programa que foi usado neste trabalho, há dois critérios de parada. O primeiro é o
número de iterações; o programa é interrompido, a despeito do valor do erro corrente, se
as iterações atingirem um número limite. Valores típicos usados foram em torno de 5.000
à 35.000 iterações. O segundo é o valor do erro RMS; espera-se que, com o avançar das
iterações, o erro RMS entre os tempos de trânsito dos modelos correntes (dados calculados)
e aqueles do modelo alvo (dados observados) baixe progressivamente, até ser atingido um

Modelagem Inversa

valor ótimo, inicialmente arbitrado.

36

Uma visão esquemática do que fora dito nos parágrafos anteriores encontra-se na Fig. 3.3. O
último modelo atualizado no algoritmo de Monte Carlo (produto) serve como modelo inicial
para o algoritmo de Gauss-Newton (insumo).

Figura 3.3: Fluxograma do algoritmo de Monte Carlo, adaptado ao trabalho aqui

desenvolvido.

Modelagem Inversa

3.6.2 Gauss-Newton

37

O programa do método de Gauss-Newton, desenvolvido para este trabalho, também tem
como insumos os coeﬁcientes das séries ondaleta que parametrizam os modelo alvo e inicial.
Desta vez, entretanto, o modelo inicial é aquele obtido como produto do algoritmo de Monte
Carlo. Inicialmente os tempos de trânsito de ambos os modelos são calculados, bem como o
erro RMS inicial.

O método, grosso modo, visa alimentar a Eq. (3.13), lembrando-se que a função erro residual
 d(ml) é na realidade um vetor erro nos tempos,  Tl de tal sorte que:

 Tl =⇥  tobs
1   tl

1   tobs
2   tl

2  ···

 tobs
i   tl

i  . . .

 tobs
M   tl

M  ⇤T .

(3.19)

Assim sendo:

 ml =n[S(ml)]T S(ml)o 1

[S(ml)]T  Tl.

(3.20)

Claramente é muito simples, inclusive computacionalmente, calcular o vetor  Tl em cada
iteração l do algoritmo de Gauss-Newton. Assim sendo, uma vez montada a matriz sen-
sibilidade, S, todo o processo se torna cálculo matricial de transposições, multiplicações,
inversões e somas.

3.6.2.1 A matriz Sensibilidade

A matriz sensibilidade tem tamanha importância para o algoritmo de Gauss-Newton que,
no programa escrito para este trabalho, a subrotina dedicada à sua elaboração é a mais
volumosa. A ﬁm de ilustrar como esta matriz é montada, bem como discutir a metodologia
empregada, considere-se um modelo parametrizado por uma série ondaleta composta por 27
coeﬁcientes e cujo traçamento de raios é semelhante àquele mostrado na Fig. 5.6, ou seja, 4
fontes em dois poços e 20 receptores em superfície, totalizando 80 pares fonte-receptor. A
matriz sensibilidade, para a l-ésima iteração, neste caso é:

Modelagem Inversa

38

(3.21)

Sl =

266666666666666664

@t1
@c1

@t2
@c1
...
@tm
@c1
...
@t80
@c1

@t1
@c2

@t2
@c2
...
@tm
@c2
...
@t80
@c2

···

···

···

···

@t1
@cn

@t2
@cn
...
@tm
@cn
...
@t80
@cn

···

···

···

···

@t1
@c27

@t2
@c27
...
@tm
@c27
...
@t80
@c27

.

377777777777777775

A relação entre os tempos de trânsito tm e o vetor de coeﬁcientes C é de tal sorte complicada
que não seria possível resolver as derivadas presentes na Eq. (3.21) de maneira analítica.
Sendo assim, optou-se por usar diferenças ﬁnitas; ocorre que a variação feita no vetor de
coeﬁcientes é em APENAS UM dos coeﬁcientes, à medida que se avançam as colunas da
matriz sensibilidade. Para ilustrar, será mostrado o processo de obtenção de dois dos termos
sm,n da matriz S a saber, os termos s1,1 e s25,7. Para o termo s1,1:

s1,1 =

@t1

@c1 ⇡⇥t1(C+)⇤  ⇥t1(C )⇤

2 ·  c1

,

(3.22)

onde, os vetores C+ e C , para o termo s1,1 (na realidade para todos os termos da primeira
coluna), são respectivamente:

e

C+ = [c1 +  c1, c2,··· , cn,··· , cN ]T

C  = [c1    c1, c2,··· , cn,··· , cN ]T .

(3.23)

(3.24)

A quantidade  c1 que aparece nas Eqs. (3.22), (3.23) e (3.24) é expressa como segue:

em que “f ator” 1 representa uma potência de 10.
Já para o termo s25,7, é

 c1 = f ator · c1,

(3.25)

s25,7 =

@t25

@c7 ⇡⇥t25(C+)⇤  ⇥t25(C )⇤

2 ·  c7

,

(3.26)

1O fator escolhido indica a sensibilidade da derivada. Valores típicos usados neste trabalho foram de

10 3, 10 4, 10 5 e 10 6, sendo 10 4 o fator que gerou melhores resultados.

Modelagem Inversa

39

onde, os vetores C+ e C , para o termo s25,7 (na realidade para todos os termos da sétima
coluna), são respectivamente:

e

C+ = [c1, c2,··· , c7 +  c7,··· , cn,··· , cN ]T

C  = [c1, c2,··· , c7    c7,··· , cn,··· , cN ]T .

(3.27)

(3.28)

A quantidade  c7 que aparece nas Eqs. (3.26), (3.27) e (3.28) é expressa como segue:

 c7 = f ator · c7.

(3.29)

Como já foi dito, o cálculo dos tempos de trânsito é feito de forma paralelizada, de maneira
que as 4 fontes utilizadas em cada modelo têm seus raios processados em núcleos de pro-
cessamento independentes. Note-se que o vetor de tempos de trânsito T = T(C+) contêm
todos os tm tempos de trânsito obtidos com a variação para mais do n-ésimo coeﬁciente, e o
vetor T = T(C ) contêm todos os tm tempos de trânsito obtidos com a variação para menos.
Assim sendo, ﬁca clara a comodidade de montar a matriz sensibilidade S coluna por coluna:
o programa paraleliza o cálculo para 8 núcleos de processamento, 4 deles trabalhando os
tempos de trânsito da n-ésima coluna com a variação para mais e outros 4 fazendo o mesmo
com a variação para menos. No ﬁm, os resultados são operados conforme exemplos das Eqs.
(3.22) e (3.26); isto signiﬁca uma velocidade quase oito vezes maior na montagem da matriz
sensibilidade quando comparada à velocidade com a qual a mesma tarefa seria realizada se
fossem calculados termo após termo.

4

Resultados Preliminares

4.1 Parametrização Unidimensional

Aqui são apresentados os resultados obtidos no inicio do trabalho, com a parametrização
unidimensional; essa etapa tem por objetivo a calibração dos algoritmos, bem como testar a
eﬁcácia da série ondaleta chapéu mexicano para seu uso na parametrização de funções. No
capítulo 1, foi proposta a parametrização da parábola restrita, Eq. (4.1) e Fig. 4.1, para
este propósito, tal como segue:

f (x) = ⇢ x(3   x)

0

se x 2 [0, 3]
se x /2 [0, 3]

.

(4.1)

Figura 4.1: Gráﬁco de uma parábola restrita. Os valores de f (x) são nulos fora do

domínio [0, 3].

Os resultados abaixo são absolutamente satisfatórios diferindo apenas na quantidade de pares

40

Resultados Preliminares

41

ordenados colhidos da função f (x), usados na Eqs. (1.36) a (1.38) e nos valores dos índices
j e k usados para formar a matriz na Eq. (1.38), o que implica em diferentes quantidades
de coeﬁcientes.

4.1.1 Primeira Parametrização

O primeiro resultado obtido foi a parametrização da parábola restrita utilizando-se 100 pares
ordenados (x, f (x)), com valores de j 2 { 1, 0, 1} e k 2 { 6, 5,··· , 5, 6}, totalizando 39
coeﬁcientes. O resultado está na Fig. 4.2:

Figura 4.2: Parábola restrita parametrizada por série ondaleta unidimensional com

39 coeﬁcientes, amostrada em 100 pontos.

4.1.2 Segunda Parametrização

Já na segunda parametrização, foram utilizados 50 pares ordenados (x, f (x)), com os mesmos
valores de j e k da primeira parametrização. O resultado está na Fig. 4.3:

Figura 4.3: Parábola restrita parametrizada por série ondaleta unidimensional com

39 coeﬁcientes, amostrada em 50 pontos.

Resultados Preliminares

42

4.1.3 Terceira Parametrização

A última parametrização foi a que utilizou menos pares ordenados (x, f (x)) (35 pares, ao
todo), e a menor quantidade de coeﬁcientes; j 2{ 0, 1, 2} e k 2{ 0, 1,··· , 7, 8}, totalizando
27 coeﬁcientes. O resultado, encontra-se apresentado na Fig. 4.4:

Figura 4.4: Parábola restrita parametrizada por série ondaleta unidimensional com

27 coeﬁcientes, amostrada em 35 pontos

4.2 Parametrização Bidimensional

Aqui novamente são apresentados resultados iniciais do trabalho, porém com a utilização da
série ondaleta bidimensional. Para calibração do algoritmo, foi parametrizada uma curva
correspondente à função sela restrita, cuja equação é:

f (x, y) = ⇢ x · y se [x, y] 2 U = [ 2, 2] ⇥ [ 2, 2]

se [x, y] /2 U

cujo gráﬁco é mostrado na Fig. 4.5:

0

,

(4.2)

Figura 4.5: Sela restrita. Os valores de f (x, y) são nulos fora do domínio [ 2, 2] ⇥

[ 2, 2].

Resultados Preliminares

43

Os coeﬁcientes que garantiram uma parametrização razoável desta função foram obtidos de
forma empírica. Ao todo foram utilizados 1.521 coeﬁcientes, e os índices j1, j2, k1 e k2
variaram de modo sequencial entre os seguintes valores:

(j1m =  1, j1M = 1, j2m =  1, j2M = 1

k1m =  6, k1M = 6, k2m =  6, k2M = 6

.

A parametrização obtida encontra-se na Fig. 4.6:

Figura 4.6: Função sela restrita parametrizada com 1.521 coeﬁcientes.

5

Resultados para Modelos de Campos de
Velocidades

Neste capítulo serão apresentados os resultados para campos de velocidades sísmicas traba-
lhados, desde a sua parametrização, utilizando diferentes quantidades de coeﬁcientes, até a
modelagem inversa.

5.1 Modelo da Falha Distensional

O primeiro modelo (M1) tratado neste trabalho foi o da falha distensional, representando 10
camadas sedimentares (separadas por interfaces não horizontais) em ambiente distensional.
O modelo foi suposto com 9, 0 km de extensão horizontal e 3, 0 km de profundidade. A
apresentação gráﬁca de M1 é feita na Fig. 5.1:

Figura 5.1: Modelo da falha distensional (M1).

44

Resultados para Modelos de Campos de Velocidades

45

Os modelos de campos de velocidades sísmicas parametrizados foram plotados de duas ma-
neiras distintas, para cada quantidade de coeﬁcientes utilizada. A primeira foi a plotagem
com o campo parametrizado sem qualquer ajuste, ou seja, ﬁdedigno às velocidades obtidas.
Na segunda, foi feito uma espécie de truncamento das velocidades; para a falha distensional,
os valores das velocidades sísmicas foram, respectivamete 1,5; 1,7; 2,0; 2,2; 2,3; 2,5; 3,0;
3,5; 4,0 e 4,5 km/s, crescendo com a profundidade. Assim, qualquer velocidade menor que
1, 6 km/s teve seu valor arredondado para o vizinho mais próximo, ou seja, 1, 5 km/s; se
o valor obtido situou-se entre 1, 6 km/s e 1, 85 km/s foi truncado para 1, 7 km/s, e assim
sucessivamente. Este processo teve por objetivo, apenas, melhorar a visualização do modelo,
já que realça detalhes ao evidenciar o limites entre as feições. Todo o processo posterior,
como traçamento de raios e aplicação dos algoritmos de inversão levou em consideração os
modelos sem ajustes.

5.1.1 Parametrizações

A primeira parametrização (P1) foi obtida utilizando-se 27 coeﬁcientes; os índices foram
j1 = j2 = 1, k1 2{ 0, 1, 2,··· , 8}, k2 2{ 0, 1, 2}. Sendo os coeﬁcientes apresentados na Tab.
5.1.

Tabela 5.1: Relação de índices e coeﬁcientes utilizados na parametrização da Falha

Distensional,

j1

j2

k1

k2

d(j1, j2, k1, k2)

j1

j2

k1

k2

d(j1, j2, k1, k2)

j1

j2

k1

k2

d(j1, j2, k1, k2)

1
1
1
1
1
1
1
1
1

1
1
1
1
1
1
1
1
1

0
0
0
1
1
1
2
2
2

0
1
2
0
1
2
0
1
2

-0,4774
-2,5656
-0,1489
-3,0910
-6,1096
-4,2943
-6,2679
-11,5444
-8,4717

1
1
1
1
1
1
1
1
1

1
1
1
1
1
1
1
1
1

3
3
3
4
4
4
5
5
5

0
1
2
0
1
2
0
1
2

-11,1434
-18,4955
-16,6095
-17,2529
-26,7175
-24,6016
-24,0149
-37,0146
-37,6100

1
1
1
1
1
1
1
1
1

1
1
1
1
1
1
1
1
1

6
6
6
7
7
7
8
8
8

0
1
2
0
1
2
0
1
2

-34,8517
-47,9853
-44,5835
-31,2458
-62,9992
-83,4823
-121,0372
-75,5884
13,5094

O campo de velocidades obtido com esta parametrização encontra-se na Fig. 5.2:

A partir das parametrizações seguintes, as tabelas com os índices e coeﬁcientes não serão
mais mostradas, por duas razões: a primeira é o volume de informação, as tabelas come-
çariam a ﬁcar grandes demais; a segunda é o fato de que, tanto a modelagem direta como
a inversa (modelos alvo e inicial) foram baseadas com parametrizações que utilizaram 27

Resultados para Modelos de Campos de Velocidades

46

(a) Sem ajustes.

(b) Com ajustes.

Figura 5.2: Parametrização do modelo da falha distensional (M1,P1) com ondaleta

bidimensional chapéu mexicano, com 27 coeﬁcientes.

coeﬁcientes.

A segunda parametrização (P2) originou melhores resultados que a primeira, utilizando 40
coeﬁcientes. Os índices foram j1 = j2 = 1, k1 2{ 0, 1, 2,··· , 9}, k2 2{ 0, 1, 2, 3}. O campo
de velocidades obtido com esta parametrização é mostrado na Fig. 5.3:

A terceira parametrização (P3), utilizando 160 coeﬁcientes, melhorou ainda mais o resultado,
evidenciando mais detalhes, conforme espera-se ao ser utilizada uma quantidade maior de
coeﬁcientes. Os índices foram j1 e j2 2{ 0, 1}, k1 2{ 0, 1, 2,··· , 9}, k2 2{ 0, 1, 2, 3}. O
campo de velocidades obtido com esta parametrização é mostrado na Fig. 5.4:

Uma última parametrização (P4) foi feita, desta vez utilizando 640 coeﬁcientes, corroborando
a melhoria do resultado com o aumento da quantidade de parâmetros. Os índices foram: j1
e j2 2{ 0, 1, 2, 3}, k1 2{ 0, 1, 2,··· , 9}, k2 2{ 0, 1, 2, 3}. O campo de velocidades obtido com
esta parametrização é mostrado na Fig. 5.5:

Resultados para Modelos de Campos de Velocidades

47

(a) Sem ajustes.

(b) Com ajustes.

Figura 5.3: Parametrização do modelo da falha distensional (M1,P2) com ondaleta

bidimensional chapéu mexicano, com 40 coeﬁcientes.

(a) Sem ajustes.

(b) Com ajustes.

Figura 5.4: Parametrização do modelo da falha distensional (M1,P3) com ondaleta

bidimensional chapéu mexicano, com 160 coeﬁcientes.

Resultados para Modelos de Campos de Velocidades

48

(a) Sem ajustes.

(b) Com ajustes.

Figura 5.5: Parametrização do modelo da falha distensional (M1,P4) com ondaleta

bidimensional chapéu mexicano, com 640 coeﬁcientes.

5.1.2 Modelagem Direta: Traçamento de Raios

Nesta seção, são apresentados os resultados do traçamento de raios para a falha distensional,
tanto a plotagem dos raios, Fig. 5.6 quanto para os tempos de trânsito. A falha distensional
servirá como modelo alvo, para o estudo da modelagem inversa. Assim sendo, os tempos
de trânsito obtidos constituem os dados sintéticos a serem trabalhados. Dado o grau de
processamento dos algoritmos de inversão, optou-se pela parametrização mais econômica, ou
seja, aquela que só utilizou 27 coeﬁcientes. O traçado foi obtido, utilizando-se 2.000 raios
partindo de cada fonte.

A partir deste traçamento, foram obtidos os tempos de trânsito, os quais estão organizados
nos perﬁs de tempos de trânsito sintéticos, nas Figs. 5.7(a) à 5.7(d).

5.1.3 Inversão

A ﬁm de proceder a modelagem inversa, foi proposto um modelo inicial, Mo1, bastante
distante daquele a ser obtido. Para tanto, foi adotado um bloco de velocidade única, cujas
dimensões são as mesmas do modelo alvo, conforme Fig. 5.8.

Resultados para Modelos de Campos de Velocidades

49

Figura 5.6: Traçamento de raios no modelo da falha distensional parametrizado por

27 coeﬁcientes (M1,P1). Foram usados 2.000 raios por fonte.

Esse modelo foi então parametrizado, adotando os mesmos índices j1, j2, k1 e k2 utilizados
para parametrizar o modelo alvo, a ﬁm de garantir a mesma quantidade de coeﬁcientes; os
índices e coeﬁcientes utilizados para parametrizar este modelo inicial encontram-se organi-
zados na tabela 5.2 Respeitando a mesma geometria de aquisição utilizada para o modelo

Tabela 5.2: Relação de índices e coeﬁcientes utilizados na parametrização do Mo-

delo Inicial, Mo1,

j1

j2

k1

k2

d(j1, j2, k1, k2)

j1

j2

k1

k2

d(j1, j2, k1, k2)

j1

j2

k1

k2

d(j1, j2, k1, k2)

1
1
1
1
1
1
1
1
1

1
1
1
1
1
1
1
1
1

0
0
0
1
1
1
2
2
2

0
1
2
0
1
2
0
1
2

-2,4068
-1,5486
-2,4058
-6,4183
-4,1297
-6,4156
-12,3402
-7,9400
-12,3349

1
1
1
1
1
1
1
1
1

1
1
1
1
1
1
1
1
1

3
3
3
4
4
4
5
5
5

0
1
2
0
1
2
0
1
2

-20,0009
-12,8692
-19,9925
-29,5547
-19,0164
-29,5422
-40,7671
-26,2308
-40,7499

1
1
1
1
1
1
1
1
1

1
1
1
1
1
1
1
1
1

6
6
6
7
7
7
8
8
8

0
1
2
0
1
2
0
1
2

-54,2623
-34,9140
-54,2393
-67,2011
-43,2388
-67,1730
–99,1574
-63,8030
-99,1139

alvo, procede-se o traçamento de raios, como na Fig. 5.9.

Os tempos de trânsito no modelo inicial, obtidos com este traçamento, encontram-se orga-
nizados nos perﬁs de tempos de trânsito sintéticos, nas Figs. 5.10(a) à 5.10(d):

Os coeﬁcientes dos modelo inicial e os tempos de trânsito do modelo alvo serão insumos para
o algoritmo de Monte Carlo. O produto deste será, por sua vez, utilizado como insumo pelo

Resultados para Modelos de Campos de Velocidades

50

(a) Fonte S1

(b) Fonte S2

(c) Fonte S3

(d) Fonte S4

Figura 5.7: Perﬁs de tempos de trânsito sintéticos para o modelo da falha dis-
tensional (M1,P1). Os tempos nulos são associados a receptores não
iluminados.

algoritmo de Gauss-Newton. A Tab. 5.3 traz o relatório do processamento 1 de cada um dos
algoritmos:

A Fig. 5.11 traz o modelo invertido da falha distensional, M1,I, após a aplicação sequen-
cial dos algoritmos de Monte Carlo e Gauss-Newton, para um modelo inicial de velocidade

1Para um detalhamento da máquina utilizada neste processamento, consultar o Anexo I

Resultados para Modelos de Campos de Velocidades

51

Figura 5.8: Mo1, modelo inicial: bloco de velocidade única, 3, 0 km/s.

Figura 5.9: Traçamento de raios no modelo inicial Mo1; novamente, foram utiliza-
dos 2.000 raios partindo de cada fonte. Modelo parametrizado com 27
coeﬁcientes.

homogênea (Fig. 5.8) parametrizado com apenas 27 coeﬁcientes. Mesmo não sendo exata-
mente o modelo alvo proposto, guarda bastante semelhança, tanto nas feições, quanto nas
velocidades.

Os índices e coeﬁcientes deste modelo invertido estão na Tab. 5.4. O traçamento de raios
foi feito, representado na Fig. 5.12, a ﬁm de calcular os tempos de trânsito:

Este traçamento originou os tempos de trânsito para o modelo da falha distensional invertido,
M1,I, organizados nos perﬁs de tempos de trânsito sintéticos, nas Figs. 5.13(a) à 5.13(d).

Finalmente, foi feita uma comparação entre as velocidades dos modelos alvo e invertido,
obtendo-se o mapa de contorno da diferença relativa, vide Fig. 5.14

Resultados para Modelos de Campos de Velocidades

52

(a) Fonte S1

(b) Fonte S2

(c) Fonte S3

(d) Fonte S4

Figura 5.10: Perﬁs de tempos de trânsito sintéticos para o modelo inicial (Mo1).

Os tempos nulos são associados a receptores não iluminados.

Tabela 5.3: Comportamento dos algoritmos de inversão - Falha Distensional.

Método No Iter. Tempo Proc. Erro Inicial Erro Final

Monte Carlo
Gauss-Newton

12.493

8

⇠ 7h
45 min

36, 79%
14, 67%

14, 67%
2, 58%

Resultados para Modelos de Campos de Velocidades

53

Figura 5.11: Modelo Invertido, M1,I, obtido através dos algoritmos de Monte Carlo

e Gauss-Newton combinados.

Tabela 5.4: Relação de índices obtidos para o Modelo Invertido, M1,I.

j1

j2

k1

k2

d(j1, j2, k1, k2)

j1

j2

k1

k2

d(j1, j2, k1, k2)

j1

j2

k1

k2

d(j1, j2, k1, k2)

1
1
1
1
1
1
1
1
1

1
1
1
1
1
1
1
1
1

0
0
0
1
1
1
2
2
2

0
1
2
0
1
2
0
1
2

-1,9443
-1,7490
-3,1677
-4,9119
-5,0601
-7,7625
-9,3450
-9,9213
-14,6339

1
1
1
1
1
1
1
1
1

1
1
1
1
1
1
1
1
1

3
3
3
4
4
4
5
5
5

0
1
2
0
1
2
0
1
2

-14,7302
-16,4228
-23,0271
-22,0530
-24,5411
-34,5671
-30,5275
-32,7598
-47,0689

1
1
1
1
1
1
1
1
1

1
1
1
1
1
1
1
1
1

6
6
6
7
7
7
8
8
8

0
1
2
0
1
2
0
1
2

-39,1992
-49,8568
-60,1476
-53,5547
-30,1110
-89,4982
-58,6541
-230,5370
-34,3102

5.2 Modelo do Domo Salino

O segundo modelo (M2) tratado neste trabalho foi o do domo salino, Fig. 5.15(a) repre-
sentando 7 camadas sedimentares (separadas por interfaces não horizontais) e uma intrusão
salina de velocidade mais elevada. Esta estrutura tem importância devido à sua propensão à
formação de reservatórios de hidrocarbonetos. O modelo foi suposto com 5, 0 km de extensão
horizontal e 3, 0 km de profundidade. A apresentação gráﬁca de M2 é feita na Fig. 5.15(b):

As cores da paleta, usadas para plotar os modelos seguintes, foram alteradas em relação
àquelas usadas nas plotagens concernentes à falha distensional. Isto possibilitou uma maior
evidenciação das estruturas principais, fazendo com que não fossem necessárias as plotagens
com velocidades truncadas.

Resultados para Modelos de Campos de Velocidades

54

Figura 5.12: Traçado de raios para o modelo da falha distensional, M1,I, obtido por

inversão; 2.000 raios por fonte.

5.2.1 Parametrizações

A primeira parametrização (P1) foi obtida utilizando-se 216 coeﬁcientes, uma quantidade
alta quando comparada àquela usada para parametrizar a falha distensional, porém ainda
razoável. Os índices foram j1 e j2 2 { 1, 0, 1}, k1 2{ 0, 1, 2, 3, 4, 5}, k2 2{ 0, 1, 2, 3}. Sendo
os coeﬁcientes apresentados no Apêndice A, Tabs. A.1 e A.2.

O campo de velocidades obtido com esta parametrização encontra-se na Fig. 5.16:

A segunda parametrização (P2) originou melhores resultados que a primeira, utilizando 600
coeﬁcientes, resultado que já era esperado pelo aumento da quantidade de parâmetros. Os
índices foram j1 e j2 2 { 2, 1, 0, 1, 2}, k1 2{ 0, 1, 2, 3, 4, 5}, k2 2{ 0, 1, 2, 3}. O campo de
velocidades obtido com esta parametrização é mostrado na Fig. 5.17:

5.2.2 Modelagem Direta: Traçamento de Raios

A Fig. 5.18 traz o traçamento de raios para o campo de velocidades do modelo do domo
salino (M2,P1), parametrizado com 216 coeﬁcientes (quantidade mínima que garantiu uma
parametrização satisfatória); este serviu como modelo alvo para o processo de inversão.
Foram utilizados 5.000 raios partindo de cada fonte. Como geometria de aquisição, foi
repetido o arranjo utilizado para a falha distensional, ou seja, 4 fontes distribuídas em 2
poços e 20 receptores ﬁxos na superfície.

Os tempos de trânsito obtidos com o traçamento de raios estão organizados nos perﬁs de
tempos de trânsito sintéticos, nas Figs. 5.19(a) à 5.19(d).

Resultados para Modelos de Campos de Velocidades

55

(a) Fonte S1

(b) Fonte S2

(c) Fonte S3

(d) Fonte S4

Figura 5.13: Perﬁs de tempos de trânsito sintéticos para o modelo da falha disten-
sional obtido por inversão (M1,I). Os tempos nulos são associados a
receptores não iluminados.

5.2.3 Inversão

A ﬁm de proceder a modelagem inversa, foi proposto um modelo inicial, Mo2, formado por
um grande bloco de velocidade uniforme, 2, 2 km/s, com uma intrusão de alta velocidade,
6, 0 km/s, partindo de sua base, porém sem deﬁnições de quaisquer detalhes de outras feições.
Tal modelo poderia ter sido proposto a partir de levantamentos de outros métodos geofísicos
(gravimétrico, por exemplo) ou conhecimento da geologia local; uma representação do modelo

Resultados para Modelos de Campos de Velocidades

56

Figura 5.14: Diferença relativa entre as velocidades do modelo invertido, M1,I e

alvo parametrizado, M1,P1.

(a) Modelo originalmente concebido (Par-
ker, 1988).

(b) Campo de velocidades do modelo original em escala de
cores.

Figura 5.15: Domo salino.

pode ser vista na Fig. 5.20.

Esse modelo foi então parametrizado, adotando os mesmos índices j1, j2, k1 e k2 utilizados
para parametrizar o modelo alvo, a ﬁm de garantir a mesma quantidade de coeﬁcientes;
os índices e coeﬁcientes utilizados para parametrizar este modelo inicial encontram-se no
Apêndice A, Tabs. A.3 e A.4. Respeitando a mesma geometria de aquisição utilizada para
o modelo alvo, procede-se o traçamento de raios, como na Fig. 5.21.

Os tempos de trânsito no modelo inicial, obtidos com este traçamento, encontram-se orga-
nizados nos perﬁs de tempos de trânsito sintéticos, nas Figs. 5.22(a) à 5.22(d).

Os coeﬁcientes dos modelo inicial e os tempos de trânsito do modelo alvo serão insumos para
o algoritmo de Monte Carlo. O produto deste será, por sua vez, utilizado como insumo pelo
algoritmo de Gauss-Newton. A Tab. 5.5 traz o relatório do processamento 2 de cada um dos

2Para um detalhamento da máquina utilizada neste processamento, consultar o Anexo I

Resultados para Modelos de Campos de Velocidades

57

Figura 5.16: Parametrização do modelo do domo salino (M2,P1) com ondaleta bidi-

mensional chapéu mexicano, com 216 coeﬁcientes.

Figura 5.17: Parametrização do modelo do domo salino (M2,P2) com ondaleta bidi-

mensional chapéu mexicano, com 600 coeﬁcientes.

algoritmos:

A Fig. 5.23 traz o modelo invertido do domo salino, M2,I, após a aplicação sequencial
dos algoritmos de Monte Carlo e Gauss-Newton, para o modelo inicial Mo2 (Fig. 5.20)
parametrizado com 216 coeﬁcientes. Mesmo não sendo exatamente o modelo alvo proposto,
guarda bastante semelhança, tanto nas feições, quanto na faixa de velocidades.

Resultados para Modelos de Campos de Velocidades

58

Figura 5.18: Traçamento de raios no modelo do domo salino parametrizado por 216

coeﬁcientes (M2,P1). Foram usados 5.000 raios por fonte.

Tabela 5.5: Comportamento dos algoritmos de inversão - Domo Salino.

Método No Iter. Tempo Proc. Erro Inicial Erro Final

Monte Carlo
Gauss-Newton

35.000

11

⇠ 25 h
⇠ 3, 5 h

20, 95%
19, 22%

19, 22%
18, 63%

Os índices e coeﬁcientes deste modelo invertido estão no Apêndice A, Tabs. A.5 e A.6. O
traçamento de raios foi feito, representado na Fig. 5.24, a ﬁm de calcular os tempos de
trânsito:

Este traçamento originou os tempos de trânsito para o modelo da falha distensional invertido,
M2,I, organizados nos perﬁs de tempos de trânsito sintéticos, nas Figs. 5.25(a) à 5.25(d).

Finalmente, foi feita uma comparação entre as velocidades dos modelos alvo (M2,P1) e inver-
tido (M2,I), obtendo-se o mapa de contorno da diferença relativa, na Fig. 5.26:

5.3 Modelo do Intrusão de Alta Velocidade

O terceiro modelo (M3) tratado neste trabalho foi o da intrusão de alta velocidade, com-
posto por 6 camadas sedimentares e uma intrusão de velocidade mais elevada, levemente
centralizada e amorfa. A representação gráﬁca do campo de velocidades para este modelo,

Resultados para Modelos de Campos de Velocidades

59

(a) Fonte S1

(b) Fonte S2

(c) Fonte S3

(d) Fonte S4

Figura 5.19: Perﬁs de tempos de trânsito sintéticos para o modelo do domo salino
(M2,P1). Os tempos nulos são associados a receptores não iluminados.

suposto com 8, 0 km de extensão horizontal e 4, 0 km de profundidade, é feita na Fig. 5.27:

5.3.1 Parametrizações

A primeira parametrização satisfatória (P1) foi obtida utilizando-se 180 coeﬁcientes, por-
tanto mais parâmetros do que fora utilizado para representar a falha distensional e menos
do que foi utilizado para representar o domo salino. Os índices foram j1 e j2 2{ 0, 1},

Resultados para Modelos de Campos de Velocidades

60

Figura 5.20: Mo2, modelo inicial: bloco de velocidade única, 2, 2 km/s com uma

intrusão de alta velocidade 6, 0 km/s

Figura 5.21: Traçamento de raios no modelo inicial Mo2; novamente, foram utili-
zados 5.000 raios partindo de cada fonte. Modelo parametrizado com
216 coeﬁcientes.

k1 2{ 0, 1, ··· , 8}, k2 2{ 0, 1, 2, 3, 4}. Sendo os coeﬁcientes apresentados no Apêndice B,
Tabs. B.1 e B.2.

O campo de velocidades obtido com esta parametrização encontra-se na Fig. 5.28:

Resultados para Modelos de Campos de Velocidades

61

(a) Fonte S1

(b) Fonte S2

(c) Fonte S3

(d) Fonte S4

Figura 5.22: Perﬁs de tempos de trânsito sintéticos para o modelo inicial (Mo2).

Os tempos nulos são associados a receptores não iluminados.

A segunda parametrização (P2) originou melhores resultados que a primeira, utilizando 405
coeﬁcientes, resultado esperado, tal como aqueles obtidos para os modelos anteriormente
parametrizados, quando se aumenta a quantidade de parâmetros. Os índices foram j1 e
j2 2 { 1, 0, 1}, k1 2{ 0, 1, ··· , 8}, k2 2{ 0, 1, 2, 3, 4}. O campo de velocidades obtido
com esta parametrização é mostrado na Fig. 5.29:

Resultados para Modelos de Campos de Velocidades

62

Figura 5.23: Modelo Invertido, M2,I, obtido através dos algoritmos de Monte Carlo

e Gauss-Newton combinados.

Figura 5.24: Traçado de raios para o modelo do domo salino, M2,I, obtido por

inversão; 5.000 raios por fonte.

5.3.2 Modelagem Direta: Traçamento de Raios

A Fig. 5.30 traz o traçamento de raios para o campo de velocidades do modelo da intrusão
(M3,P1), parametrizado com 180 coeﬁcientes (quantidade mínima que garantiu uma para-
metrização satisfatória); este serviu como modelo alvo para o processo de inversão. Foram

Resultados para Modelos de Campos de Velocidades

63

(a) Fonte S1

(b) Fonte S2

(c) Fonte S3

(d) Fonte S4

Figura 5.25: Perﬁs de tempos de trânsito sintéticos para o modelo do domo sa-
lino obtido por inversão (M2,I). Os tempos nulos são associados a
receptores não iluminados.

utilizados 1.000 raios partindo de cada fonte. Como geometria de aquisição, também foi
repetido o arranjo utilizado para a falha distensional.

Os tempos de trânsito obtidos com o traçamento de raios estão organizados nos perﬁs de
tempos de trânsito sintéticos, nas Figs. 5.31(a) à 5.31(d).

Resultados para Modelos de Campos de Velocidades

64

Figura 5.26: Diferença relativa entre as velocidades do modelo invertido, M2,I e

alvo parametrizado, M2,P1, para o domo salino.

Figura 5.27: Campo de velocidades original do modelo da intrusão de alta veloci-

dade em escala de cores.

5.3.3 Inversão

A ﬁm de proceder a modelagem inversa, foi proposto um modelo inicial, Mo3, formado por
um grande bloco de velocidade uniforme, 2, 6 km/s, com uma intrusão de alta velocidade,
6, 0 km/s, levemente centralizada horizontalmente e mais próxima à superfície, porém sem
deﬁnições de quaisquer detalhes de outras feições. Novamente, poderia ter sido um modelo

Resultados para Modelos de Campos de Velocidades

65

Figura 5.28: Parametrização do modelo da intrusão de alta velocidade (M3,P1) com

ondaleta bidimensional chapéu mexicano, com 180 coeﬁcientes.

Figura 5.29: Parametrização do modelo da intrusão de alta velocidade (M3,P2) com

ondaleta bidimensional chapéu mexicano, com 405 coeﬁcientes.

proposto a partir de levantamentos de outros métodos geofísicos ou conhecimento da geologia
local; uma representação do modelo pode ser vista na Fig. 5.32:

Esse modelo foi então parametrizado, adotando os mesmos índices j1, j2, k1 e k2 utilizados
para parametrizar o modelo alvo, a ﬁm de garantir a mesma quantidade de coeﬁcientes; os

Resultados para Modelos de Campos de Velocidades

66

Figura 5.30: Traçamento de raios no modelo da intrusão de alta velocidade para-
metrizado por 180 coeﬁcientes (M3,P1). Foram usados 1.000 raios por
fonte.

índices e coeﬁcientes utilizados para parametrizar Mo3 encontram-se no Apêndice B, Tabs.
B.3 e B.4. Respeitando a mesma geometria de aquisição utilizada para o modelo alvo,
procede-se o traçamento de raios, como na Fig. 5.33.

Os tempos de trânsito no modelo inicial, obtidos com este traçamento, encontram-se orga-
nizados nos perﬁs de tempos de trânsito sintéticos, nas Figs. 5.34(a) à 5.34(d).

Os coeﬁcientes dos modelo inicial e os tempos de trânsito do modelo alvo serão insumos para
o algoritmo de Monte Carlo. O produto deste será, por sua vez, utilizado como insumo pelo
algoritmo de Gauss-Newton. A Tab. 5.6 traz o relatório do processamento 3 de cada um dos
algoritmos:

Tabela 5.6: Comportamento dos algoritmos de inversão - Intrusão de alta veloci-

dade.

Método No Iter. Tempo Proc. Erro Inicial Erro Final

Monte Carlo
Gauss-Newton

15.932

6

⇠ 15h
57 min

59, 17%
23, 49%

23, 49%
6, 74%

A Fig. 5.35 traz o modelo invertido da intrusão de alta velocidade, M3,I, após a aplicação
sequencial dos algoritmos de Monte Carlo e Gauss-Newton, para o modelo inicial Mo3 (Fig.

3Para um detalhamento da máquina utilizada neste processamento, consultar o Anexo I

Resultados para Modelos de Campos de Velocidades

67

(a) Fonte S1

(b) Fonte S2

(c) Fonte S3

(d) Fonte S4

Figura 5.31: Perﬁs de tempos de trânsito sintéticos para o modelo da intrusão de
alta velocidade (M3,P1). Os tempos nulos são associados a receptores
não iluminados.

5.32) parametrizado com 180 coeﬁcientes. Mesmo não sendo exatamente o modelo alvo
proposto, guarda bastante semelhança, tanto nas feições, quanto nas velocidades.

Os índices e coeﬁcientes deste modelo invertido estão no Apêndice B, Tabs. B.5 e B.6. O
traçamento de raios foi feito, representado na Fig. 5.36, a ﬁm de calcular os tempos de
trânsito:

Este traçamento originou os tempos de trânsito para o modelo da falha distensional invertido,

Resultados para Modelos de Campos de Velocidades

68

Figura 5.32: Mo3, modelo inicial: bloco de velocidade única, 2, 6 km/s com uma

intrusão de alta velocidade 6, 0 km/s.

Figura 5.33: Traçamento de raios no modelo inicial Mo3; novamente, foram utili-
zados 1.000 raios partindo de cada fonte. Modelo parametrizado com
180 coeﬁcientes.

M3,I, organizados nos perﬁs de tempos de trânsito sintéticos, nas Figs. 5.37(a) à 5.37(d).

Finalmente, foi feita uma comparação entre as velocidades dos modelos alvo (M3,P1) e in-
vertido (M3,I), obtendo-se o mapa de contorno da diferença relativa, apresentado na Fig.
5.38

Resultados para Modelos de Campos de Velocidades

69

(a) Fonte S1

(b) Fonte S2

(c) Fonte S3

(d) Fonte S4

Figura 5.34: Perﬁs de tempos de trânsito sintéticos para o modelo inicial (Mo3).

Os tempos nulos são associados a receptores não iluminados.

Resultados para Modelos de Campos de Velocidades

70

Figura 5.35: Modelo Invertido, M3,I, obtido através dos algoritmos de Monte Carlo

e Gauss-Newton combinados.

Figura 5.36: Traçado de raios para o modelo da intrusão de alta velocidade, M3,I,

obtido por inversão; 1.000 raios por fonte.

Resultados para Modelos de Campos de Velocidades

71

(a) Fonte S1

(b) Fonte S2

(c) Fonte S3

(d) Fonte S4

Figura 5.37: Perﬁs de tempos de trânsito sintéticos para o modelo da intrusão
de alta velocidade obtido por inversão (M3,I). Os tempos nulos são
associados a receptores não iluminados.

Resultados para Modelos de Campos de Velocidades

72

Figura 5.38: Diferença relativa entre as velocidades do modelo invertido, M3,I e

alvo parametrizado, M3,P1, para a intrusão de alta velocidade.

6

Conclusões

A técnica de parametrização baseada em séries ondaletas, mostrou-se extremamente eﬁcaz,
tanto no seu propósito de parametrizar funções uni e bidimensionais, como campos de velo-
cidades sísmicas. No tocante à parametrização dos modelos de velocidades, ﬁcou claro, ao
longo do trabalho, que o uso de uma maior quantidade de coeﬁcientes (parâmetros) acarreta
uma melhoria na representação dos mesmos; não obstante, uma pequena quantidade de coeﬁ-
cientes garante razoável acurácia e reduz sobremaneira o custo dos processos computacionais
iterativos.

A modelagem direta dos campos de velocidade foi também bastante satisfatória. Por um
lado, a técnica do traçamento de raios tem aplicação bastante facilitada quando uma função
matemática contínua descreve este campo, caso das parametrizações empregadas, já que
ondaleta chapéu mexicano é contínua; por outro, o baixo tempo no processamento destes
traçamentos acarreta uma economia muito bem vinda nos tempos de processamento dos
algoritmos de inversão. Se há de notar que as ﬁguras representativas de tais traçamentos
exibem a eﬁcácia da técnica, já que o comportamento dos raios está de acordo com o esperado,
teoricamente, para a propagação das ondas elásticas em subsuperfície.

Os modelos invertidos, ainda que não idênticos aos respectivos modelos alvos, tem a capaci-
dade de destacar as principais feições, servindo bem ao propósito geofísico. As velocidades
obtidas para os modelos invertidos estão muito próximas daquelas dos correspondentes mo-
delos alvos, o que pode ser veriﬁcado nos mapas de contorno das diferenças relativas.

Provavelmente, às custas do aumento nos tempos de processamento, os resultados das in-
versões seriam tanto mais acurados quanto maiores fossem as quantidades de coeﬁcientes
utilizados nas parametrizações. Além disso, se os algoritmos de traçamento dos raios e in-

73

Conclusões

74

versão considerassem raios mais profundos (não só as primeiras chegadas), possivelmente
os resultados seriam mais expressivos. Tais considerações serão investigadas em trabalhos
futuros.

O coroamento da técnica seria a aplicação num dado tomográﬁco real; apesar de isto não ter
sido feito, o caminho está pronto para tal e, num trabalho mais aprofundado, tanto a técnica
desenvolvida como seus resultados serviriam de base para algoritmos com esta ﬁnalidade.

O processamento de várias etapas do trabalho em paralelo permitiu um dinamismo na obten-
ção dos resultados, uma vez que as tarefas são demasiadamente repetidas a ﬁm de eliminar
possíveis erros.

Agradecimentos

Agradeço ao CPGG-UFBA pelos recursos computacionais para realização de parte desta pesquisa
e da base deste texto em LATEX, bem como pelo provimento da estrutura de estudo e pelas aulas da
pós-graduação.

Agradeço à ANP que, através do convênio PRH-08 mantido com UFBA, proveu minha bolsa
de mestrado, sem a qual seria inviável a realização deste trabalho. Cabe também agradecimento à
Fapex-UFBA que, quando do rompimento do referido convênio, custeou os meses ﬁnais da bolsa.

Agradeço à Rede Temática de Estudos em Geofísica Aplicada do CENPES-PETROBRAS.
Agradeço ao Professor Cícero Paixão, pelo exemplo e pelas sempre incentivadoras conversas,

tanto na universidade, quanto na viagem do RAA.

Agradeço ao professor Hedison Kiuity Sato, que fora meu orientador quando da primeira ten-
tativa de mestrado. Sou grato pelo material que serve de base para este trabalho, pelas dicas de
LATEX, linux, Fortran e shell script. Também preciso agradecê-lo pelo esforço em manter a minha
bolsa, mesmo com o ﬁm do convênio PRH.

Agradeço ao professor Wilson Mouzer Figueiró, mestre de iluminação ímpar. Sou grato pelo
tema proposto, pelo desaﬁo que me foi dado, pela esperança do sucesso. Sou grato pelo respeito e
amizade com que sempre me tratou e pelas soluções inventivas (muitas vezes de difícil implementa-
ção, é verdade) que me oferecia quando o trabalho parecia um beco sem saída. Também agradeço
à sua revisão minuciosa do texto desta disseração.

Agradeço aos professores Eduardo Telmo Fonseca Santos e Juarez dos Santos Azevedo, pelas
perguntas altamente pertinentes feitas no dia da minha defesa, bem como à atenciosa leitura e
revisão que ﬁzeram do meu trabalho

Sou grato à minha família pelo suporte, em especial aos meus tios Antônio Fernando e Patrícia
Nascimento que me presentearam custeando boa parte da compra do meu notebook, máquina que
processou robusta e exaustivamente os programas que desenvolvi para esta pesquisa. Meu irmão,
Arthur Mello, também merece meus agradecimentos especiais, pela ajuda com o computador e pela
referência e suporte.

Agradeço por ﬁm a todos os meus amigos da Geofísica, desde os estudantes de graduação aos
de doutorado. Obviamente ﬁcaria longo citar todos os nomes, mas todos eles contribuíram de al-
guma forma com a minha Pesquisa; vale menção especial à Vitor Hugo Serravalle Reis Rodrigues
(“radesh”), pelas preciosas aulas de geofísica e Alexsandro Guerra Cerqueira. O agradecimento à
Alex se estenderia por muito mais de uma página, o que posso dizer para resumir é que, sem ele,
deﬁnitivamente este trabalho não aconteceria.

75

Referências Bibliográﬁcas

ˆCervenˆy, V. (2001) Seismic Ray Theory, Cambridge University Press, Cambrige UK.

Dos Santos, V. G. B. (2009) Inversão Sísmica Tomográﬁca usando Norma de Integral de Função,

Tese de Doutorado, Geofísica, UFBA.

Dos Santos, V. G. B. e Figueiró, W. M. (2011) Seismic ray tomography using l1 integral norm,

Revista Brasileira de Geofısica, 29(2):347–358.

Martinez, A. C. e Figueiró, W. M. (2011) Parametrização ondaleta do campo de velocidades sísmicas
relativo a um domo salino, In: 12th International Congress of the Brazilian Geophysical Society.

Misiti, M.; Misiti, Y.; Oppenheim, G. e Poggi, J.-M. (2013) Wavelets and their Applications, John

Wiley & Sons.

Morettin, P. A. (1999) Ondas e Ondaletas: da Análise de Fourier à Análise de Ondaletas, Edusp.

Parker, S. P. (1988) McGraw-Hill Encyclopedia of the Geological Sciences, McGraw-Hill New York

etc.

Perin, H. M. e Figueiró, W. M. (2011) Parametrização de campo bidimensional de velocidades
sísmicas usando ondaletas, In: 12th International Congress of the Brazilian Geophysical Society.

Ponti, M. (2011) Multirresolution and the wavelet transform, http://wiki.icmc.usp.br/images/3/

30/Dip13_multiresolution-wavelets.pdf, Acesso em: 28 Julho 2015.

Rodrigues, V. H. S. R. (2015) Aplicação da Tomograﬁa de Tempos de Trânsinto a Dados do Campo

de Miranga, Bacia do Recôncavo, Dissert. de Mestrado, Geofísica, UFBA.

Sen, M. K. e Stoﬀa, P. L. (2013) Global Optimization Methods in Geophysical Inversion, Cambridge

University Press.

Traina, A. J.; Castañón, C. A. e Traina Jr, C. (2003) Multiwavemed: a system for medical image
retrieval through wavelets transformations, In: Computer-Based Medical Systems, 2003. Procee-
dings. 16th IEEE Symposium, pp. 150–155, IEEE.

76

ApêndiceA

Tabelas de Coeﬁcientes da
Parametrização do Modelo Domo Salino

77

Tabelas de Coeﬁcientes da Parametrização do Modelo Domo Salino

78

.
e
t
r
a
p

a
1

,
1
P
,
2

M

,
o
n

i
l
a
s

o
m
o
d

o
d

o
l
e
d
o
m
o
d

o
ã
ç
a
z
i
r
t
e
m
a
r
a
p

a
n

s
o
d
a
z
i
l
i
t
u

s
e
t
n
e
i
c
ﬁ
e
o
C

:
1
.
A
a
l
e
b
a
T

r
o
l
a
v

)
2
k
,
1
k
,
2
j
,
1
j
(
d

r
o
l
a
v

)
2
k
,
1
k
,
2
j
,
1
j
(
d

r
o
l
a
v

)
2
k
,
1
k
,
2
j
,
1
j
(
d

r
o
l
a
v

)
2
k
,
1
k
,
2
j
,
1
j
(
d

o
v
l
A
o
l
e
d
o
M

1
.
A

4
0
+
E
0
6
4
6
6
1
3
8
7
3
.
1

4
0
+
E
8
4
9
6
8
1
9
3
8
2
.
1
 

4
0
+
E
7
6
2
8
4
3
6
9
0
2
.
1

4
0
+
E
7
7
6
5
2
4
4
9
6
3
.
1
 

3
0
+
E
6
8
1
9
1
2
1
5
7
6
.
2
 

4
0
+
E
5
5
8
8
3
0
4
3
3
5
.
1

4
0
+
E
3
3
6
9
0
6
5
8
2
0
.
1

3
0
+
E
3
6
2
2
8
3
0
0
5
7
.
7
 

3
0
+
E
6
7
8
1
0
4
9
4
7
8
.
2
 

3
0
+
E
4
4
9
0
0
5
4
5
4
3
.
6

3
0
+
E
8
0
2
4
7
1
6
7
6
6
.
4

3
0
+
E
8
7
2
2
8
0
6
8
0
5
.
1

2
0
+
E
6
5
9
3
9
8
7
7
2
5
.
2
 

3
0
+
E
9
8
1
9
0
8
4
3
4
9
.
2

3
0
+
E
2
0
2
6
5
4
5
8
8
4
.
1

4
0
+
E
8
6
4
5
0
9
8
6
1
5
.
5

5
0
+
E
9
7
7
7
8
4
6
8
2
0
.
1
 

5
0
+
E
0
1
6
5
9
3
9
5
9
1
.
1
 

5
0
+
E
6
3
2
5
5
3
6
3
1
2
.
1
 

2
0
+
E
0
4
9
7
4
2
0
1
3
5
.
8
 

5
0
+
E
8
5
2
7
5
3
0
3
7
9
.
1
 

5
0
+
E
0
0
7
1
9
9
5
9
9
9
.
1
 

5
0
+
E
6
8
3
6
1
4
6
1
4
9
.
1
 

5
0
+
E
7
9
6
4
1
0
0
0
3
2
.
1

5
0
+
E
3
2
6
5
8
9
5
2
0
8
.
1
 

5
0
+
E
2
9
7
4
4
4
1
8
4
1
.
2
 

5
0
+
E
2
8
9
4
5
1
0
9
1
4
.
2
 

)
1
,
2
,
1
 

)
2
,
2
,
1
 

)
3
,
2
,
1
 

)
0
,
3
,
1
 

)
1
,
3
,
1
 

)
2
,
3
,
1
 

)
3
,
3
,
1
 

)
0
,
4
,
1
 

)
1
,
4
,
1
 

)
2
,
4
,
1
 

)
3
,
4
,
1
 

)
0
,
5
,
1
 

)
1
,
5
,
1
 

)
2
,
5
,
1
 

)
3
,
5
,
1
 

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

)
0
,
0
,
0
,
0
(
d

)
1
,
0
,
0
,
0
(
d

)
2
,
0
,
0
,
0
(
d

)
3
,
0
,
0
,
0
(
d

)
0
,
1
,
0
,
0
(
d

)
1
,
1
,
0
,
0
(
d

)
2
,
1
,
0
,
0
(
d

)
3
,
1
,
0
,
0
(
d

)
0
,
2
,
0
,
0
(
d

)
1
,
2
,
0
,
0
(
d

)
2
,
2
,
0
,
0
(
d

)
3
,
2
,
0
,
0
(
d

4
0
+
E
8
5
9
3
2
9
9
5
2
2
.
2

4
0
+
E
6
9
8
9
9
2
7
3
2
2
.
5
 

4
0
+
E
1
9
5
5
9
1
8
8
1
4
.
4

4
0
+
E
0
0
6
9
3
1
6
7
3
9
.
9
 

4
0
+
E
8
4
2
9
0
1
8
2
5
0
.
6
 

3
0
+
E
5
1
6
2
8
3
0
6
9
8
.
3
 

4
0
+
E
7
5
4
6
2
3
8
3
0
8
.
9
 

5
0
+
E
9
5
8
1
3
5
1
0
9
5
.
1

4
0
+
E
3
7
0
5
5
6
9
6
7
4
.
9

5
0
+
E
6
1
9
1
6
9
5
9
4
0
.
1
 

4
0
+
E
0
5
2
9
6
7
1
9
6
9
.
2

4
0
+
E
9
5
2
7
0
5
8
4
7
3
.
4
 

3
0
+
E
4
3
1
4
5
2
8
9
7
1
.
5

4
0
+
E
2
8
3
1
8
1
5
4
5
0
.
3
 

4
0
+
E
2
9
8
4
7
2
5
9
1
9
.
1

4
0
+
E
3
7
6
7
4
6
7
4
3
3
.
1
 

3
0
+
E
1
9
7
9
1
9
4
1
8
6
.
8

4
0
+
E
8
3
4
5
5
7
6
3
0
4
.
1
 

4
0
+
E
5
0
9
3
1
5
7
0
3
5
.
1
 

3
0
+
E
0
3
8
7
5
7
1
6
1
1
.
8
 

3
0
+
E
3
1
0
5
3
7
5
9
7
9
.
4

3
0
+
E
1
1
9
6
6
3
7
7
6
1
.
6

3
0
+
E
4
0
2
4
8
2
3
4
4
0
.
2

4
0
+
E
8
2
7
7
5
1
0
7
9
3
.
1

4
0
+
E
8
0
6
1
3
1
5
3
3
5
.
2

4
0
+
E
5
4
6
0
8
8
4
8
5
2
.
1

4
0
+
E
4
7
6
0
7
3
1
4
8
5
.
2
 

)
2
,
1
,
1
,
1
 
(
d

)
3
,
1
,
1
,
1
 
(
d

)
0
,
2
,
1
,
1
 
(
d

)
1
,
2
,
1
,
1
 
(
d

)
2
,
2
,
1
,
1
 
(
d

)
3
,
2
,
1
,
1
 
(
d

)
0
,
3
,
1
,
1
 
(
d

)
1
,
3
,
1
,
1
 
(
d

)
2
,
3
,
1
,
1
 
(
d

)
3
,
3
,
1
,
1
 
(
d

)
0
,
4
,
1
,
1
 
(
d

)
1
,
4
,
1
,
1
 
(
d

)
2
,
4
,
1
,
1
 
(
d

)
3
,
4
,
1
,
1
 
(
d

)
0
,
5
,
1
,
1
 
(
d

)
1
,
5
,
1
,
1
 
(
d

)
2
,
5
,
1
,
1
 
(
d

)
3
,
5
,
1
,
1
 
(
d

)
0
,
0
,
1
 

)
1
,
0
,
1
 

)
2
,
0
,
1
 

)
3
,
0
,
1
 

)
0
,
1
,
1
 

)
1
,
1
,
1
 

)
2
,
1
,
1
 

)
3
,
1
,
1
 

)
0
,
2
,
1
 

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

3
0
+
E
8
9
5
1
4
1
4
2
3
9
.
3

4
0
+
E
8
9
6
7
9
2
1
8
9
8
.
4

3
0
+
E
0
6
1
4
7
1
3
3
4
3
.
8
 

4
0
+
E
6
5
2
5
9
7
8
6
2
2
.
3
 

4
0
+
E
9
3
4
3
6
4
3
3
5
0
.
2
 

4
0
+
E
4
1
3
2
6
6
5
8
7
1
.
8

3
0
+
E
5
7
2
1
9
9
1
3
6
4
.
8

4
0
+
E
1
9
8
2
6
5
2
9
8
1
.
2
 

4
0
+
E
5
7
1
7
3
9
9
6
1
1
.
2
 

4
0
+
E
0
6
5
0
1
3
0
2
6
4
.
2

4
0
+
E
5
3
2
7
3
2
6
9
8
5
.
8
 

5
0
+
E
0
9
7
2
2
9
4
4
7
1
.
1
 

4
0
+
E
1
2
0
9
0
6
5
6
3
0
.
7
 

4
0
+
E
7
2
2
3
0
2
4
9
3
0
.
3

3
0
+
E
6
7
6
9
1
1
4
3
1
0
.
6
 

4
0
+
E
0
6
5
8
9
9
0
6
8
8
.
1
 

4
0
+
E
7
0
1
4
6
7
6
1
1
5
.
1
 

3
0
+
E
3
1
6
5
5
6
9
0
8
2
.
3

4
0
+
E
2
9
2
6
2
6
1
7
0
1
.
1
 

4
0
+
E
3
3
6
8
7
2
4
5
1
5
.
1
 

3
0
+
E
7
3
8
6
9
3
0
8
7
5
.
9
 

4
0
+
E
3
2
9
4
7
2
2
1
9
8
.
1
 

3
0
+
E
2
7
9
6
9
0
1
1
4
2
.
6

3
0
+
E
6
1
8
8
9
3
8
8
9
8
.
8

3
0
+
E
9
4
2
8
5
1
1
0
0
8
.
8
 

4
0
+
E
9
3
2
0
0
2
0
3
1
4
.
5

4
0
+
E
1
4
7
3
7
5
6
0
6
0
.
7
 

)
3
,
0
,
0
,
1
 
(
d

)
0
,
1
,
0
,
1
 
(
d

)
1
,
1
,
0
,
1
 
(
d

)
2
,
1
,
0
,
1
 
(
d

)
3
,
1
,
0
,
1
 
(
d

)
0
,
2
,
0
,
1
 
(
d

)
1
,
2
,
0
,
1
 
(
d

)
2
,
2
,
0
,
1
 
(
d

)
3
,
2
,
0
,
1
 
(
d

)
0
,
3
,
0
,
1
 
(
d

)
1
,
3
,
0
,
1
 
(
d

)
2
,
3
,
0
,
1
 
(
d

)
3
,
3
,
0
,
1
 
(
d

)
0
,
4
,
0
,
1
 
(
d

)
1
,
4
,
0
,
1
 
(
d

)
2
,
4
,
0
,
1
 
(
d

)
3
,
4
,
0
,
1
 
(
d

)
0
,
5
,
0
,
1
 
(
d

)
1
,
5
,
0
,
1
 
(
d

)
2
,
5
,
0
,
1
 
(
d

)
3
,
5
,
0
,
1
 
(
d

)
0
,
0
,
1
,
1
 
(
d

)
1
,
0
,
1
,
1
 
(
d

)
2
,
0
,
1
,
1
 
(
d

)
3
,
0
,
1
,
1
 
(
d

)
0
,
1
,
1
,
1
 
(
d

)
1
,
1
,
1
,
1
 
(
d

3
0
+
E
5
3
9
3
6
4
4
8
5
8
.
6
 

3
0
+
E
3
5
5
8
8
2
7
7
5
1
.
8
 

3
0
+
E
5
0
4
9
4
6
9
3
9
7
.
5
 

3
0
+
E
1
2
4
5
5
2
8
3
4
7
.
1
 

4
0
+
E
8
8
3
8
0
7
1
0
9
7
.
1
 

4
0
+
E
0
5
6
2
0
4
6
8
5
9
.
1
 

4
0
+
E
6
6
6
9
6
9
0
8
5
2
.
1
 

3
0
+
E
6
9
0
1
3
7
5
2
0
0
.
3
 

4
0
+
E
9
4
9
8
6
9
4
5
0
5
.
2
 

4
0
+
E
1
7
6
4
2
4
3
0
7
6
.
2
 

4
0
+
E
5
7
0
8
6
6
1
9
3
6
.
1
 

3
0
+
E
7
5
1
1
8
7
1
5
3
4
.
3
 

4
0
+
E
3
0
5
3
1
6
7
6
7
9
.
1
 

4
0
+
E
1
0
4
8
9
3
6
4
2
0
.
2
 

4
0
+
E
4
8
1
2
2
9
0
8
9
1
.
1
 

3
0
+
E
4
3
8
8
4
4
8
9
9
1
.
2
 

4
0
+
E
5
7
7
3
0
1
4
3
2
0
.
1
 

4
0
+
E
9
1
3
2
5
7
2
2
6
0
.
1
 

3
0
+
E
5
0
9
3
7
6
1
0
7
2
.
6
 

3
0
+
E
5
4
3
3
1
2
3
4
5
1
.
1
 

3
0
+
E
8
2
7
5
0
1
0
3
5
4
.
2
 

3
0
+
E
9
3
9
2
4
9
6
0
6
4
.
2
 

3
0
+
E
8
5
3
8
7
4
6
0
0
4
.
1
 

2
0
+
E
3
3
3
0
6
2
6
6
5
2
.
2
 

4
0
+
E
2
0
0
4
8
4
0
3
1
2
.
2

4
0
+
E
1
7
2
3
7
5
7
1
4
1
.
1

3
0
+
E
7
3
6
8
6
6
4
9
9
1
.
3

)
0
,
0
,
1
 

)
1
,
0
,
1
 

)
2
,
0
,
1
 

)
3
,
0
,
1
 

)
0
,
1
,
1
 

)
1
,
1
,
1
 

)
2
,
1
,
1
 

)
3
,
1
,
1
 

)
0
,
2
,
1
 

)
1
,
2
,
1
 

)
2
,
2
,
1
 

)
3
,
2
,
1
 

)
0
,
3
,
1
 

)
1
,
3
,
1
 

)
2
,
3
,
1
 

)
3
,
3
,
1
 

)
0
,
4
,
1
 

)
1
,
4
,
1
 

)
2
,
4
,
1
 

)
3
,
4
,
1
 

)
0
,
5
,
1
 

)
1
,
5
,
1
 

)
2
,
5
,
1
 

)
3
,
5
,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

)
0
,
0
,
0
,
1
 

)
1
,
0
,
0
,
1
 

)
2
,
0
,
0
,
1
 

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

Tabelas de Coeﬁcientes da Parametrização do Modelo Domo Salino

79

.
e
t
r
a
p

a
2

,
1
P
,
2

M

,
o
n

i
l
a
s

o
m
o
d

o
d

o
l
e
d
o
m
o
d

o
ã
ç
a
z
i
r
t
e
m
a
r
a
p

a
n

s
o
d
a
z
i
l
i
t
u

s
e
t
n
e
i
c
ﬁ
e
o
C

:
2
.
A
a
l
e
b
a
T

r
o
l
a
v

)
2
k
,
1
k
,
2
j
,
1
j
(
d

r
o
l
a
v

)
2
k
,
1
k
,
2
j
,
1
j
(
d

r
o
l
a
v

)
2
k
,
1
k
,
2
j
,
1
j
(
d

r
o
l
a
v

)
2
k
,
1
k
,
2
j
,
1
j
(
d

3
0
+
E
6
1
2
5
2
3
9
0
9
0
.
1

2
0
+
E
7
7
0
0
9
7
4
8
7
8
.
7

3
0
+
E
5
5
6
0
3
5
5
2
9
2
.
1

4
0
+
E
7
3
1
0
7
1
1
9
7
2
.
7

4
0
+
E
0
5
2
9
0
2
8
1
0
4
.
5
 

4
0
+
E
5
3
9
9
8
8
6
4
2
1
.
6
 

3
0
+
E
2
7
6
4
6
4
1
6
3
2
.
1
 

5
0
+
E
6
5
6
1
2
7
6
0
2
9
.
1

5
0
+
E
3
6
5
1
8
4
7
1
5
1
.
1

4
0
+
E
6
7
1
0
6
8
2
8
6
9
.
6
 

5
0
+
E
5
8
8
9
1
8
1
6
2
7
.
1

5
0
+
E
0
6
6
5
9
7
5
3
4
2
.
2

4
0
+
E
5
1
5
5
5
4
3
8
1
1
.
6
 

5
0
+
E
7
4
3
9
9
7
4
4
2
5
.
1

5
0
+
E
9
3
4
0
0
3
5
5
9
0
.
1
 

5
0
+
E
8
7
0
0
1
8
8
3
0
6
.
1

3
0
+
E
8
8
0
9
9
9
0
1
9
8
.
5
 

5
0
+
E
2
8
2
8
4
7
4
5
4
4
.
1

4
0
+
E
1
4
9
9
4
3
2
0
1
8
.
6
 

4
0
+
E
5
5
6
7
6
7
6
1
8
1
.
7

4
0
+
E
5
4
4
3
1
1
6
1
0
1
.
1
 

4
0
+
E
9
8
4
7
3
6
5
5
4
8
.
5

4
0
+
E
0
1
5
1
8
2
8
4
0
2
.
3
 

3
0
+
E
8
5
8
1
0
1
5
6
5
3
.
1

3
0
+
E
9
1
5
7
5
0
4
9
7
7
.
4
 

2
0
+
E
3
2
0
9
3
7
8
4
3
2
.
6
 

3
0
+
E
8
5
8
9
7
8
8
7
7
4
.
7
 

)
1
,
5
,
0
,
1
(
d

)
2
,
5
,
0
,
1
(
d

)
3
,
5
,
0
,
1
(
d

)
0
,
0
,
1
,
1
(
d

)
1
,
0
,
1
,
1
(
d

)
2
,
0
,
1
,
1
(
d

)
3
,
0
,
1
,
1
(
d

)
0
,
1
,
1
,
1
(
d

)
1
,
1
,
1
,
1
(
d

)
2
,
1
,
1
,
1
(
d

)
3
,
1
,
1
,
1
(
d

)
0
,
2
,
1
,
1
(
d

)
1
,
2
,
1
,
1
(
d

)
2
,
2
,
1
,
1
(
d

)
3
,
2
,
1
,
1
(
d

)
0
,
3
,
1
,
1
(
d

)
1
,
3
,
1
,
1
(
d

)
2
,
3
,
1
,
1
(
d

)
3
,
3
,
1
,
1
(
d

)
0
,
4
,
1
,
1
(
d

)
1
,
4
,
1
,
1
(
d

)
2
,
4
,
1
,
1
(
d

)
3
,
4
,
1
,
1
(
d

)
0
,
5
,
1
,
1
(
d

)
1
,
5
,
1
,
1
(
d

)
2
,
5
,
1
,
1
(
d

)
3
,
5
,
1
,
1
(
d

2
0
+
E
7
5
2
0
4
3
2
0
6
7
.
4

2
0
+
E
7
8
5
2
1
2
9
0
3
6
.
1

2
0
+
E
3
7
7
6
0
3
1
2
5
0
.
6

2
0
+
E
7
3
5
5
9
5
7
3
1
2
.
4

1
0
+
E
2
0
5
2
5
8
1
6
0
4
.
2
 

2
0
+
E
7
0
7
4
8
8
7
6
1
5
.
1
 

3
0
+
E
1
1
9
0
4
5
5
0
3
9
.
2
 

4
0
+
E
5
5
3
9
2
6
6
4
0
2
.
6
 

4
0
+
E
9
9
4
8
0
6
3
7
3
4
.
7
 

4
0
+
E
1
6
4
3
3
3
2
3
9
4
.
5
 

4
0
+
E
5
8
6
6
4
4
2
1
9
8
.
9
 

4
0
+
E
9
2
5
9
8
8
8
4
8
8
.
7

4
0
+
E
3
9
2
6
4
9
9
1
5
6
.
9

5
0
+
E
4
6
3
4
7
7
8
7
8
3
.
1

4
0
+
E
1
4
1
7
0
5
6
4
1
9
.
4
 

5
0
+
E
7
0
3
5
3
5
3
2
6
6
.
1
 

5
0
+
E
4
1
6
2
9
6
9
2
1
8
.
1
 

5
0
+
E
2
0
8
4
7
2
1
2
0
1
.
1
 

4
0
+
E
5
5
9
4
3
9
5
2
3
9
.
6
 

5
0
+
E
7
2
4
1
5
8
5
4
0
2
.
1
 

5
0
+
E
3
3
5
6
3
1
3
2
9
2
.
1
 

4
0
+
E
3
1
3
9
5
5
2
7
9
9
.
5
 

4
0
+
E
1
7
1
1
1
8
1
5
4
2
.
2
 

4
0
+
E
3
1
8
7
9
9
3
3
5
2
.
5
 

4
0
+
E
1
9
2
7
6
8
3
8
9
6
.
5
 

4
0
+
E
7
2
9
3
6
7
7
1
3
0
.
3
 

3
0
+
E
9
7
4
2
4
7
2
0
6
4
.
2
 

)
2
,
4
,
1
 

)
3
,
4
,
1
 

)
0
,
5
,
1
 

)
1
,
5
,
1
 

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

)
2
,
5
,
1
 

)
3
,
5
,
1
 

)
0
,
0
,
0
,
1
(
d

4
0
+
E
7
5
9
3
7
2
6
8
8
2
.
3

4
0
+
E
5
0
5
3
0
3
5
7
8
4
.
7

5
0
+
E
0
7
5
6
1
0
7
5
4
1
.
1
 

4
0
+
E
7
5
9
1
0
0
4
2
3
8
.
8
 

4
0
+
E
7
6
1
4
8
6
3
9
8
9
.
7
 

4
0
+
E
9
2
4
8
0
1
0
0
2
1
.
4
 

5
0
+
E
5
3
0
9
4
3
8
5
0
5
.
1

)
1
,
0
,
0
,
1
(
d

)
2
,
0
,
0
,
1
(
d

)
3
,
0
,
0
,
1
(
d

)
0
,
1
,
0
,
1
(
d

)
1
,
1
,
0
,
1
(
d

)
2
,
1
,
0
,
1
(
d

)
3
,
1
,
0
,
1
(
d

)
0
,
2
,
0
,
1
(
d

)
1
,
2
,
0
,
1
(
d

)
2
,
2
,
0
,
1
(
d

)
3
,
2
,
0
,
1
(
d

)
0
,
3
,
0
,
1
(
d

)
1
,
3
,
0
,
1
(
d

)
2
,
3
,
0
,
1
(
d

)
3
,
3
,
0
,
1
(
d

)
0
,
4
,
0
,
1
(
d

)
1
,
4
,
0
,
1
(
d

)
2
,
4
,
0
,
1
(
d

)
3
,
4
,
0
,
1
(
d

)
0
,
5
,
0
,
1
(
d

4
0
+
E
0
8
3
3
2
0
9
4
7
9
.
8

4
0
+
E
9
0
7
8
1
8
7
2
4
0
.
8
 

3
0
+
E
9
2
7
1
4
7
5
9
9
6
.
2
 

3
0
+
E
5
7
0
3
8
6
2
3
4
2
.
2
 

3
0
+
E
0
5
7
2
7
2
6
7
8
0
.
1

2
0
+
E
1
1
3
0
1
3
5
8
3
9
.
4

4
0
+
E
5
4
2
2
0
0
1
4
7
5
.
1

3
0
+
E
1
4
7
0
0
7
8
9
0
2
.
7

4
0
+
E
4
7
3
5
0
9
7
3
4
0
.
1
 

3
0
+
E
7
2
4
4
9
5
7
6
7
2
.
8
 

3
0
+
E
2
0
4
0
9
3
3
2
3
6
.
2
 

2
0
+
E
6
9
9
1
7
7
7
9
1
4
.
3
 

3
0
+
E
4
7
0
5
8
1
1
0
1
1
.
3

3
0
+
E
1
4
9
4
3
2
8
0
8
8
.
1

3
0
+
E
7
2
0
0
3
8
1
8
1
9
.
2

3
0
+
E
7
6
6
1
3
5
9
1
8
8
.
2

2
0
+
E
6
5
5
1
3
5
5
0
1
6
.
7

1
0
+
E
1
6
7
1
1
9
3
7
9
4
.
2

2
0
+
E
6
5
1
8
9
5
8
7
4
8
.
2
 

2
0
+
E
5
6
2
0
8
1
4
4
1
1
.
3

)
3
,
3
,
1
,
0
(
d

)
0
,
4
,
1
,
0
(
d

)
1
,
4
,
1
,
0
(
d

)
2
,
4
,
1
,
0
(
d

)
3
,
4
,
1
,
0
(
d

)
0
,
5
,
1
,
0
(
d

)
1
,
5
,
1
,
0
(
d

)
2
,
5
,
1
,
0
(
d

)
3
,
5
,
1
,
0
(
d

)
0
,
0
,
1
 

)
1
,
0
,
1
 

)
2
,
0
,
1
 

)
3
,
0
,
1
 

)
0
,
1
,
1
 

)
1
,
1
,
1
 

)
2
,
1
,
1
 

)
3
,
1
,
1
 

)
0
,
2
,
1
 

)
1
,
2
,
1
 

)
2
,
2
,
1
 

)
3
,
2
,
1
 

)
0
,
3
,
1
 

)
1
,
3
,
1
 

)
2
,
3
,
1
 

)
3
,
3
,
1
 

)
0
,
4
,
1
 

)
1
,
4
,
1
 

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

3
0
+
E
8
7
3
9
3
6
9
3
4
3
.
1

5
0
+
E
0
6
6
5
1
8
2
6
6
0
.
3
 

5
0
+
E
3
1
5
1
1
9
5
8
1
4
.
3
 

5
0
+
E
4
3
0
8
1
2
0
4
6
7
.
2
 

4
0
+
E
2
9
3
8
7
2
9
9
9
6
.
3

4
0
+
E
7
0
7
2
6
3
9
7
7
6
.
7
 

4
0
+
E
9
1
4
0
7
4
7
3
2
0
.
9
 

4
0
+
E
3
6
5
6
2
2
8
1
6
6
.
9
 

4
0
+
E
2
9
5
7
8
7
3
8
5
1
.
4
 

5
0
+
E
9
9
4
5
5
2
6
2
9
1
.
1
 

5
0
+
E
9
3
5
1
4
0
5
7
9
2
.
1
 

4
0
+
E
3
4
6
2
8
3
7
9
4
8
.
7
 

5
0
+
E
3
4
1
1
1
1
6
9
3
4
.
1
 

5
0
+
E
0
0
9
6
6
2
7
1
9
2
.
1

5
0
+
E
9
6
4
5
9
4
9
8
8
0
.
1
 

4
0
+
E
0
3
1
5
6
5
8
7
9
3
.
3
 

5
0
+
E
5
4
5
4
8
2
4
5
0
5
.
1
 

5
0
+
E
5
2
1
6
2
1
2
4
5
8
.
1

5
0
+
E
7
3
4
8
4
4
6
1
9
3
.
1
 

4
0
+
E
8
7
7
2
6
9
8
8
5
2
.
6
 

5
0
+
E
2
9
0
5
3
2
5
4
3
0
.
3
 

5
0
+
E
4
5
6
6
3
0
9
3
4
9
.
1

5
0
+
E
0
2
5
1
9
0
3
0
6
1
.
2
 

5
0
+
E
0
0
1
6
7
6
2
4
2
8
.
1
 

5
0
+
E
8
8
4
0
3
8
7
9
5
4
.
2
 

5
0
+
E
1
4
0
3
3
3
1
2
1
6
.
3

5
0
+
E
3
3
0
7
6
1
3
0
8
5
.
2
 

)
0
,
3
,
0
,
0
(
d

)
1
,
3
,
0
,
0
(
d

)
2
,
3
,
0
,
0
(
d

)
3
,
3
,
0
,
0
(
d

)
0
,
4
,
0
,
0
(
d

)
1
,
4
,
0
,
0
(
d

)
2
,
4
,
0
,
0
(
d

)
3
,
4
,
0
,
0
(
d

)
0
,
5
,
0
,
0
(
d

)
1
,
5
,
0
,
0
(
d

)
2
,
5
,
0
,
0
(
d

)
3
,
5
,
0
,
0
(
d

)
0
,
0
,
1
,
0
(
d

)
1
,
0
,
1
,
0
(
d

)
2
,
0
,
1
,
0
(
d

)
3
,
0
,
1
,
0
(
d

)
0
,
1
,
1
,
0
(
d

)
1
,
1
,
1
,
0
(
d

)
2
,
1
,
1
,
0
(
d

)
3
,
1
,
1
,
0
(
d

)
0
,
2
,
1
,
0
(
d

)
1
,
2
,
1
,
0
(
d

)
2
,
2
,
1
,
0
(
d

)
3
,
2
,
1
,
0
(
d

)
0
,
3
,
1
,
0
(
d

)
1
,
3
,
1
,
0
(
d

)
2
,
3
,
1
,
0
(
d

Tabelas de Coeﬁcientes da Parametrização do Modelo Domo Salino

80

r
o
l
a
v

)
2
k
,
1
k
,
2
j
,
1
j
(
d

r
o
l
a
v

)
2
k
,
1
k
,
2
j
,
1
j
(
d

r
o
l
a
v

)
2
k
,
1
k
,
2
j
,
1
j
(
d

r
o
l
a
v

)
2
k
,
1
k
,
2
j
,
1
j
(
d

a
1

.
o
n

i
l
a
s

o
m
o
d

o
d

o
ã
s
r
e
v
n

i

a
n

o
d
a
z
i
l
i
t
u

,
2
o

M

,
l
a
i
c
i
n

i

o
l
e
d
o
m
o
d

o
ã
ç
a
z
i
r
t
e
m
a
r
a
p

a
n

s
o
d
a
z
i
l
i
t
u

s
e
t
n
e
i
c
ﬁ
e
o
C

.
e
t
r
a
p

:
3
.
A

a
l
e
b
a
T

l
a
i
c
i
n
I

o
l
e
d
o
M

2
.
A

3
0
+
E
3
5
4
6
1
4
4
5
3
4
.
9

4
0
+
E
8
5
8
2
4
1
7
2
8
4
.
1

3
0
+
E
6
3
9
0
7
1
5
4
8
4
.
7

4
0
+
E
4
3
8
8
2
9
2
4
6
0
.
1

4
0
+
E
1
6
7
4
8
2
5
2
0
5
.
1

4
0
+
E
4
1
3
6
2
5
4
9
1
8
.
1

3
0
+
E
1
9
5
5
1
8
6
7
2
7
.
8

3
0
+
E
9
6
1
5
1
8
3
5
6
4
.
4

3
0
+
E
7
6
2
3
0
7
9
4
0
5
.
6

3
0
+
E
9
3
1
6
7
3
2
8
3
3
.
8

3
0
+
E
7
1
1
8
5
5
2
1
2
1
.
4

2
0
+
E
2
5
2
2
7
9
5
1
0
4
.
6

3
0
+
E
5
4
9
7
9
5
0
0
5
0
.
1

3
0
+
E
4
7
6
3
9
1
5
3
5
9
.
1

3
0
+
E
8
6
7
7
8
7
1
9
4
1
.
1

4
0
+
E
8
3
6
4
5
9
8
3
2
6
.
1

4
0
+
E
0
7
6
4
1
7
1
2
9
7
.
1

4
0
+
E
2
7
3
9
0
2
5
8
4
2
.
1

3
0
+
E
6
9
7
4
3
0
0
2
2
9
.
5

4
0
+
E
8
9
0
2
4
7
0
1
1
9
.
1
-

4
0
+
E
9
3
3
3
9
2
5
4
7
8
.
3
-

3
0
+
E
4
6
6
4
4
9
8
9
5
7
.
8
-

4
0
+
E
9
9
4
4
8
4
9
2
8
0
.
3
-

4
0
+
E
9
7
9
8
5
6
6
2
0
7
.
4

4
0
+
E
6
2
5
1
0
1
8
5
3
8
.
3

4
0
+
E
1
1
0
4
6
0
6
9
8
9
.
5

3
0
+
E
7
1
8
9
7
4
9
7
3
6
.
4

)
1
,
2
,
1
 

)
2
,
2
,
1
 

)
3
,
2
,
1
 

)
0
,
3
,
1
 

)
1
,
3
,
1
 

)
2
,
3
,
1
 

)
3
,
3
,
1
 

)
0
,
4
,
1
 

)
1
,
4
,
1
 

)
2
,
4
,
1
 

)
3
,
4
,
1
 

)
0
,
5
,
1
 

)
1
,
5
,
1
 

)
2
,
5
,
1
 

)
3
,
5
,
1
 

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

)
0
,
0
,
0
,
0
(
d

)
1
,
0
,
0
,
0
(
d

)
2
,
0
,
0
,
0
(
d

)
3
,
0
,
0
,
0
(
d

)
0
,
1
,
0
,
0
(
d

)
1
,
1
,
0
,
0
(
d

)
2
,
1
,
0
,
0
(
d

)
3
,
1
,
0
,
0
(
d

)
0
,
2
,
0
,
0
(
d

)
1
,
2
,
0
,
0
(
d

)
2
,
2
,
0
,
0
(
d

)
3
,
2
,
0
,
0
(
d

3
0
+
E
2
9
3
6
8
6
3
2
4
1
.
2
 

4
0
+
E
6
4
7
0
3
4
6
4
0
9
.
1
 

4
0
+
E
1
9
1
7
1
1
0
9
4
2
.
3
 

4
0
+
E
5
0
8
8
2
2
0
4
8
1
.
4

4
0
+
E
0
8
6
5
6
6
0
2
5
7
.
3

4
0
+
E
2
1
9
4
8
6
4
4
4
5
.
3
 

3
0
+
E
0
6
3
8
6
3
8
1
3
3
.
3

4
0
+
E
0
7
4
0
7
5
7
9
1
6
.
2
 

4
0
+
E
5
2
0
3
4
4
2
9
3
1
.
2
 

3
0
+
E
2
4
0
3
1
6
1
2
0
6
.
6
 

4
0
+
E
8
8
6
8
3
9
7
6
6
2
.
2
 

5
0
+
E
3
3
3
3
1
0
8
7
9
2
.
1

5
0
+
E
6
7
7
8
7
6
1
5
8
0
.
1

4
0
+
E
5
2
9
6
6
7
1
2
2
4
.
6
 

2
0
+
E
4
0
4
0
8
3
2
1
8
1
.
5
 

4
0
+
E
7
3
8
1
2
9
1
4
8
3
.
1
 

3
0
+
E
9
1
0
7
4
8
0
1
1
3
.
2

4
0
+
E
1
1
4
0
7
5
8
6
8
5
.
1
 

3
0
+
E
5
8
2
7
1
4
8
1
5
9
.
1
 

3
0
+
E
8
1
9
4
1
6
0
9
5
6
.
4
 

3
0
+
E
6
5
8
5
5
7
4
4
3
2
.
3
 

3
0
+
E
1
7
9
7
5
0
6
4
3
0
.
2
 

4
0
+
E
9
7
1
2
3
2
3
5
4
7
.
1

4
0
+
E
3
3
3
8
0
0
7
8
8
2
.
2

4
0
+
E
7
2
7
3
8
7
5
0
6
3
.
2

4
0
+
E
7
4
6
3
6
6
5
0
4
0
.
1

3
0
+
E
9
8
4
6
3
4
1
6
3
8
.
6

)
2
,
1
,
1
,
1
 
(
d

)
3
,
1
,
1
,
1
 
(
d

)
0
,
2
,
1
,
1
 
(
d

)
1
,
2
,
1
,
1
 
(
d

)
2
,
2
,
1
,
1
 
(
d

)
3
,
2
,
1
,
1
 
(
d

)
0
,
3
,
1
,
1
 
(
d

)
1
,
3
,
1
,
1
 
(
d

)
2
,
3
,
1
,
1
 
(
d

)
3
,
3
,
1
,
1
 
(
d

)
0
,
4
,
1
,
1
 
(
d

)
1
,
4
,
1
,
1
 
(
d

)
2
,
4
,
1
,
1
 
(
d

)
3
,
4
,
1
,
1
 
(
d

)
0
,
5
,
1
,
1
 
(
d

)
1
,
5
,
1
,
1
 
(
d

)
2
,
5
,
1
,
1
 
(
d

)
3
,
5
,
1
,
1
 
(
d

)
0
,
0
,
1
 

)
1
,
0
,
1
 

)
2
,
0
,
1
 

)
3
,
0
,
1
 

)
0
,
1
,
1
 

)
1
,
1
,
1
 

)
2
,
1
,
1
 

)
3
,
1
,
1
 

)
0
,
2
,
1
 

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

3
0
+
E
8
9
7
2
1
1
1
0
9
7
.
7

4
0
+
E
0
0
8
5
5
5
5
0
5
3
.
3

4
0
+
E
0
4
6
3
2
8
6
3
3
7
.
3

4
0
+
E
2
1
5
1
8
6
1
9
6
4
.
2

4
0
+
E
1
8
6
1
8
6
0
0
3
9
.
1

4
0
+
E
9
9
0
7
1
1
2
8
4
6
.
1

3
0
+
E
2
5
9
4
2
0
2
6
6
4
.
4
 

4
0
+
E
1
9
8
1
1
9
6
8
7
6
.
2
 

3
0
+
E
5
4
5
5
2
8
6
8
8
3
.
3
 

4
0
+
E
8
3
1
0
6
5
2
8
8
0
.
2

4
0
+
E
4
5
3
2
1
0
3
5
6
4
.
1

3
0
+
E
9
3
8
7
5
4
0
6
4
7
.
5

3
0
+
E
4
1
4
0
4
6
2
1
0
1
.
3
 

4
0
+
E
3
4
0
3
6
3
7
5
8
8
.
3
 

4
0
+
E
8
4
5
9
3
9
6
1
5
8
.
8
 

5
0
+
E
7
9
9
0
5
6
9
4
3
0
.
1
 

4
0
+
E
8
5
8
2
5
4
6
5
2
8
.
4
 

3
0
+
E
4
0
4
7
2
8
4
3
5
0
.
4

3
0
+
E
4
6
0
2
0
5
2
3
9
6
.
9

3
0
+
E
2
5
3
1
7
6
7
8
8
5
.
8

3
0
+
E
7
7
3
9
1
1
3
9
9
1
.
5

3
0
+
E
4
9
8
3
8
4
6
5
3
9
.
4
 

3
0
+
E
0
2
0
0
3
3
8
8
3
2
.
4
 

3
0
+
E
2
6
6
5
7
8
6
6
4
2
.
1

3
0
+
E
0
1
8
7
3
6
4
8
1
3
.
4

4
0
+
E
1
0
4
4
7
7
8
5
1
9
.
1
 

4
0
+
E
9
5
0
0
6
7
0
6
9
3
.
2
 

)
3
,
0
,
0
,
1
 
(
d

)
0
,
1
,
0
,
1
 
(
d

)
1
,
1
,
0
,
1
 
(
d

)
2
,
1
,
0
,
1
 
(
d

)
3
,
1
,
0
,
1
 
(
d

)
0
,
2
,
0
,
1
 
(
d

)
1
,
2
,
0
,
1
 
(
d

)
2
,
2
,
0
,
1
 
(
d

)
3
,
2
,
0
,
1
 
(
d

)
0
,
3
,
0
,
1
 
(
d

)
1
,
3
,
0
,
1
 
(
d

)
2
,
3
,
0
,
1
 
(
d

)
3
,
3
,
0
,
1
 
(
d

)
0
,
4
,
0
,
1
 
(
d

)
1
,
4
,
0
,
1
 
(
d

)
2
,
4
,
0
,
1
 
(
d

)
3
,
4
,
0
,
1
 
(
d

)
0
,
5
,
0
,
1
 
(
d

)
1
,
5
,
0
,
1
 
(
d

)
2
,
5
,
0
,
1
 
(
d

)
3
,
5
,
0
,
1
 
(
d

)
0
,
0
,
1
,
1
 
(
d

)
1
,
0
,
1
,
1
 
(
d

)
2
,
0
,
1
,
1
 
(
d

)
3
,
0
,
1
,
1
 
(
d

)
0
,
1
,
1
,
1
 
(
d

)
1
,
1
,
1
,
1
 
(
d

3
0
+
E
8
8
6
2
2
3
7
0
4
6
.
3
 

3
0
+
E
6
3
6
2
9
3
0
5
8
4
.
4
 

3
0
+
E
5
5
1
5
9
1
6
2
9
4
.
3
 

3
0
+
E
0
5
3
4
1
7
0
9
3
2
.
1
 

3
0
+
E
5
1
2
2
8
7
3
9
6
5
.
9
 

4
0
+
E
7
2
4
9
7
4
6
3
4
2
.
1
 

4
0
+
E
0
2
9
7
9
5
5
3
1
0
.
1
 

3
0
+
E
5
2
2
5
9
8
3
0
2
0
.
4
 

4
0
+
E
4
8
4
4
6
0
7
6
2
2
.
1
 

4
0
+
E
5
0
8
6
6
4
7
3
3
6
.
1
 

4
0
+
E
1
7
2
8
2
9
1
3
8
3
.
1
 

3
0
+
E
8
2
5
1
8
4
6
9
2
8
.
5
 

3
0
+
E
8
3
8
2
0
1
9
3
6
6
.
9
 

4
0
+
E
8
7
4
2
0
6
2
6
1
3
.
1
 

4
0
+
E
2
1
1
8
2
2
6
2
3
1
.
1
 

3
0
+
E
1
8
2
3
1
5
9
4
9
8
.
4
 

3
0
+
E
4
0
6
7
4
2
3
2
9
0
.
3
 

3
0
+
E
0
7
2
8
8
4
6
5
0
3
.
4
 

3
0
+
E
9
2
5
9
6
0
7
9
5
2
.
4
 

3
0
+
E
7
0
8
9
3
3
2
6
0
1
.
2
 

2
0
+
E
3
6
5
2
8
8
7
9
9
9
.
4
 

2
0
+
E
2
7
0
0
0
6
0
9
5
1
.
9
 

3
0
+
E
5
3
7
1
9
4
8
1
0
0
.
1
 

2
0
+
E
1
1
8
8
5
3
9
9
4
2
.
5
 

4
0
+
E
5
3
2
4
0
5
8
8
3
2
.
1

4
0
+
E
3
5
1
6
0
8
4
3
7
2
.
1

3
0
+
E
8
3
3
4
3
7
4
0
8
1
.
9

)
0
,
0
,
1
 

)
1
,
0
,
1
 

)
2
,
0
,
1
 

)
3
,
0
,
1
 

)
0
,
1
,
1
 

)
1
,
1
,
1
 

)
2
,
1
,
1
 

)
3
,
1
,
1
 

)
0
,
2
,
1
 

)
1
,
2
,
1
 

)
2
,
2
,
1
 

)
3
,
2
,
1
 

)
0
,
3
,
1
 

)
1
,
3
,
1
 

)
2
,
3
,
1
 

)
3
,
3
,
1
 

)
0
,
4
,
1
 

)
1
,
4
,
1
 

)
2
,
4
,
1
 

)
3
,
4
,
1
 

)
0
,
5
,
1
 

)
1
,
5
,
1
 

)
2
,
5
,
1
 

)
3
,
5
,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

)
0
,
0
,
0
,
1
 

)
1
,
0
,
0
,
1
 

)
2
,
0
,
0
,
1
 

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

Tabelas de Coeﬁcientes da Parametrização do Modelo Domo Salino

81

a
2

.
o
n

i
l
a
s

o
m
o
d

o
d

o
ã
s
r
e
v
n

i

a
n

o
d
a
z
i
l
i
t
u

,
2
o

M

,
l
a
i
c
i
n

i

o
l
e
d
o
m
o
d

o
ã
ç
a
z
i
r
t
e
m
a
r
a
p

a
n

s
o
d
a
z
i
l
i
t
u

s
e
t
n
e
i
c
ﬁ
e
o
C

.
e
t
r
a
p

:
4
.
A

a
l
e
b
a
T

r
o
l
a
v

)
2
k
,
1
k
,
2
j
,
1
j
(
d

r
o
l
a
v

)
2
k
,
1
k
,
2
j
,
1
j
(
d

r
o
l
a
v

)
2
k
,
1
k
,
2
j
,
1
j
(
d

r
o
l
a
v

)
2
k
,
1
k
,
2
j
,
1
j
(
d

4
0
+
E
1
1
3
2
8
2
7
5
5
5
.
2
 

4
0
+
E
8
4
7
5
5
5
6
9
5
7
.
2
 

4
0
+
E
5
1
6
7
3
2
6
1
6
5
.
1
 

3
0
+
E
3
3
9
2
4
6
6
1
4
1
.
4
 

3
0
+
E
9
9
8
9
6
5
2
4
6
8
.
7

3
0
+
E
2
6
5
5
7
5
5
9
6
0
.
4

2
0
+
E
7
6
4
9
3
0
0
9
1
1
.
4

3
0
+
E
8
1
6
2
7
4
4
3
6
3
.
2

4
0
+
E
6
5
7
1
0
2
3
9
5
6
.
4
 

3
0
+
E
9
4
2
0
7
2
8
6
6
0
.
9
 

4
0
+
E
0
1
2
7
4
7
3
7
3
4
.
5
 

3
0
+
E
4
1
5
1
0
4
4
9
4
0
.
9

4
0
+
E
3
1
3
4
2
1
2
7
6
3
.
3

4
0
+
E
6
4
2
9
5
5
3
6
8
6
.
4
 

4
0
+
E
3
4
9
0
7
9
6
9
3
5
.
2
 

3
0
+
E
6
7
5
9
8
4
2
9
8
2
.
5
 

4
0
+
E
0
4
8
6
4
7
1
4
7
9
.
1
 

3
0
+
E
2
8
5
0
0
1
8
2
0
6
.
1
 

4
0
+
E
1
8
5
9
5
0
9
7
4
5
.
3
 

3
0
+
E
3
3
1
5
6
7
6
2
0
5
.
4

4
0
+
E
2
4
4
8
5
6
1
1
2
9
.
1

4
0
+
E
9
6
6
3
5
0
2
1
0
0
.
4
 

4
0
+
E
7
8
4
8
7
6
4
6
0
2
.
3
 

3
0
+
E
5
6
9
2
6
5
0
6
1
5
.
6
 

4
0
+
E
7
0
4
4
5
9
6
5
7
9
.
2

4
0
+
E
3
2
0
3
7
6
4
7
2
6
.
1

4
0
+
E
4
4
7
8
2
9
8
9
3
7
.
1
 

)
1
,
5
,
0
,
1
(
d

)
2
,
5
,
0
,
1
(
d

)
3
,
5
,
0
,
1
(
d

)
0
,
0
,
1
,
1
(
d

)
1
,
0
,
1
,
1
(
d

)
2
,
0
,
1
,
1
(
d

)
3
,
0
,
1
,
1
(
d

)
0
,
1
,
1
,
1
(
d

)
1
,
1
,
1
,
1
(
d

)
2
,
1
,
1
,
1
(
d

)
3
,
1
,
1
,
1
(
d

)
0
,
2
,
1
,
1
(
d

)
1
,
2
,
1
,
1
(
d

)
2
,
2
,
1
,
1
(
d

)
3
,
2
,
1
,
1
(
d

)
0
,
3
,
1
,
1
(
d

)
1
,
3
,
1
,
1
(
d

)
2
,
3
,
1
,
1
(
d

)
3
,
3
,
1
,
1
(
d

)
0
,
4
,
1
,
1
(
d

)
1
,
4
,
1
,
1
(
d

)
2
,
4
,
1
,
1
(
d

)
3
,
4
,
1
,
1
(
d

)
0
,
5
,
1
,
1
(
d

)
1
,
5
,
1
,
1
(
d

)
2
,
5
,
1
,
1
(
d

)
3
,
5
,
1
,
1
(
d

2
0
+
E
7
9
1
4
8
2
5
1
7
6
.
3

2
0
+
E
4
3
9
6
6
5
8
7
7
1
.
3

2
0
+
E
1
7
7
8
3
1
8
7
2
5
.
4

2
0
+
E
6
5
6
3
0
8
3
5
3
4
.
8

2
0
+
E
9
5
2
0
1
3
9
3
9
0
.
7

2
0
+
E
1
1
5
3
6
0
1
3
1
2
.
3

3
0
+
E
9
4
6
8
1
9
3
7
9
6
.
3

4
0
+
E
5
3
2
6
5
1
5
5
7
3
.
1
 

3
0
+
E
4
3
4
3
6
1
5
5
4
0
.
2
 

4
0
+
E
3
7
3
8
0
5
9
7
8
3
.
1
 

3
0
+
E
7
0
6
2
5
3
1
8
9
1
.
1

4
0
+
E
9
7
1
7
7
0
6
3
9
4
.
3

4
0
+
E
9
9
6
6
3
1
8
6
1
8
.
1

4
0
+
E
2
6
6
9
6
3
9
6
4
8
.
2

4
0
+
E
8
6
1
9
7
3
4
6
5
3
.
2

4
0
+
E
4
4
7
8
2
2
1
9
2
8
.
3

4
0
+
E
4
4
3
9
9
0
3
8
6
7
.
4

4
0
+
E
4
8
5
3
4
7
9
5
1
0
.
2

3
0
+
E
7
4
7
1
3
2
2
7
2
8
.
4

3
0
+
E
1
1
2
9
3
5
7
8
6
8
.
7

3
0
+
E
8
9
6
3
7
9
1
4
1
4
.
7

3
0
+
E
9
5
4
2
3
7
2
4
9
1
.
1

4
0
+
E
9
0
7
0
6
1
9
5
7
5
.
1

4
0
+
E
0
9
1
0
9
9
9
3
1
0
.
3

4
0
+
E
4
0
8
2
4
9
5
1
5
3
.
3

4
0
+
E
2
0
4
6
9
7
2
8
2
6
.
1

4
0
+
E
3
6
9
6
7
6
7
1
8
1
.
1
 

)
2
,
4
,
1
 

)
3
,
4
,
1
 

)
0
,
5
,
1
 

)
1
,
5
,
1
 

)
2
,
5
,
1
 

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

)
3
,
5
,
1
 

)
0
,
0
,
0
,
1
(
d

)
1
,
0
,
0
,
1
(
d

)
2
,
0
,
0
,
1
(
d

)
3
,
0
,
0
,
1
(
d

)
0
,
1
,
0
,
1
(
d

)
1
,
1
,
0
,
1
(
d

)
2
,
1
,
0
,
1
(
d

)
3
,
1
,
0
,
1
(
d

)
0
,
2
,
0
,
1
(
d

)
1
,
2
,
0
,
1
(
d

)
2
,
2
,
0
,
1
(
d

)
3
,
2
,
0
,
1
(
d

)
0
,
3
,
0
,
1
(
d

)
1
,
3
,
0
,
1
(
d

)
2
,
3
,
0
,
1
(
d

)
3
,
3
,
0
,
1
(
d

)
0
,
4
,
0
,
1
(
d

)
1
,
4
,
0
,
1
(
d

)
2
,
4
,
0
,
1
(
d

)
3
,
4
,
0
,
1
(
d

)
0
,
5
,
0
,
1
(
d

3
0
+
E
8
9
6
8
2
7
9
1
1
9
.
6
 

3
0
+
E
9
0
0
3
8
9
3
5
2
0
.
7
 

3
0
+
E
5
9
9
1
4
1
1
6
1
2
.
2
 

3
0
+
E
6
9
4
6
9
5
1
9
8
7
.
6

3
0
+
E
2
6
5
7
2
1
4
2
3
1
.
2

4
0
+
E
2
4
8
3
9
2
0
1
7
3
.
1
 

4
0
+
E
2
8
4
1
7
3
7
1
0
3
.
4

5
0
+
E
6
0
3
3
0
2
1
3
1
2
.
1
 

3
0
+
E
4
2
3
6
7
5
0
7
8
1
.
4

5
0
+
E
4
9
5
3
2
9
1
7
7
2
.
1
 

3
0
+
E
9
4
7
6
4
4
6
7
4
6
.
7

3
0
+
E
2
0
6
3
6
6
5
2
4
3
.
9

3
0
+
E
6
9
6
8
9
6
6
3
5
1
.
5

3
0
+
E
8
5
4
1
0
4
2
7
5
1
.
8
 

4
0
+
E
7
8
0
6
2
8
3
8
3
1
.
1
 

4
0
+
E
7
9
5
9
2
2
4
8
3
4
.
1
 

3
0
+
E
5
2
8
4
9
9
3
4
6
9
.
6
 

3
0
+
E
7
7
2
1
5
2
9
8
3
4
.
1

3
0
+
E
4
9
6
0
8
3
7
6
4
2
.
2

3
0
+
E
2
9
5
0
9
5
6
2
1
5
.
3

3
0
+
E
9
9
6
5
8
4
6
6
6
9
.
1

2
0
+
E
9
6
9
6
7
4
5
4
0
1
.
3

1
0
+
E
2
2
3
0
4
9
6
4
5
5
.
4
 

2
0
+
E
0
7
5
2
8
8
2
6
9
9
.
2

2
0
+
E
9
4
6
5
4
8
0
4
3
4
.
2

1
0
+
E
8
6
7
2
7
3
6
1
4
8
.
8
 

0
0
+
E
7
6
0
7
9
0
1
0
7
3
.
4
 

)
3
,
3
,
1
,
0
(
d

)
0
,
4
,
1
,
0
(
d

)
1
,
4
,
1
,
0
(
d

)
2
,
4
,
1
,
0
(
d

)
3
,
4
,
1
,
0
(
d

)
0
,
5
,
1
,
0
(
d

)
1
,
5
,
1
,
0
(
d

)
2
,
5
,
1
,
0
(
d

)
3
,
5
,
1
,
0
(
d

)
0
,
0
,
1
 

)
1
,
0
,
1
 

)
2
,
0
,
1
 

)
3
,
0
,
1
 

)
0
,
1
,
1
 

)
1
,
1
,
1
 

)
2
,
1
,
1
 

)
3
,
1
,
1
 

)
0
,
2
,
1
 

)
1
,
2
,
1
 

)
2
,
2
,
1
 

)
3
,
2
,
1
 

)
0
,
3
,
1
 

)
1
,
3
,
1
 

)
2
,
3
,
1
 

)
3
,
3
,
1
 

)
0
,
4
,
1
 

)
1
,
4
,
1
 

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

3
0
+
E
9
1
3
0
3
2
3
6
1
1
.
3

4
0
+
E
0
7
2
0
0
3
0
5
5
1
.
3
 

4
0
+
E
6
3
8
5
2
2
5
9
8
2
.
1
 

3
0
+
E
1
6
4
9
1
1
2
9
1
1
.
8

4
0
+
E
9
9
5
9
0
7
3
5
1
5
.
3
 

3
0
+
E
0
5
4
3
1
5
9
3
9
8
.
3

3
0
+
E
1
1
9
8
3
0
4
1
6
2
.
5
 

4
0
+
E
2
8
3
0
2
2
1
0
2
3
.
4

4
0
+
E
8
7
6
1
2
5
0
7
9
1
.
1
 

4
0
+
E
4
8
6
6
4
8
7
6
5
0
.
8

4
0
+
E
9
9
5
6
0
4
1
7
8
7
.
8

4
0
+
E
0
7
0
6
2
3
7
3
6
7
.
3

3
0
+
E
9
2
5
7
9
0
7
6
4
3
.
8
 

3
0
+
E
8
7
4
3
9
4
9
5
2
5
.
8
 

3
0
+
E
0
1
5
0
2
3
3
2
6
7
.
5

4
0
+
E
2
5
3
2
8
2
3
8
6
8
.
1

3
0
+
E
5
1
3
2
1
1
7
2
9
3
.
3
 

4
0
+
E
6
7
5
6
3
6
0
4
7
2
.
2

4
0
+
E
9
8
0
2
2
5
3
7
4
7
.
2

4
0
+
E
1
6
0
9
5
7
7
0
9
4
.
2

3
0
+
E
8
7
7
8
1
2
2
3
2
7
.
5
 

4
0
+
E
2
5
5
4
2
1
0
7
4
6
.
4
 

4
0
+
E
0
0
0
6
6
2
8
7
5
9
.
4

4
0
+
E
8
9
5
5
0
4
8
6
1
1
.
3
 

4
0
+
E
1
2
4
1
0
3
1
3
2
3
.
1
 

4
0
+
E
1
1
8
5
2
8
5
6
0
0
.
2

3
0
+
E
1
9
9
1
1
6
6
6
7
5
.
4

)
0
,
3
,
0
,
0
(
d

)
1
,
3
,
0
,
0
(
d

)
2
,
3
,
0
,
0
(
d

)
3
,
3
,
0
,
0
(
d

)
0
,
4
,
0
,
0
(
d

)
1
,
4
,
0
,
0
(
d

)
2
,
4
,
0
,
0
(
d

)
3
,
4
,
0
,
0
(
d

)
0
,
5
,
0
,
0
(
d

)
1
,
5
,
0
,
0
(
d

)
2
,
5
,
0
,
0
(
d

)
3
,
5
,
0
,
0
(
d

)
0
,
0
,
1
,
0
(
d

)
1
,
0
,
1
,
0
(
d

)
2
,
0
,
1
,
0
(
d

)
3
,
0
,
1
,
0
(
d

)
0
,
1
,
1
,
0
(
d

)
1
,
1
,
1
,
0
(
d

)
2
,
1
,
1
,
0
(
d

)
3
,
1
,
1
,
0
(
d

)
0
,
2
,
1
,
0
(
d

)
1
,
2
,
1
,
0
(
d

)
2
,
2
,
1
,
0
(
d

)
3
,
2
,
1
,
0
(
d

)
0
,
3
,
1
,
0
(
d

)
1
,
3
,
1
,
0
(
d

)
2
,
3
,
1
,
0
(
d

Tabelas de Coeﬁcientes da Parametrização do Modelo Domo Salino

82

.
e
t
r
a
p

a
1

.
o
ã
s
r
e
v
n

i

a
n

s
o
d
i
t
b
o

,
I
,
2

M

,
o
n

i
l
a
s

o
m
o
d

o
l
e
d
o
m
o
d

o
ã
ç
a
z
i
r
t
e
m
a
r
a
p

a
d

s
e
t
n
e
i
c
ﬁ
e
o
C

:
5
.
A
a
l
e
b
a
T

r
o
l
a
v

)
2
k
,
1
k
,
2
j
,
1
j
(
d

r
o
l
a
v

)
2
k
,
1
k
,
2
j
,
1
j
(
d

r
o
l
a
v

)
2
k
,
1
k
,
2
j
,
1
j
(
d

r
o
l
a
v

)
2
k
,
1
k
,
2
j
,
1
j
(
d

o
d
i
t
r
e
v
n
I

o
l
e
d
o
M

3
.
A

3
0
+
E
0
2
4
4
3
6
4
4
1
9
.
1

2
0
+
E
6
4
0
6
8
2
2
3
3
3
.
9
 

3
0
+
E
4
2
7
4
0
8
1
7
3
4
.
1

3
0
+
E
1
5
9
1
4
3
2
7
5
0
.
2
 

3
0
+
E
1
5
2
4
5
1
1
1
2
0
.
1
 

2
0
+
E
0
9
8
3
9
3
3
5
9
9
.
6

2
0
+
E
7
8
8
6
2
6
6
5
4
3
.
5

2
0
+
E
7
1
8
6
0
9
4
1
4
5
.
2

2
0
+
E
6
3
6
0
6
2
5
8
3
4
.
5
 

2
0
+
E
9
2
5
4
4
8
4
1
1
3
.
9

2
0
+
E
0
0
3
3
8
6
3
7
9
7
.
4

2
0
+
E
4
8
6
6
6
5
6
7
1
8
.
3

2
0
+
E
4
1
6
1
0
6
9
8
5
2
.
7

2
0
+
E
2
4
3
6
0
4
5
3
2
0
.
6

2
0
+
E
4
2
6
5
8
7
7
7
8
8
.
1

2
0
+
E
8
4
5
7
6
5
1
1
8
3
.
9
 

4
0
+
E
8
7
2
8
2
0
6
1
8
4
.
2
 

4
0
+
E
6
7
5
5
1
9
7
0
1
5
.
2
 

4
0
+
E
6
1
5
9
3
5
3
1
8
5
.
2
 

3
0
+
E
5
5
8
5
3
3
8
9
3
6
.
3
 

4
0
+
E
0
1
9
7
7
2
9
4
0
0
.
4
 

4
0
+
E
5
0
6
2
6
3
7
8
5
7
.
4
 

4
0
+
E
2
6
9
8
6
5
0
0
0
0
.
4
 

4
0
+
E
0
2
1
8
6
5
9
2
8
8
.
1

4
0
+
E
7
0
5
3
4
0
8
4
7
6
.
2
 

4
0
+
E
5
3
0
5
8
7
8
9
6
4
.
3
 

4
0
+
E
8
3
4
7
0
5
2
2
5
7
.
4
 

)
1
,
2
,
1
 

)
2
,
2
,
1
 

)
3
,
2
,
1
 

)
0
,
3
,
1
 

)
1
,
3
,
1
 

)
2
,
3
,
1
 

)
3
,
3
,
1
 

)
0
,
4
,
1
 

)
1
,
4
,
1
 

)
2
,
4
,
1
 

)
3
,
4
,
1
 

)
0
,
5
,
1
 

)
1
,
5
,
1
 

)
2
,
5
,
1
 

)
3
,
5
,
1
 

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

)
0
,
0
,
0
,
0
(
d

)
1
,
0
,
0
,
0
(
d

)
2
,
0
,
0
,
0
(
d

)
3
,
0
,
0
,
0
(
d

)
0
,
1
,
0
,
0
(
d

)
1
,
1
,
0
,
0
(
d

)
2
,
1
,
0
,
0
(
d

)
3
,
1
,
0
,
0
(
d

)
0
,
2
,
0
,
0
(
d

)
1
,
2
,
0
,
0
(
d

)
2
,
2
,
0
,
0
(
d

)
3
,
2
,
0
,
0
(
d

3
0
+
E
6
2
7
5
8
1
6
2
2
4
.
3

4
0
+
E
6
4
3
8
5
0
0
7
1
2
.
1
 

3
0
+
E
0
1
6
9
4
2
4
9
1
8
.
5

3
0
+
E
1
0
6
0
5
2
9
5
5
3
.
8
 

3
0
+
E
2
5
0
3
3
3
2
0
9
1
.
6
 

3
0
+
E
0
9
7
2
6
0
8
6
4
1
.
6
 

3
0
+
E
9
1
1
1
3
6
4
5
3
8
.
4
 

4
0
+
E
9
3
5
7
6
0
8
3
5
8
.
2

4
0
+
E
3
6
2
2
2
6
7
9
6
3
.
2

4
0
+
E
9
6
1
6
2
7
6
4
5
0
.
1
 

3
0
+
E
8
3
9
1
3
8
3
7
8
5
.
1

4
0
+
E
7
3
3
6
2
7
7
6
3
1
.
1

4
0
+
E
2
0
4
8
9
2
2
9
7
6
.
1

1
0
+
E
7
5
6
7
6
5
0
1
8
3
.
6
 

3
0
+
E
7
7
0
3
8
2
9
9
3
6
.
8

4
0
+
E
2
1
4
3
6
4
2
1
6
6
.
2

4
0
+
E
3
5
8
4
0
6
9
9
6
1
.
5
 

2
0
+
E
2
4
3
4
8
1
5
0
3
9
.
5

4
0
+
E
2
5
9
9
6
4
3
2
2
6
.
3
 

3
0
+
E
8
7
5
6
5
9
7
8
9
1
.
2

3
0
+
E
9
1
5
6
7
4
9
7
1
1
.
3

3
0
+
E
3
3
4
9
6
0
7
3
9
6
.
1

3
0
+
E
1
3
5
9
3
8
7
3
3
5
.
1
 

3
0
+
E
3
9
1
4
3
6
8
5
8
0
.
1
 

2
0
+
E
7
2
0
5
4
3
8
4
1
8
.
1
 

2
0
+
E
1
7
3
1
0
4
9
1
2
0
.
2
 

3
0
+
E
4
5
3
7
6
0
6
1
4
8
.
2
 

)
2
,
1
,
1
,
1
 
(
d

)
3
,
1
,
1
,
1
 
(
d

)
0
,
2
,
1
,
1
 
(
d

)
1
,
2
,
1
,
1
 
(
d

)
2
,
2
,
1
,
1
 
(
d

)
3
,
2
,
1
,
1
 
(
d

)
0
,
3
,
1
,
1
 
(
d

)
1
,
3
,
1
,
1
 
(
d

)
2
,
3
,
1
,
1
 
(
d

)
3
,
3
,
1
,
1
 
(
d

)
0
,
4
,
1
,
1
 
(
d

)
1
,
4
,
1
,
1
 
(
d

)
2
,
4
,
1
,
1
 
(
d

)
3
,
4
,
1
,
1
 
(
d

)
0
,
5
,
1
,
1
 
(
d

)
1
,
5
,
1
,
1
 
(
d

)
2
,
5
,
1
,
1
 
(
d

)
3
,
5
,
1
,
1
 
(
d

)
0
,
0
,
1
 

)
1
,
0
,
1
 

)
2
,
0
,
1
 

)
3
,
0
,
1
 

)
0
,
1
,
1
 

)
1
,
1
,
1
 

)
2
,
1
,
1
 

)
3
,
1
,
1
 

)
0
,
2
,
1
 

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

,
0
(
d

3
0
+
E
4
6
3
2
4
7
5
8
2
6
.
2

3
0
+
E
5
0
9
6
4
1
7
5
9
0
.
2
 

4
0
+
E
4
4
0
0
4
6
1
9
5
5
.
1
 

4
0
+
E
8
9
2
8
5
6
6
3
8
5
.
1
 

4
0
+
E
6
3
6
2
0
3
8
5
8
1
.
1
 

3
0
+
E
5
0
2
4
1
6
9
5
9
1
.
3

3
0
+
E
7
4
4
1
0
0
7
7
1
6
.
7
 

3
0
+
E
4
9
9
0
5
8
5
5
2
0
.
6
 

3
0
+
E
4
2
2
9
9
4
4
6
4
1
.
8
 

3
0
+
E
6
3
3
6
2
6
0
6
9
2
.
6
 

4
0
+
E
0
9
9
8
6
4
5
7
6
1
.
2
 

4
0
+
E
4
8
9
5
8
8
9
2
5
0
.
2
 

4
0
+
E
2
2
6
5
7
7
4
6
3
3
.
1
 

3
0
+
E
8
5
8
8
4
8
0
2
5
2
.
2
 

3
0
+
E
5
3
1
9
0
8
4
8
7
5
.
6
 

3
0
+
E
0
9
2
8
7
5
3
8
4
0
.
5
 

3
0
+
E
5
0
7
1
0
3
5
9
7
7
.
2
 

4
0
+
E
8
4
3
9
8
4
4
4
4
9
.
1

4
0
+
E
6
4
8
0
8
1
9
1
8
0
.
4

4
0
+
E
6
7
2
8
9
7
2
6
6
4
.
4

4
0
+
E
2
8
4
6
9
3
5
1
7
3
.
2

3
0
+
E
6
6
2
1
9
3
6
4
7
7
.
3
 

4
0
+
E
2
8
1
1
3
7
1
6
4
3
.
1
 

3
0
+
E
3
3
4
2
6
9
8
5
8
6
.
1

4
0
+
E
2
1
0
3
0
2
4
2
1
9
.
1
 

3
0
+
E
3
2
9
3
3
7
9
9
7
1
.
9
 

4
0
+
E
0
2
5
4
0
3
2
4
0
7
.
1

)
3
,
0
,
0
,
1
 
(
d

)
0
,
1
,
0
,
1
 
(
d

)
1
,
1
,
0
,
1
 
(
d

)
2
,
1
,
0
,
1
 
(
d

)
3
,
1
,
0
,
1
 
(
d

)
0
,
2
,
0
,
1
 
(
d

)
1
,
2
,
0
,
1
 
(
d

)
2
,
2
,
0
,
1
 
(
d

)
3
,
2
,
0
,
1
 
(
d

)
0
,
3
,
0
,
1
 
(
d

)
1
,
3
,
0
,
1
 
(
d

)
2
,
3
,
0
,
1
 
(
d

)
3
,
3
,
0
,
1
 
(
d

)
0
,
4
,
0
,
1
 
(
d

)
1
,
4
,
0
,
1
 
(
d

)
2
,
4
,
0
,
1
 
(
d

)
3
,
4
,
0
,
1
 
(
d

)
0
,
5
,
0
,
1
 
(
d

)
1
,
5
,
0
,
1
 
(
d

)
2
,
5
,
0
,
1
 
(
d

)
3
,
5
,
0
,
1
 
(
d

)
0
,
0
,
1
,
1
 
(
d

)
1
,
0
,
1
,
1
 
(
d

)
2
,
0
,
1
,
1
 
(
d

)
3
,
0
,
1
,
1
 
(
d

)
0
,
1
,
1
,
1
 
(
d

)
1
,
1
,
1
,
1
 
(
d

2
0
+
E
2
9
1
8
4
3
8
9
7
0
.
5
 

2
0
+
E
6
7
6
1
7
5
6
0
6
9
.
2
 

2
0
+
E
9
2
6
5
8
3
6
2
0
9
.
1

2
0
+
E
2
1
8
0
7
3
9
2
5
8
.
2

2
0
+
E
7
8
8
4
0
2
4
6
4
6
.
7

2
0
+
E
5
9
1
4
5
8
2
9
2
2
.
1
 

3
0
+
E
0
2
3
7
6
1
6
2
4
5
.
1

3
0
+
E
7
7
7
1
6
9
2
1
7
0
.
1

3
0
+
E
8
1
5
1
5
5
5
3
0
2
.
1

1
0
+
E
2
7
0
7
2
4
3
1
6
0
.
2
 

3
0
+
E
0
7
2
9
4
7
3
1
7
2
.
2

3
0
+
E
3
3
4
1
1
4
5
9
4
5
.
1

2
0
+
E
9
8
6
3
6
5
2
6
8
7
.
3

3
0
+
E
2
7
5
6
8
6
1
0
2
4
.
1

3
0
+
E
9
7
3
1
9
5
4
9
7
0
.
2

3
0
+
E
0
9
3
4
9
6
8
7
9
2
.
1

2
0
+
E
1
2
6
9
4
1
2
7
6
4
.
2

2
0
+
E
1
9
5
1
9
5
6
1
2
6
.
6

2
0
+
E
9
5
2
8
3
5
4
0
1
1
.
9

2
0
+
E
9
6
1
7
3
2
7
8
2
6
.
5

2
0
+
E
7
2
3
1
1
0
6
2
9
2
.
4
 

2
0
+
E
1
1
3
7
4
8
1
9
1
5
.
6
 

2
0
+
E
3
6
7
5
2
3
1
5
9
9
.
3
 

1
0
+
E
6
1
4
5
5
3
7
4
7
9
.
7
 

3
0
+
E
5
2
0
2
3
8
8
1
1
1
.
7

3
0
+
E
5
2
6
6
5
8
2
2
2
4
.
8

3
0
+
E
4
9
8
7
6
6
5
3
2
6
.
8

)
0
,
0
,
1
 

)
1
,
0
,
1
 

)
2
,
0
,
1
 

)
3
,
0
,
1
 

)
0
,
1
,
1
 

)
1
,
1
,
1
 

)
2
,
1
,
1
 

)
3
,
1
,
1
 

)
0
,
2
,
1
 

)
1
,
2
,
1
 

)
2
,
2
,
1
 

)
3
,
2
,
1
 

)
0
,
3
,
1
 

)
1
,
3
,
1
 

)
2
,
3
,
1
 

)
3
,
3
,
1
 

)
0
,
4
,
1
 

)
1
,
4
,
1
 

)
2
,
4
,
1
 

)
3
,
4
,
1
 

)
0
,
5
,
1
 

)
1
,
5
,
1
 

)
2
,
5
,
1
 

)
3
,
5
,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

,
1
 

)
0
,
0
,
0
,
1
 

)
1
,
0
,
0
,
1
 

)
2
,
0
,
0
,
1
 

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

(
d

Tabelas de Coeﬁcientes da Parametrização do Modelo Domo Salino

83

.
e
t
r
a
p

a
2

.
o
ã
s
r
e
v
n

i

a
n

s
o
d
i
t
b
o

,
I
,
2

M

,
o
n

i
l
a
s

o
m
o
d

o
l
e
d
o
m
o
d

o
ã
ç
a
z
i
r
t
e
m
a
r
a
p

a
d

s
e
t
n
e
i
c
ﬁ
e
o
C

:
6
.
A
a
l
e
b
a
T

r
o
l
a
v

)
2
k
,
1
k
,
2
j
,
1
j
(
d

r
o
l
a
v

)
2
k
,
1
k
,
2
j
,
1
j
(
d

r
o
l
a
v

)
2
k
,
1
k
,
2
j
,
1
j
(
d

r
o
l
a
v

)
2
k
,
1
k
,
2
j
,
1
j
(
d

4
0
+
E
0
0
6
3
3
5
9
7
6
3
.
1

4
0
+
E
1
7
8
0
1
0
2
7
3
4
.
1

3
0
+
E
7
0
9
1
6
2
6
2
6
9
.
6

3
0
+
E
0
8
6
9
6
0
0
4
8
9
.
8

3
0
+
E
0
5
2
5
4
9
9
3
8
6
.
9
 

3
0
+
E
7
3
4
3
8
3
2
6
6
3
.
7
 

3
0
+
E
2
8
7
2
3
6
9
3
5
4
.
1
 

4
0
+
E
5
8
8
4
6
5
4
6
6
1
.
3

4
0
+
E
0
7
8
7
8
4
8
8
0
7
.
1

4
0
+
E
8
2
0
6
3
0
5
7
2
2
.
1
 

4
0
+
E
0
3
0
9
9
8
2
2
8
4
.
3

4
0
+
E
9
4
3
0
0
7
8
7
2
7
.
6

4
0
+
E
1
4
7
1
6
5
9
3
0
2
.
1
 

4
0
+
E
8
6
7
4
3
0
9
0
2
3
.
5

4
0
+
E
6
1
7
6
3
3
4
2
6
8
.
2
 

4
0
+
E
4
9
2
1
0
7
7
8
9
4
.
3

3
0
+
E
9
8
2
9
2
5
1
7
3
1
.
2
 

4
0
+
E
4
7
5
5
3
2
2
1
6
0
.
3

4
0
+
E
2
0
4
4
1
2
9
4
5
5
.
1
 

4
0
+
E
9
9
6
9
7
7
4
6
4
7
.
2

3
0
+
E
3
5
3
2
4
4
7
7
3
0
.
3
 

4
0
+
E
7
4
5
5
1
3
8
0
0
4
.
2

4
0
+
E
7
7
0
0
3
4
4
6
3
1
.
1
 

2
0
+
E
6
6
6
8
0
2
8
8
8
8
.
6

3
0
+
E
3
1
6
6
2
2
7
4
7
5
.
6

4
0
+
E
2
0
9
9
5
6
0
6
2
0
.
2
 

4
0
+
E
1
6
4
7
3
3
8
9
9
0
.
2
 

)
1
,
5
,
0
,
1
(
d

)
2
,
5
,
0
,
1
(
d

)
3
,
5
,
0
,
1
(
d

)
0
,
0
,
1
,
1
(
d

)
1
,
0
,
1
,
1
(
d

)
2
,
0
,
1
,
1
(
d

)
3
,
0
,
1
,
1
(
d

)
0
,
1
,
1
,
1
(
d

)
1
,
1
,
1
,
1
(
d

)
2
,
1
,
1
,
1
(
d

)
3
,
1
,
1
,
1
(
d

)
0
,
2
,
1
,
1
(
d

)
1
,
2
,
1
,
1
(
d

)
2
,
2
,
1
,
1
(
d

)
3
,
2
,
1
,
1
(
d

)
0
,
3
,
1
,
1
(
d

)
1
,
3
,
1
,
1
(
d

)
2
,
3
,
1
,
1
(
d

)
3
,
3
,
1
,
1
(
d

)
0
,
4
,
1
,
1
(
d

)
1
,
4
,
1
,
1
(
d

)
2
,
4
,
1
,
1
(
d

)
3
,
4
,
1
,
1
(
d

)
0
,
5
,
1
,
1
(
d

)
1
,
5
,
1
,
1
(
d

)
2
,
5
,
1
,
1
(
d

)
3
,
5
,
1
,
1
(
d

1
0
+
E
8
0
5
0
8
7
1
9
8
7
.
3

1
0
+
E
5
2
2
6
2
8
5
7
6
2
.
1
 

1
0
+
E
0
2
7
0
4
6
0
0
4
3
.
8
 

2
0
+
E
4
9
6
4
6
1
6
1
6
4
.
1
 

1
0
+
E
7
3
5
1
7
4
1
9
4
8
.
9
 

1
0
+
E
6
0
9
5
9
9
6
1
2
5
.
2
 

3
0
+
E
9
5
4
1
9
3
7
5
2
5
.
3

3
0
+
E
2
8
6
3
0
0
3
7
5
0
.
5
 

3
0
+
E
4
7
0
5
3
0
5
5
8
7
.
8
 

3
0
+
E
4
5
2
5
6
9
2
5
7
2
.
7
 

4
0
+
E
3
4
2
1
9
6
5
4
3
3
.
1
 

4
0
+
E
3
3
8
8
0
3
5
0
2
5
.
1

4
0
+
E
4
4
1
9
9
5
3
1
6
0
.
2

4
0
+
E
2
5
9
5
5
5
4
0
5
8
.
2

4
0
+
E
5
3
5
5
0
8
8
2
5
8
.
1
 

4
0
+
E
8
6
9
2
9
2
8
1
4
8
.
4
 

4
0
+
E
8
6
7
1
2
2
3
7
0
3
.
5
 

4
0
+
E
6
0
5
6
5
8
6
9
0
0
.
3
 

4
0
+
E
2
7
1
4
6
7
3
4
5
4
.
1
 

4
0
+
E
9
1
2
7
3
8
4
0
4
6
.
2
 

4
0
+
E
8
4
6
3
1
7
0
2
3
8
.
2
 

4
0
+
E
5
6
4
1
0
2
8
1
3
3
.
1
 

3
0
+
E
7
9
4
7
2
2
9
5
7
0
.
9
 

4
0
+
E
3
7
2
6
6
5
9
0
7
9
.
1
 

4
0
+
E
3
4
1
3
0
3
6
5
3
1
.
2
 

4
0
+
E
7
7
2
8
7
4
6
3
9
0
.
1
 

3
0
+
E
4
0
2
8
9
1
5
7
1
6
.
6

)
2
,
4
,
1
 

)
3
,
4
,
1
 

)
0
,
5
,
1
 

)
1
,
5
,
1
 

)
2
,
5
,
1
 

)
3
,
5
,
1
 

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

)
0
,
0
,
0
,
1
(
d

)
1
,
0
,
0
,
1
(
d

)
2
,
0
,
0
,
1
(
d

)
3
,
0
,
0
,
1
(
d

)
0
,
1
,
0
,
1
(
d

)
1
,
1
,
0
,
1
(
d

)
2
,
1
,
0
,
1
(
d

)
3
,
1
,
0
,
1
(
d

)
0
,
2
,
0
,
1
(
d

)
1
,
2
,
0
,
1
(
d

)
2
,
2
,
0
,
1
(
d

)
3
,
2
,
0
,
1
(
d

)
0
,
3
,
0
,
1
(
d

)
1
,
3
,
0
,
1
(
d

)
2
,
3
,
0
,
1
(
d

)
3
,
3
,
0
,
1
(
d

)
0
,
4
,
0
,
1
(
d

)
1
,
4
,
0
,
1
(
d

)
2
,
4
,
0
,
1
(
d

)
3
,
4
,
0
,
1
(
d

)
0
,
5
,
0
,
1
(
d

4
0
+
E
9
9
5
7
5
8
0
6
8
3
.
1
 

4
0
+
E
8
2
0
4
6
9
9
2
8
4
.
2
 

4
0
+
E
8
2
1
4
8
7
4
2
4
2
.
6

4
0
+
E
6
7
2
3
2
9
2
3
0
2
.
2

4
0
+
E
2
5
5
1
4
9
9
0
7
6
.
3
 

4
0
+
E
7
4
8
6
2
5
2
6
5
0
.
6

3
0
+
E
2
5
8
5
0
1
5
3
3
3
.
9
 

4
0
+
E
2
5
9
5
2
1
7
2
7
5
.
4

4
0
+
E
0
6
6
9
2
6
3
3
6
7
.
2
 

3
0
+
E
8
6
7
2
7
3
5
5
8
7
.
1
 

3
0
+
E
5
5
8
2
3
5
3
3
1
1
.
2
 

3
0
+
E
3
8
0
5
7
1
7
3
0
5
.
1
 

2
0
+
E
0
1
1
4
3
2
3
7
2
3
.
6
 

3
0
+
E
6
8
0
8
2
6
3
8
3
4
.
2

3
0
+
E
2
5
6
6
6
7
1
4
5
5
.
1

2
0
+
E
6
3
7
2
2
5
9
0
9
2
.
3
 

2
0
+
E
2
3
2
8
3
9
2
5
3
6
.
4
 

2
0
+
E
5
5
5
5
4
1
6
7
1
0
.
5
 

2
0
+
E
0
7
4
1
7
4
6
6
3
1
.
2
 

1
0
+
E
5
5
7
3
9
4
8
4
2
3
.
6

1
0
+
E
9
0
2
6
4
4
0
2
6
6
.
2

2
0
+
E
0
8
9
5
2
8
9
1
7
1
.
5

2
0
+
E
1
2
6
4
8
6
0
6
4
7
.
5

2
0
+
E
4
5
7
4
6
7
7
8
7
3
.
2

0
0
+
E
9
0
2
8
8
2
2
7
6
9
.
7

1
0
+
E
4
8
5
2
1
9
7
0
3
4
.
1

1
0
+
E
1
0
0
1
2
3
2
1
1
0
.
8

)
3
,
3
,
1
,
0
(
d

)
0
,
4
,
1
,
0
(
d

)
1
,
4
,
1
,
0
(
d

)
2
,
4
,
1
,
0
(
d

)
3
,
4
,
1
,
0
(
d

)
0
,
5
,
1
,
0
(
d

)
1
,
5
,
1
,
0
(
d

)
2
,
5
,
1
,
0
(
d

)
3
,
5
,
1
,
0
(
d

)
0
,
0
,
1
 

)
1
,
0
,
1
 

)
2
,
0
,
1
 

)
3
,
0
,
1
 

)
0
,
1
,
1
 

)
1
,
1
,
1
 

)
2
,
1
,
1
 

)
3
,
1
,
1
 

)
0
,
2
,
1
 

)
1
,
2
,
1
 

)
2
,
2
,
1
 

)
3
,
2
,
1
 

)
0
,
3
,
1
 

)
1
,
3
,
1
 

)
2
,
3
,
1
 

)
3
,
3
,
1
 

)
0
,
4
,
1
 

)
1
,
4
,
1
 

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

,
1
(
d

3
0
+
E
9
7
6
3
8
0
8
3
3
0
.
3

4
0
+
E
0
7
1
7
3
5
9
2
3
7
.
3
 

4
0
+
E
6
7
6
4
1
3
4
3
4
4
.
4
 

4
0
+
E
6
0
2
8
6
3
5
6
0
2
.
4
 

4
0
+
E
3
9
8
0
1
4
5
1
6
4
.
1
 

4
0
+
E
2
8
8
3
7
1
9
9
3
2
.
5
 

4
0
+
E
0
8
9
3
1
6
0
9
7
8
.
5
 

4
0
+
E
8
7
6
4
3
2
1
4
5
0
.
4
 

4
0
+
E
0
2
0
4
6
8
5
0
7
0
.
2
 

4
0
+
E
6
2
1
1
4
1
4
4
2
6
.
4
 

4
0
+
E
0
2
9
8
4
8
5
3
0
0
.
5
 

4
0
+
E
4
3
0
0
7
5
7
8
5
7
.
2
 

4
0
+
E
9
2
5
7
9
3
4
6
9
7
.
1
 

4
0
+
E
1
1
3
9
0
8
7
3
1
2
.
2

4
0
+
E
4
6
3
0
7
6
7
1
4
5
.
1
 

4
0
+
E
0
3
7
9
1
8
8
3
3
0
.
1
 

4
0
+
E
2
6
5
6
8
7
4
1
9
8
.
2
 

4
0
+
E
8
8
8
2
6
9
6
9
4
7
.
4

3
0
+
E
7
0
6
6
4
1
2
8
6
7
.
2

4
0
+
E
1
3
3
2
3
1
0
8
9
7
.
2
 

4
0
+
E
1
2
8
1
5
5
4
9
2
4
.
1

4
0
+
E
5
5
2
0
3
7
6
1
9
2
.
5
 

4
0
+
E
1
0
1
3
2
5
5
8
2
2
.
3
 

4
0
+
E
1
9
6
2
6
2
8
1
1
2
.
7
 

4
0
+
E
5
7
2
1
2
3
5
0
6
5
.
3
 

4
0
+
E
8
3
2
1
5
2
6
8
6
0
.
4

4
0
+
E
4
8
6
6
9
6
1
6
4
9
.
2
 

)
0
,
3
,
0
,
0
(
d

)
1
,
3
,
0
,
0
(
d

)
2
,
3
,
0
,
0
(
d

)
3
,
3
,
0
,
0
(
d

)
0
,
4
,
0
,
0
(
d

)
1
,
4
,
0
,
0
(
d

)
2
,
4
,
0
,
0
(
d

)
3
,
4
,
0
,
0
(
d

)
0
,
5
,
0
,
0
(
d

)
1
,
5
,
0
,
0
(
d

)
2
,
5
,
0
,
0
(
d

)
3
,
5
,
0
,
0
(
d

)
0
,
0
,
1
,
0
(
d

)
1
,
0
,
1
,
0
(
d

)
2
,
0
,
1
,
0
(
d

)
3
,
0
,
1
,
0
(
d

)
0
,
1
,
1
,
0
(
d

)
1
,
1
,
1
,
0
(
d

)
2
,
1
,
1
,
0
(
d

)
3
,
1
,
1
,
0
(
d

)
0
,
2
,
1
,
0
(
d

)
1
,
2
,
1
,
0
(
d

)
2
,
2
,
1
,
0
(
d

)
3
,
2
,
1
,
0
(
d

)
0
,
3
,
1
,
0
(
d

)
1
,
3
,
1
,
0
(
d

)
2
,
3
,
1
,
0
(
d

ApêndiceB

Tabelas de Coeﬁcientes da
Parametrização do Modelo com Intrusão
de Alta Velocidade

84

Tabelas de Coeﬁcientes da Parametrização do Modelo com Intrusão de Alta Velocidade 85

.
e
t
r
a
p

a
1

,
1
P
,
3

M

,
e
d
a
d
i
c
o
l
e
v

a
t
l
a

e
d

o
ã
s
u
r
t
n

i

a
d

o
l
e
d
o
m
o
d

o
ã
ç
a
z
i
r
t
e
m
a
r
a
p

a
n

s
o
d
a
z
i
l
i
t
u

s
e
t
n
e
i
c
ﬁ
e
o
C

:
1
.
B
a
l
e
b
a
T

r
o
l
a
v

)
2
k
,
1
k
,
2
j
,
1
j
(
d

r
o
l
a
v

)
2
k
,
1
k
,
2
j
,
1
j
(
d

r
o
l
a
v

)
2
k
,
1
k
,
2
j
,
1
j
(
d

r
o
l
a
v

)
2
k
,
1
k
,
2
j
,
1
j
(
d

o
v
l
A
o
l
e
d
o
M

1
.
B

4
0
+
E
1
5
3
7
1
0
0
4
2
9
.
4

3
0
+
E
0
7
3
4
2
5
7
8
8
8
.
3
 

4
0
+
E
3
2
8
2
0
6
2
3
8
6
.
1

4
0
+
E
1
1
1
7
0
0
5
1
7
8
.
3
 

4
0
+
E
3
3
3
2
0
1
2
1
6
6
.
2

3
0
+
E
1
5
1
2
0
3
6
0
7
6
.
7

4
0
+
E
9
2
2
4
4
1
1
6
8
7
.
2

4
0
+
E
0
4
0
9
4
9
9
0
5
1
.
2

4
0
+
E
6
0
3
0
2
0
1
5
7
9
.
2
 

1
0
+
E
8
2
8
2
9
4
3
3
4
3
.
4

4
0
+
E
7
7
2
6
0
7
8
3
9
7
.
1

4
0
+
E
8
3
0
0
5
0
5
1
6
2
.
1
 

4
0
+
E
6
3
9
5
7
7
1
8
2
2
.
3

4
0
+
E
4
9
8
8
1
9
2
5
2
4
.
2
 

3
0
+
E
7
0
9
7
3
8
8
3
5
4
.
8
 

3
0
+
E
3
4
6
7
9
8
1
0
3
1
.
3
 

4
0
+
E
2
6
8
5
7
3
9
6
5
2
.
2

4
0
+
E
8
4
0
4
0
7
3
0
3
6
.
4

4
0
+
E
6
5
5
2
1
1
0
5
7
0
.
2
 

3
0
+
E
4
2
3
3
3
3
6
8
0
2
.
1

4
0
+
E
1
0
5
6
5
3
6
6
8
6
.
3

4
0
+
E
0
7
8
2
0
9
5
3
2
2
.
1

4
0
+
E
1
9
7
8
0
2
7
8
4
8
.
3

)
4
,
4
,
1
,
0
(
d

)
0
,
5
,
1
,
0
(
d

)
1
,
5
,
1
,
0
(
d

)
2
,
5
,
1
,
0
(
d

)
3
,
5
,
1
,
0
(
d

)
4
,
5
,
1
,
0
(
d

)
0
,
6
,
1
,
0
(
d

)
1
,
6
,
1
,
0
(
d

)
2
,
6
,
1
,
0
(
d

)
3
,
6
,
1
,
0
(
d

)
4
,
6
,
1
,
0
(
d

)
0
,
7
,
1
,
0
(
d

)
1
,
7
,
1
,
0
(
d

)
2
,
7
,
1
,
0
(
d

)
3
,
7
,
1
,
0
(
d

)
4
,
7
,
1
,
0
(
d

)
0
,
8
,
1
,
0
(
d

)
1
,
8
,
1
,
0
(
d

)
2
,
8
,
1
,
0
(
d

)
3
,
8
,
1
,
0
(
d

)
4
,
8
,
1
,
0
(
d

)
0
,
0
,
0
,
1
(
d

)
1
,
0
,
0
,
1
(
d

4
0
+
E
4
6
7
7
9
8
8
9
6
0
.
3
 

3
0
+
E
7
1
3
7
9
8
1
1
0
8
.
6
 

4
0
+
E
8
3
3
7
4
5
9
7
1
3
.
6

4
0
+
E
4
0
2
4
6
9
8
5
8
8
.
4

4
0
+
E
0
3
4
2
9
6
5
2
9
2
.
3
 

4
0
+
E
0
2
7
4
6
2
4
8
2
5
.
2

4
0
+
E
4
7
4
0
8
0
2
1
1
8
.
6
 

4
0
+
E
1
8
8
5
3
4
9
2
8
8
.
5

3
0
+
E
0
4
3
6
3
5
5
3
2
5
.
3

4
0
+
E
7
3
1
7
1
7
6
5
6
1
.
7

4
0
+
E
6
6
4
5
5
1
2
2
7
5
.
2

4
0
+
E
6
1
7
9
7
1
0
3
3
5
.
9
 

4
0
+
E
5
9
3
7
8
1
5
7
9
0
.
8

3
0
+
E
6
2
2
0
8
2
0
9
0
9
.
2

4
0
+
E
4
0
2
7
3
7
8
3
4
8
.
6

4
0
+
E
1
9
8
6
4
3
8
1
8
1
.
3

4
0
+
E
1
6
3
6
1
8
3
4
6
0
.
8
 

4
0
+
E
9
5
8
4
7
8
3
7
4
4
.
3

4
0
+
E
3
9
7
6
1
0
0
8
2
0
.
4

4
0
+
E
8
0
4
0
6
7
8
7
3
7
.
4

4
0
+
E
9
4
5
1
8
7
4
8
0
1
.
5
 

3
0
+
E
4
3
2
4
1
6
8
9
3
0
.
5
 

4
0
+
E
3
8
1
2
0
7
3
9
6
9
.
1

)
1
,
0
,
1
,
0
(
d

)
2
,
0
,
1
,
0
(
d

)
3
,
0
,
1
,
0
(
d

)
4
,
0
,
1
,
0
(
d

)
0
,
1
,
1
,
0
(
d

)
1
,
1
,
1
,
0
(
d

)
2
,
1
,
1
,
0
(
d

)
3
,
1
,
1
,
0
(
d

)
4
,
1
,
1
,
0
(
d

)
0
,
2
,
1
,
0
(
d

)
1
,
2
,
1
,
0
(
d

)
2
,
2
,
1
,
0
(
d

)
3
,
2
,
1
,
0
(
d

)
4
,
2
,
1
,
0
(
d

)
0
,
3
,
1
,
0
(
d

)
1
,
3
,
1
,
0
(
d

)
2
,
3
,
1
,
0
(
d

)
3
,
3
,
1
,
0
(
d

)
4
,
3
,
1
,
0
(
d

)
0
,
4
,
1
,
0
(
d

)
1
,
4
,
1
,
0
(
d

)
2
,
4
,
1
,
0
(
d

)
3
,
4
,
1
,
0
(
d

4
0
+
E
7
6
6
0
3
1
0
9
4
4
.
7

3
0
+
E
4
9
4
8
5
7
4
4
5
9
.
9

4
0
+
E
4
5
5
4
6
3
8
8
9
6
.
2

4
0
+
E
2
9
6
2
9
7
8
6
8
7
.
1
 

4
0
+
E
3
6
4
8
6
0
1
5
4
5
.
3

4
0
+
E
7
1
7
8
4
7
2
9
6
4
.
5

3
0
+
E
4
0
6
4
5
3
1
9
5
2
.
7
 

4
0
+
E
3
1
5
7
4
4
9
6
1
2
.
1
 

4
0
+
E
0
6
7
6
8
6
1
6
7
2
.
1

3
0
+
E
1
8
3
5
7
1
8
2
7
4
.
8

4
0
+
E
9
6
0
5
8
1
8
5
8
6
.
1

4
0
+
E
3
9
0
8
9
4
2
9
9
7
.
2
 

3
0
+
E
3
1
6
4
0
9
4
6
5
6
.
1
 

4
0
+
E
4
8
6
2
9
6
4
2
5
2
.
1

3
0
+
E
3
8
7
0
3
9
8
5
1
3
.
6

3
0
+
E
3
8
0
1
8
4
2
6
1
3
.
2

3
0
+
E
3
8
5
5
6
6
1
5
2
9
.
6

4
0
+
E
3
8
3
7
1
4
4
1
5
7
.
2
 

4
0
+
E
2
4
0
5
2
4
8
3
5
1
.
2

4
0
+
E
5
7
6
2
1
1
8
5
2
2
.
2

4
0
+
E
6
2
4
0
9
1
8
5
5
0
.
1

4
0
+
E
5
5
6
8
5
9
1
7
1
4
.
2

4
0
+
E
4
0
8
1
4
5
2
4
4
0
.
1
 

)
3
,
4
,
0
,
0
(
d

)
4
,
4
,
0
,
0
(
d

)
0
,
5
,
0
,
0
(
d

)
1
,
5
,
0
,
0
(
d

)
2
,
5
,
0
,
0
(
d

)
3
,
5
,
0
,
0
(
d

)
4
,
5
,
0
,
0
(
d

)
0
,
6
,
0
,
0
(
d

)
1
,
6
,
0
,
0
(
d

)
2
,
6
,
0
,
0
(
d

)
3
,
6
,
0
,
0
(
d

)
4
,
6
,
0
,
0
(
d

)
0
,
7
,
0
,
0
(
d

)
1
,
7
,
0
,
0
(
d

)
2
,
7
,
0
,
0
(
d

)
3
,
7
,
0
,
0
(
d

)
4
,
7
,
0
,
0
(
d

)
0
,
8
,
0
,
0
(
d

)
1
,
8
,
0
,
0
(
d

)
2
,
8
,
0
,
0
(
d

)
3
,
8
,
0
,
0
(
d

)
4
,
8
,
0
,
0
(
d

)
0
,
0
,
1
,
0
(
d

4
0
+
E
1
6
9
0
2
9
1
0
8
5
.
1

4
0
+
E
2
3
9
6
4
5
4
8
3
8
.
4

4
0
+
E
0
0
3
1
7
9
8
6
8
4
.
7

4
0
+
E
3
1
1
2
4
1
2
3
5
3
.
7

4
0
+
E
4
8
8
8
8
8
8
0
6
7
.
3

4
0
+
E
6
0
2
0
5
8
2
4
9
5
.
2

4
0
+
E
9
0
8
7
0
5
7
9
4
4
.
8

5
0
+
E
8
4
6
4
0
9
3
0
0
2
.
1

5
0
+
E
1
7
6
1
0
3
8
7
8
0
.
1

4
0
+
E
6
7
7
1
6
8
0
0
6
4
.
4

4
0
+
E
2
8
8
9
5
4
8
1
8
7
.
2

5
0
+
E
4
3
9
7
5
6
3
3
3
1
.
1

5
0
+
E
2
5
1
4
6
8
9
8
2
6
.
1

5
0
+
E
3
9
8
6
2
1
4
8
5
5
.
1

4
0
+
E
8
2
7
6
7
1
7
0
9
1
.
6

3
0
+
E
0
8
2
3
1
5
5
5
2
2
.
5

4
0
+
E
6
4
7
8
9
6
8
2
9
8
.
7

5
0
+
E
5
1
6
2
7
4
0
1
0
1
.
1

5
0
+
E
7
4
7
3
3
8
5
0
4
1
.
1

4
0
+
E
1
6
4
7
1
0
5
2
0
2
.
3

4
0
+
E
9
7
2
3
2
1
3
2
7
5
.
3

4
0
+
E
5
7
4
8
8
3
5
1
0
7
.
1
 

4
0
+
E
1
2
7
2
9
3
7
2
6
1
.
5

)
0
,
0
,
0
,
0
(
d

)
1
,
0
,
0
,
0
(
d

)
2
,
0
,
0
,
0
(
d

)
3
,
0
,
0
,
0
(
d

)
4
,
0
,
0
,
0
(
d

)
0
,
1
,
0
,
0
(
d

)
1
,
1
,
0
,
0
(
d

)
2
,
1
,
0
,
0
(
d

)
3
,
1
,
0
,
0
(
d

)
4
,
1
,
0
,
0
(
d

)
0
,
2
,
0
,
0
(
d

)
1
,
2
,
0
,
0
(
d

)
2
,
2
,
0
,
0
(
d

)
3
,
2
,
0
,
0
(
d

)
4
,
2
,
0
,
0
(
d

)
0
,
3
,
0
,
0
(
d

)
1
,
3
,
0
,
0
(
d

)
2
,
3
,
0
,
0
(
d

)
3
,
3
,
0
,
0
(
d

)
4
,
3
,
0
,
0
(
d

)
0
,
4
,
0
,
0
(
d

)
1
,
4
,
0
,
0
(
d

)
2
,
4
,
0
,
0
(
d

Tabelas de Coeﬁcientes da Parametrização do Modelo com Intrusão de Alta Velocidade 86

.
e
t
r
a
p

a
2

,
1
P
,
3

M

,
e
d
a
d
i
c
o
l
e
v

a
t
l
a

e
d

o
ã
s
u
r
t
n

i

a
d

o
l
e
d
o
m
o
d

o
ã
ç
a
z
i
r
t
e
m
a
r
a
p

a
n

s
o
d
a
z
i
l
i
t
u

s
e
t
n
e
i
c
ﬁ
e
o
C

:
2
.
B
a
l
e
b
a
T

r
o
l
a
v

)
2
k
,
1
k
,
2
j
,
1
j
(
d

r
o
l
a
v

)
2
k
,
1
k
,
2
j
,
1
j
(
d

r
o
l
a
v

)
2
k
,
1
k
,
2
j
,
1
j
(
d

r
o
l
a
v

)
2
k
,
1
k
,
2
j
,
1
j
(
d

4
0
+
E
6
2
8
8
2
9
4
2
8
6
.
4

4
0
+
E
4
9
0
0
2
5
1
1
0
5
.
2

4
0
+
E
0
8
8
2
7
2
7
3
7
6
.
3
 

4
0
+
E
4
9
4
5
3
6
9
4
5
7
.
4

4
0
+
E
3
3
3
8
7
2
5
4
5
1
.
3
 

2
0
+
E
4
5
7
6
9
4
8
7
4
8
.
3

4
0
+
E
5
4
4
0
9
2
8
8
9
3
.
4

3
0
+
E
3
2
5
8
7
2
1
8
9
2
.
4
 

3
0
+
E
1
7
6
4
5
0
3
7
2
1
.
7
 

4
0
+
E
2
2
2
9
5
4
5
4
6
0
.
1
 

4
0
+
E
2
4
3
1
0
5
9
3
7
8
.
5
 

4
0
+
E
0
8
6
9
0
7
0
1
4
6
.
7

3
0
+
E
6
7
2
8
5
2
2
2
9
6
.
2
 

4
0
+
E
1
7
5
3
9
2
3
1
6
0
.
2
 

4
0
+
E
0
0
2
5
8
5
2
1
8
1
.
2

4
0
+
E
6
0
2
0
3
7
2
1
3
2
.
1
 

4
0
+
E
0
0
2
4
4
8
7
8
0
0
.
4
 

4
0
+
E
7
6
4
5
2
4
2
0
8
2
.
2

2
0
+
E
4
2
2
9
7
0
8
6
4
3
.
7

4
0
+
E
4
2
5
4
1
1
0
1
4
6
.
2

4
0
+
E
1
5
7
4
9
4
6
7
0
1
.
1
 

4
0
+
E
2
0
7
7
5
6
6
0
2
8
.
2
 

)
3
,
4
,
1
,
1
(
d

)
4
,
4
,
1
,
1
(
d

)
0
,
5
,
1
,
1
(
d

)
1
,
5
,
1
,
1
(
d

)
2
,
5
,
1
,
1
(
d

)
3
,
5
,
1
,
1
(
d

)
4
,
5
,
1
,
1
(
d

)
0
,
6
,
1
,
1
(
d

)
1
,
6
,
1
,
1
(
d

)
2
,
6
,
1
,
1
(
d

)
3
,
6
,
1
,
1
(
d

)
4
,
6
,
1
,
1
(
d

)
0
,
7
,
1
,
1
(
d

)
1
,
7
,
1
,
1
(
d

)
2
,
7
,
1
,
1
(
d

)
3
,
7
,
1
,
1
(
d

)
4
,
7
,
1
,
1
(
d

)
0
,
8
,
1
,
1
(
d

)
1
,
8
,
1
,
1
(
d

)
2
,
8
,
1
,
1
(
d

)
3
,
8
,
1
,
1
(
d

)
4
,
8
,
1
,
1
(
d

4
0
+
E
6
1
5
3
7
4
9
6
1
5
.
1

4
0
+
E
1
9
5
4
3
7
1
4
6
7
.
2
 

4
0
+
E
7
4
5
3
5
5
5
9
3
2
.
3

4
0
+
E
7
0
4
6
7
8
5
9
4
2
.
1

4
0
+
E
9
2
7
8
3
5
9
9
8
4
.
5

4
0
+
E
8
5
8
7
9
5
8
7
0
6
.
2
 

3
0
+
E
8
2
1
2
6
0
9
8
9
2
.
8

4
0
+
E
9
0
1
2
5
1
1
0
3
7
.
4
 

3
0
+
E
1
8
3
6
2
3
0
7
4
8
.
2

4
0
+
E
6
4
6
1
9
5
7
3
2
1
.
3
 

3
0
+
E
5
7
4
2
0
8
7
9
3
1
.
3

4
0
+
E
5
3
8
1
6
3
3
8
1
9
.
1
 

4
0
+
E
8
0
8
6
9
9
9
8
8
4
.
4

3
0
+
E
7
2
1
3
8
3
7
6
7
9
.
7

4
0
+
E
1
2
3
9
4
0
5
7
8
3
.
3
 

3
0
+
E
2
4
3
3
1
0
2
5
6
4
.
1

4
0
+
E
9
5
5
9
1
0
6
4
4
5
.
3

4
0
+
E
8
0
7
6
4
0
0
0
2
7
.
1
 

4
0
+
E
5
3
0
7
8
2
2
5
3
6
.
1

3
0
+
E
8
2
2
3
4
9
5
4
2
4
.
8

4
0
+
E
4
8
6
0
6
1
8
5
6
0
.
1
 

4
0
+
E
9
9
1
8
4
1
0
6
7
9
.
3
 

)
1
,
0
,
1
,
1
(
d

)
2
,
0
,
1
,
1
(
d

)
3
,
0
,
1
,
1
(
d

)
4
,
0
,
1
,
1
(
d

)
0
,
1
,
1
,
1
(
d

)
1
,
1
,
1
,
1
(
d

)
2
,
1
,
1
,
1
(
d

)
3
,
1
,
1
,
1
(
d

)
4
,
1
,
1
,
1
(
d

)
0
,
2
,
1
,
1
(
d

)
1
,
2
,
1
,
1
(
d

)
2
,
2
,
1
,
1
(
d

)
3
,
2
,
1
,
1
(
d

)
4
,
2
,
1
,
1
(
d

)
0
,
3
,
1
,
1
(
d

)
1
,
3
,
1
,
1
(
d

)
2
,
3
,
1
,
1
(
d

)
3
,
3
,
1
,
1
(
d

)
4
,
3
,
1
,
1
(
d

)
0
,
4
,
1
,
1
(
d

)
1
,
4
,
1
,
1
(
d

)
2
,
4
,
1
,
1
(
d

4
0
+
E
0
6
8
8
6
6
1
6
2
9
.
2

4
0
+
E
6
8
3
3
0
1
6
8
5
2
.
1

4
0
+
E
9
5
6
7
4
9
8
3
8
2
.
3

4
0
+
E
0
8
5
5
9
3
1
6
8
6
.
3

4
0
+
E
3
1
1
7
0
4
6
3
9
3
.
2

3
0
+
E
0
8
4
5
0
2
2
5
7
6
.
6
 

4
0
+
E
7
0
1
2
9
6
6
0
1
0
.
1
 

3
0
+
E
0
4
0
9
7
1
6
8
1
7
.
5
 

3
0
+
E
3
8
1
1
8
8
7
6
8
4
.
9
 

3
0
+
E
9
3
5
2
1
1
6
2
0
5
.
1
 

3
0
+
E
0
7
6
8
7
4
6
8
2
1
.
9

3
0
+
E
1
9
8
3
3
5
6
2
8
3
.
9

3
0
+
E
7
4
6
3
4
1
1
5
7
8
.
2

4
0
+
E
7
6
2
6
9
8
5
7
5
2
.
1
 

4
0
+
E
5
7
8
9
6
2
9
5
8
2
.
1
 

4
0
+
E
1
1
8
6
9
8
9
1
1
4
.
5
 

4
0
+
E
3
9
3
4
6
4
5
8
8
9
.
2
 

3
0
+
E
0
1
8
6
2
6
2
1
5
7
.
6

3
0
+
E
4
3
1
1
9
7
2
0
3
1
.
8

4
0
+
E
1
2
0
5
2
9
0
1
1
4
.
2

4
0
+
E
9
7
2
6
8
5
6
7
3
8
.
2
 

4
0
+
E
2
2
2
1
6
9
5
5
8
3
.
2

)
4
,
4
,
0
,
1
(
d

)
0
,
5
,
0
,
1
(
d

)
1
,
5
,
0
,
1
(
d

)
2
,
5
,
0
,
1
(
d

)
3
,
5
,
0
,
1
(
d

)
4
,
5
,
0
,
1
(
d

)
0
,
6
,
0
,
1
(
d

)
1
,
6
,
0
,
1
(
d

)
2
,
6
,
0
,
1
(
d

)
3
,
6
,
0
,
1
(
d

)
4
,
6
,
0
,
1
(
d

)
0
,
7
,
0
,
1
(
d

)
1
,
7
,
0
,
1
(
d

)
2
,
7
,
0
,
1
(
d

)
3
,
7
,
0
,
1
(
d

)
4
,
7
,
0
,
1
(
d

)
0
,
8
,
0
,
1
(
d

)
1
,
8
,
0
,
1
(
d

)
2
,
8
,
0
,
1
(
d

)
3
,
8
,
0
,
1
(
d

)
4
,
8
,
0
,
1
(
d

)
0
,
0
,
1
,
1
(
d

4
0
+
E
3
3
0
5
5
1
4
2
7
4
.
5

4
0
+
E
2
1
9
1
2
3
7
8
1
0
.
5

4
0
+
E
5
7
8
1
2
9
7
3
3
0
.
2

4
0
+
E
4
4
9
4
5
0
3
8
1
4
.
2
 

4
0
+
E
3
6
8
9
4
6
4
7
4
5
.
5
 

4
0
+
E
4
6
1
2
4
4
2
9
0
8
.
6
 

4
0
+
E
4
0
1
3
1
3
1
2
0
4
.
4
 

4
0
+
E
1
1
5
8
2
1
6
2
4
7
.
2

4
0
+
E
0
7
3
4
0
2
9
5
0
0
.
1
 

4
0
+
E
2
2
4
2
9
0
3
5
6
9
.
3

4
0
+
E
0
1
5
0
1
3
0
9
5
5
.
5

4
0
+
E
9
5
3
7
6
7
2
3
8
0
.
4

4
0
+
E
6
1
1
3
0
8
2
8
4
2
.
2

3
0
+
E
8
8
6
8
9
0
6
3
3
6
.
4

4
0
+
E
8
0
6
6
8
1
9
4
8
4
.
1

4
0
+
E
1
4
8
6
8
9
1
2
1
2
.
3

4
0
+
E
0
5
5
0
0
3
4
4
0
8
.
3

4
0
+
E
4
0
1
6
7
6
9
4
3
6
.
3

4
0
+
E
5
7
7
0
3
8
0
3
1
0
.
2

2
0
+
E
4
7
8
9
0
7
0
2
5
0
.
4
 

4
0
+
E
2
1
3
9
1
1
2
0
2
7
.
3

4
0
+
E
6
5
8
9
8
2
5
6
1
4
.
5

)
2
,
0
,
0
,
1
(
d

)
3
,
0
,
0
,
1
(
d

)
4
,
0
,
0
,
1
(
d

)
0
,
1
,
0
,
1
(
d

)
1
,
1
,
0
,
1
(
d

)
2
,
1
,
0
,
1
(
d

)
3
,
1
,
0
,
1
(
d

)
4
,
1
,
0
,
1
(
d

)
0
,
2
,
0
,
1
(
d

)
1
,
2
,
0
,
1
(
d

)
2
,
2
,
0
,
1
(
d

)
3
,
2
,
0
,
1
(
d

)
4
,
2
,
0
,
1
(
d

)
0
,
3
,
0
,
1
(
d

)
1
,
3
,
0
,
1
(
d

)
2
,
3
,
0
,
1
(
d

)
3
,
3
,
0
,
1
(
d

)
4
,
3
,
0
,
1
(
d

)
0
,
4
,
0
,
1
(
d

)
1
,
4
,
0
,
1
(
d

)
2
,
4
,
0
,
1
(
d

)
3
,
4
,
0
,
1
(
d

Tabelas de Coeﬁcientes da Parametrização do Modelo com Intrusão de Alta Velocidade 87

a
t
l
a

e
d

o
ã
s
u
r
t
n

i

a
d

o
ã
s
r
e
v
n

i

a
n

o
d
a
z
i
l
i
t
u

,
3
o

M

,
l
a
i
c
i
n

i

o
l
e
d
o
m
o
d

o
ã
ç
a
z
i
r
t
e
m
a
r
a
p

a
n

s
o
d
a
z
i
l
i
t
u

.
e
t
r
a
p

a
1

s
e
t
n
e
i
c
ﬁ
e
o
C

.
e
d
a
d
i
c
o
l
e
v

:
3
.
B

a
l
e
b
a
T

r
o
l
a
v

)
2
k
,
1
k
,
2
j
,
1
j
(
d

r
o
l
a
v

)
2
k
,
1
k
,
2
j
,
1
j
(
d

r
o
l
a
v

)
2
k
,
1
k
,
2
j
,
1
j
(
d

r
o
l
a
v

)
2
k
,
1
k
,
2
j
,
1
j
(
d

4
0
+
E
8
9
7
0
7
1
3
2
6
5
.
4

4
0
+
E
4
1
3
9
0
0
8
0
6
5
.
2
 

4
0
+
E
2
5
8
6
8
3
6
1
7
7
.
2

4
0
+
E
4
8
9
6
4
5
0
3
3
3
.
3
 

3
0
+
E
2
4
8
3
7
8
1
5
7
4
.
4

4
0
+
E
5
5
8
3
0
6
3
3
1
8
.
1

4
0
+
E
4
8
5
2
3
5
7
2
2
2
.
3

4
0
+
E
9
1
8
5
5
0
9
0
7
1
.
1

4
0
+
E
4
8
9
3
8
8
2
0
2
6
.
2
 

3
0
+
E
1
5
4
6
7
2
1
4
6
8
.
5

3
0
+
E
8
4
3
8
2
9
4
6
3
6
.
4

4
0
+
E
5
6
8
1
6
0
6
3
1
0
.
1

3
0
+
E
1
1
0
6
7
9
8
1
1
1
.
9

4
0
+
E
3
7
9
4
3
0
5
7
8
5
.
1
 

3
0
+
E
9
5
1
5
7
2
0
9
3
9
.
2

4
0
+
E
0
3
3
8
1
1
2
1
4
3
.
2
 

4
0
+
E
7
7
9
4
1
3
9
9
9
0
.
2

4
0
+
E
5
4
2
4
4
0
9
4
0
8
.
2

4
0
+
E
0
0
6
7
8
7
5
1
2
1
.
2
 

4
0
+
E
7
5
3
8
4
5
4
2
0
0
.
1

4
0
+
E
2
4
1
7
1
6
5
2
6
1
.
2

4
0
+
E
7
9
9
9
3
0
5
9
7
7
.
2

3
0
+
E
9
3
3
6
2
1
9
7
6
8
.
2
 

)
4
,
4
,
1
,
0
(
d

)
0
,
5
,
1
,
0
(
d

)
1
,
5
,
1
,
0
(
d

)
2
,
5
,
1
,
0
(
d

)
3
,
5
,
1
,
0
(
d

)
4
,
5
,
1
,
0
(
d

)
0
,
6
,
1
,
0
(
d

)
1
,
6
,
1
,
0
(
d

)
2
,
6
,
1
,
0
(
d

)
3
,
6
,
1
,
0
(
d

)
4
,
6
,
1
,
0
(
d

)
0
,
7
,
1
,
0
(
d

)
1
,
7
,
1
,
0
(
d

)
2
,
7
,
1
,
0
(
d

)
3
,
7
,
1
,
0
(
d

)
4
,
7
,
1
,
0
(
d

)
0
,
8
,
1
,
0
(
d

)
1
,
8
,
1
,
0
(
d

)
2
,
8
,
1
,
0
(
d

)
3
,
8
,
1
,
0
(
d

)
4
,
8
,
1
,
0
(
d

)
0
,
0
,
0
,
1
(
d

)
1
,
0
,
0
,
1
(
d

4
0
+
E
7
6
0
4
1
8
0
8
6
6
.
1
 

4
0
+
E
4
9
2
2
3
4
6
5
7
8
.
4
 

4
0
+
E
6
1
4
2
0
4
7
3
9
0
.
4

4
0
+
E
3
4
0
2
8
5
8
8
3
0
.
5

4
0
+
E
4
1
4
4
2
6
2
0
2
0
.
7
 

3
0
+
E
3
5
1
6
6
2
4
2
3
5
.
2

4
0
+
E
4
5
8
6
6
7
4
2
9
7
.
5
 

4
0
+
E
2
0
0
6
4
6
1
4
2
0
.
5

4
0
+
E
5
4
2
2
9
3
7
3
5
2
.
1

4
0
+
E
6
7
5
5
1
7
6
5
2
5
.
6

4
0
+
E
6
9
7
6
3
6
0
1
7
0
.
8
 

3
0
+
E
3
9
0
9
1
9
0
8
3
3
.
4
 

4
0
+
E
7
3
8
1
4
7
2
3
8
3
.
5

4
0
+
E
6
9
2
4
7
6
0
2
6
7
.
9

3
0
+
E
0
9
9
4
7
4
6
9
3
2
.
7
 

4
0
+
E
2
5
4
0
4
2
6
9
1
6
.
6

4
0
+
E
3
4
4
9
3
2
1
7
0
9
.
8
 

4
0
+
E
6
8
9
3
7
6
1
2
7
4
.
5

4
0
+
E
8
5
2
9
8
7
4
7
3
1
.
7

4
0
+
E
2
7
8
0
3
4
6
9
5
8
.
3

3
0
+
E
3
9
0
4
2
5
0
1
0
0
.
4

4
0
+
E
5
3
1
3
9
6
4
4
4
7
.
4
 

4
0
+
E
2
4
4
9
0
2
7
2
2
0
.
1
 

)
1
,
0
,
1
,
0
(
d

)
2
,
0
,
1
,
0
(
d

)
3
,
0
,
1
,
0
(
d

)
4
,
0
,
1
,
0
(
d

)
0
,
1
,
1
,
0
(
d

)
1
,
1
,
1
,
0
(
d

)
2
,
1
,
1
,
0
(
d

)
3
,
1
,
1
,
0
(
d

)
4
,
1
,
1
,
0
(
d

)
0
,
2
,
1
,
0
(
d

)
1
,
2
,
1
,
0
(
d

)
2
,
2
,
1
,
0
(
d

)
3
,
2
,
1
,
0
(
d

)
4
,
2
,
1
,
0
(
d

)
0
,
3
,
1
,
0
(
d

)
1
,
3
,
1
,
0
(
d

)
2
,
3
,
1
,
0
(
d

)
3
,
3
,
1
,
0
(
d

)
4
,
3
,
1
,
0
(
d

)
0
,
4
,
1
,
0
(
d

)
1
,
4
,
1
,
0
(
d

)
2
,
4
,
1
,
0
(
d

)
3
,
4
,
1
,
0
(
d

4
0
+
E
8
8
7
5
5
6
2
6
9
2
.
4

3
0
+
E
8
3
0
1
6
8
6
5
3
6
.
8
 

4
0
+
E
5
1
3
3
9
3
2
0
6
8
.
1
 

4
0
+
E
6
7
5
0
9
9
4
8
1
4
.
2

4
0
+
E
1
5
8
2
7
1
0
8
5
3
.
2

4
0
+
E
2
6
1
2
0
1
9
7
5
7
.
3

3
0
+
E
1
9
6
1
8
9
9
9
3
4
.
6
 

4
0
+
E
6
1
9
1
7
5
0
4
7
1
.
1
 

4
0
+
E
3
5
8
1
6
1
5
8
3
1
.
2

4
0
+
E
6
8
6
1
6
9
9
0
1
3
.
2

4
0
+
E
0
1
3
8
9
7
1
2
7
5
.
3

3
0
+
E
3
7
0
5
8
2
6
7
3
0
.
4

3
0
+
E
3
2
6
5
2
6
0
2
6
6
.
5

3
0
+
E
7
9
7
6
5
6
4
9
4
1
.
7
 

3
0
+
E
3
2
8
6
2
0
9
0
2
2
.
3

3
0
+
E
6
2
4
5
0
0
9
5
5
1
.
2
 

3
0
+
E
1
0
5
4
3
2
0
3
8
8
.
6

3
0
+
E
4
5
4
7
9
2
8
6
7
2
.
9
 

4
0
+
E
7
9
3
2
0
5
3
4
2
6
.
2

4
0
+
E
3
1
1
9
7
6
3
0
6
0
.
3

4
0
+
E
3
6
9
5
2
3
4
5
1
5
.
2

3
0
+
E
0
5
8
9
6
7
0
8
5
9
.
3

3
0
+
E
8
4
7
5
5
2
3
3
7
1
.
3

)
3
,
4
,
0
,
0
(
d

)
4
,
4
,
0
,
0
(
d

)
0
,
5
,
0
,
0
(
d

)
1
,
5
,
0
,
0
(
d

)
2
,
5
,
0
,
0
(
d

)
3
,
5
,
0
,
0
(
d

)
4
,
5
,
0
,
0
(
d

)
0
,
6
,
0
,
0
(
d

)
1
,
6
,
0
,
0
(
d

)
2
,
6
,
0
,
0
(
d

)
3
,
6
,
0
,
0
(
d

)
4
,
6
,
0
,
0
(
d

)
0
,
7
,
0
,
0
(
d

)
1
,
7
,
0
,
0
(
d

)
2
,
7
,
0
,
0
(
d

)
3
,
7
,
0
,
0
(
d

)
4
,
7
,
0
,
0
(
d

)
0
,
8
,
0
,
0
(
d

)
1
,
8
,
0
,
0
(
d

)
2
,
8
,
0
,
0
(
d

)
3
,
8
,
0
,
0
(
d

)
4
,
8
,
0
,
0
(
d

)
0
,
0
,
1
,
0
(
d

3
0
+
E
1
7
0
6
3
0
9
6
2
0
.
3

4
0
+
E
3
5
6
0
6
6
0
8
1
2
.
2

4
0
+
E
1
0
7
6
3
5
9
5
8
2
.
4

4
0
+
E
0
1
0
9
9
0
3
9
1
4
.
5

4
0
+
E
0
5
1
2
1
6
9
8
1
6
.
3

3
0
+
E
4
1
9
3
1
4
5
1
5
5
.
8

4
0
+
E
0
7
5
3
1
8
2
3
3
7
.
6

5
0
+
E
7
4
1
0
5
0
2
8
4
0
.
1

5
0
+
E
2
9
1
8
8
9
8
0
8
0
.
1

4
0
+
E
7
7
3
9
3
4
0
7
3
5
.
5

3
0
+
E
2
9
1
8
0
7
2
5
3
0
.
3

4
0
+
E
1
9
6
9
8
8
3
7
2
3
.
8

5
0
+
E
8
2
2
0
7
7
2
6
6
2
.
1

5
0
+
E
5
2
4
5
5
9
2
3
6
3
.
1

4
0
+
E
4
8
5
0
8
8
9
5
1
1
.
6

3
0
+
E
9
9
7
7
4
6
0
2
2
3
.
1

4
0
+
E
8
9
7
7
3
6
0
2
8
5
.
9

5
0
+
E
6
3
3
2
1
4
8
1
1
3
.
1

5
0
+
E
3
3
0
5
5
3
2
8
1
3
.
1

4
0
+
E
4
2
4
7
0
6
5
2
6
7
.
3

4
0
+
E
6
1
4
5
9
6
7
7
7
5
.
2

4
0
+
E
2
2
7
5
9
9
0
6
8
1
.
2
 

4
0
+
E
4
2
7
7
7
2
6
5
7
5
.
2

)
0
,
0
,
0
,
0
(
d

)
1
,
0
,
0
,
0
(
d

)
2
,
0
,
0
,
0
(
d

)
3
,
0
,
0
,
0
(
d

)
4
,
0
,
0
,
0
(
d

)
0
,
1
,
0
,
0
(
d

)
1
,
1
,
0
,
0
(
d

)
2
,
1
,
0
,
0
(
d

)
3
,
1
,
0
,
0
(
d

)
4
,
1
,
0
,
0
(
d

)
0
,
2
,
0
,
0
(
d

)
1
,
2
,
0
,
0
(
d

)
2
,
2
,
0
,
0
(
d

)
3
,
2
,
0
,
0
(
d

)
4
,
2
,
0
,
0
(
d

)
0
,
3
,
0
,
0
(
d

)
1
,
3
,
0
,
0
(
d

)
2
,
3
,
0
,
0
(
d

)
3
,
3
,
0
,
0
(
d

)
4
,
3
,
0
,
0
(
d

)
0
,
4
,
0
,
0
(
d

)
1
,
4
,
0
,
0
(
d

)
2
,
4
,
0
,
0
(
d

l
a
i
c
i
n
I

o
l
e
d
o
M

2
.
B

Tabelas de Coeﬁcientes da Parametrização do Modelo com Intrusão de Alta Velocidade 88

a
t
l
a

e
d

o
ã
s
u
r
t
n

i

a
d

o
ã
s
r
e
v
n

i

a
n

o
d
a
z
i
l
i
t
u

,
3
o

M

,
l
a
i
c
i
n

i

o
l
e
d
o
m
o
d

o
ã
ç
a
z
i
r
t
e
m
a
r
a
p

a
n

s
o
d
a
z
i
l
i
t
u

.
e
t
r
a
p

a
2

s
e
t
n
e
i
c
ﬁ
e
o
C

.
e
d
a
d
i
c
o
l
e
v

:
4
.
B

a
l
e
b
a
T

r
o
l
a
v

)
2
k
,
1
k
,
2
j
,
1
j
(
d

r
o
l
a
v

)
2
k
,
1
k
,
2
j
,
1
j
(
d

r
o
l
a
v

)
2
k
,
1
k
,
2
j
,
1
j
(
d

r
o
l
a
v

)
2
k
,
1
k
,
2
j
,
1
j
(
d

3
0
+
E
3
8
7
8
4
2
3
6
5
5
.
4

3
0
+
E
2
2
1
3
5
8
3
7
7
7
.
6
 

4
0
+
E
4
5
7
9
0
4
7
5
8
1
.
4

4
0
+
E
8
4
1
9
5
1
8
5
4
9
.
3

4
0
+
E
2
3
5
9
2
7
8
1
7
4
.
4
 

4
0
+
E
2
2
7
0
1
1
4
1
0
1
.
1

3
0
+
E
1
9
8
9
9
2
4
7
1
5
.
7
 

4
0
+
E
9
9
7
5
2
1
9
5
0
3
.
2

3
0
+
E
7
3
0
6
5
8
2
7
9
2
.
9
 

4
0
+
E
2
9
6
4
0
8
4
9
7
9
.
5
 

3
0
+
E
8
6
4
4
6
8
3
5
3
4
.
4
 

4
0
+
E
2
7
0
0
4
4
8
5
1
0
.
1

4
0
+
E
9
8
2
0
0
8
4
2
2
7
.
2

3
0
+
E
3
1
4
1
3
5
0
4
8
5
.
6

4
0
+
E
2
1
1
1
2
5
5
4
3
5
.
2
 

3
0
+
E
2
8
0
6
9
2
7
6
3
6
.
9

4
0
+
E
6
8
1
4
2
1
8
6
0
1
.
6

4
0
+
E
3
9
0
8
5
1
5
9
4
1
.
7
 

4
0
+
E
0
1
9
1
0
1
8
4
6
4
.
4

4
0
+
E
8
0
5
3
3
8
7
1
0
5
.
2
 

4
0
+
E
2
2
7
4
4
5
2
8
9
6
.
1
 

4
0
+
E
1
4
3
0
5
2
1
7
1
5
.
4
 

)
3
,
4
,
1
,
1
(
d

)
4
,
4
,
1
,
1
(
d

)
0
,
5
,
1
,
1
(
d

)
1
,
5
,
1
,
1
(
d

)
2
,
5
,
1
,
1
(
d

)
3
,
5
,
1
,
1
(
d

)
4
,
5
,
1
,
1
(
d

)
0
,
6
,
1
,
1
(
d

)
1
,
6
,
1
,
1
(
d

)
2
,
6
,
1
,
1
(
d

)
3
,
6
,
1
,
1
(
d

)
4
,
6
,
1
,
1
(
d

)
0
,
7
,
1
,
1
(
d

)
1
,
7
,
1
,
1
(
d

)
2
,
7
,
1
,
1
(
d

)
3
,
7
,
1
,
1
(
d

)
4
,
7
,
1
,
1
(
d

)
0
,
8
,
1
,
1
(
d

)
1
,
8
,
1
,
1
(
d

)
2
,
8
,
1
,
1
(
d

)
3
,
8
,
1
,
1
(
d

)
4
,
8
,
1
,
1
(
d

4
0
+
E
3
9
7
2
1
4
1
8
0
5
.
5

4
0
+
E
7
8
3
7
6
5
0
9
8
2
.
3
 

4
0
+
E
5
0
5
1
7
6
1
4
9
7
.
9

4
0
+
E
1
7
7
1
3
1
0
1
4
4
.
1
 

4
0
+
E
6
7
2
8
8
1
0
1
2
9
.
3

4
0
+
E
6
3
4
5
5
5
0
9
1
6
.
2
 

2
0
+
E
7
2
5
3
5
7
5
0
2
5
.
9

4
0
+
E
3
0
2
3
5
3
1
8
2
5
.
2
 

4
0
+
E
1
7
6
4
9
5
5
7
4
2
.
2
 

4
0
+
E
8
4
0
7
8
5
5
7
4
1
.
2

4
0
+
E
8
3
2
2
4
7
8
4
7
6
.
1
 

2
0
+
E
3
9
3
7
8
1
9
7
0
9
.
5
 

2
0
+
E
8
1
1
0
0
9
5
7
3
3
.
4
 

4
0
+
E
0
2
7
8
8
3
6
2
2
8
.
5

4
0
+
E
1
3
5
5
9
3
4
7
6
4
.
3

4
0
+
E
7
4
2
7
7
8
8
9
2
4
.
4

4
0
+
E
5
5
5
9
1
0
4
2
0
6
.
2
 

4
0
+
E
2
0
3
8
3
3
9
1
6
8
.
1

4
0
+
E
4
0
7
1
9
9
8
4
6
9
.
2

4
0
+
E
5
2
6
6
9
6
2
6
6
7
.
1

3
0
+
E
9
3
2
0
2
0
3
2
1
6
.
3
 

4
0
+
E
9
0
6
4
6
4
7
0
5
1
.
4
 

)
1
,
0
,
1
,
1
(
d

)
2
,
0
,
1
,
1
(
d

)
3
,
0
,
1
,
1
(
d

)
4
,
0
,
1
,
1
(
d

)
0
,
1
,
1
,
1
(
d

)
1
,
1
,
1
,
1
(
d

)
2
,
1
,
1
,
1
(
d

)
3
,
1
,
1
,
1
(
d

)
4
,
1
,
1
,
1
(
d

)
0
,
2
,
1
,
1
(
d

)
1
,
2
,
1
,
1
(
d

)
2
,
2
,
1
,
1
(
d

)
3
,
2
,
1
,
1
(
d

)
4
,
2
,
1
,
1
(
d

)
0
,
3
,
1
,
1
(
d

)
1
,
3
,
1
,
1
(
d

)
2
,
3
,
1
,
1
(
d

)
3
,
3
,
1
,
1
(
d

)
4
,
3
,
1
,
1
(
d

)
0
,
4
,
1
,
1
(
d

)
1
,
4
,
1
,
1
(
d

)
2
,
4
,
1
,
1
(
d

4
0
+
E
0
8
6
2
4
0
6
1
2
7
.
2

4
0
+
E
4
6
8
2
3
9
8
9
9
0
.
3

4
0
+
E
1
2
4
0
6
3
4
8
1
0
.
1
 

4
0
+
E
8
0
3
0
6
0
2
7
9
7
.
2

4
0
+
E
4
0
3
9
2
2
2
2
0
2
.
3

4
0
+
E
7
4
2
4
0
5
2
9
2
8
.
1
 

4
0
+
E
5
6
5
2
6
6
7
4
7
6
.
3
 

4
0
+
E
4
2
1
6
9
2
6
7
2
8
.
1
 

4
0
+
E
9
9
4
5
3
2
1
5
4
0
.
2

4
0
+
E
5
0
4
7
4
1
8
2
3
0
.
4

4
0
+
E
0
9
8
2
5
3
1
8
1
5
.
5

4
0
+
E
6
2
2
7
8
1
2
3
3
5
.
2

4
0
+
E
3
1
0
0
1
8
1
9
3
5
.
2
 

4
0
+
E
7
8
3
2
7
1
4
9
0
8
.
2

4
0
+
E
6
3
5
2
4
6
4
9
5
3
.
3
 

4
0
+
E
7
3
5
1
2
7
3
5
1
3
.
7
 

4
0
+
E
0
1
3
9
4
8
7
6
6
7
.
4
 

4
0
+
E
1
9
2
8
3
5
7
6
4
4
.
9
 

4
0
+
E
0
5
1
0
0
8
5
0
2
0
.
8

4
0
+
E
1
1
0
3
0
0
3
9
4
9
.
8

4
0
+
E
6
9
7
4
4
8
0
9
5
4
.
8
 

4
0
+
E
7
1
5
3
5
1
9
4
9
2
.
4

)
4
,
4
,
0
,
1
(
d

)
0
,
5
,
0
,
1
(
d

)
1
,
5
,
0
,
1
(
d

)
2
,
5
,
0
,
1
(
d

)
3
,
5
,
0
,
1
(
d

)
4
,
5
,
0
,
1
(
d

)
0
,
6
,
0
,
1
(
d

)
1
,
6
,
0
,
1
(
d

)
2
,
6
,
0
,
1
(
d

)
3
,
6
,
0
,
1
(
d

)
4
,
6
,
0
,
1
(
d

)
0
,
7
,
0
,
1
(
d

)
1
,
7
,
0
,
1
(
d

)
2
,
7
,
0
,
1
(
d

)
3
,
7
,
0
,
1
(
d

)
4
,
7
,
0
,
1
(
d

)
0
,
8
,
0
,
1
(
d

)
1
,
8
,
0
,
1
(
d

)
2
,
8
,
0
,
1
(
d

)
3
,
8
,
0
,
1
(
d

)
4
,
8
,
0
,
1
(
d

)
0
,
0
,
1
,
1
(
d

4
0
+
E
6
9
9
3
1
0
7
9
9
6
.
3

4
0
+
E
5
6
6
7
9
5
7
5
0
0
.
3

3
0
+
E
5
3
9
0
4
8
4
1
2
7
.
6

4
0
+
E
8
7
2
2
8
2
4
8
1
4
.
1
 

4
0
+
E
3
4
9
4
6
5
0
0
4
8
.
4
 

4
0
+
E
4
3
6
8
6
4
3
4
6
6
.
7
 

4
0
+
E
9
7
3
2
3
4
9
4
6
3
.
7
 

4
0
+
E
0
7
8
2
3
8
9
1
5
7
.
4
 

3
0
+
E
3
7
3
3
3
5
5
2
8
2
.
1
 

4
0
+
E
6
0
5
0
2
8
6
9
8
5
.
1

4
0
+
E
1
8
2
5
0
1
4
8
1
8
.
3

4
0
+
E
9
4
0
9
9
9
7
7
6
9
.
3

4
0
+
E
8
8
2
2
5
9
2
7
7
9
.
3

4
0
+
E
3
7
1
4
3
8
3
2
1
6
.
2

2
0
+
E
7
4
9
9
0
4
9
6
8
7
.
1
 

4
0
+
E
2
6
6
9
1
3
6
8
4
2
.
3

4
0
+
E
7
3
6
5
8
1
7
2
0
5
.
2

3
0
+
E
7
2
1
7
8
5
9
5
2
9
.
8
 

4
0
+
E
0
9
3
3
0
7
5
5
6
1
.
3
 

4
0
+
E
6
4
9
7
0
0
4
5
6
5
.
1
 

1
0
+
E
4
2
6
9
4
3
6
2
7
1
.
2

4
0
+
E
1
7
7
1
3
5
9
3
9
4
.
2

)
2
,
0
,
0
,
1
(
d

)
3
,
0
,
0
,
1
(
d

)
4
,
0
,
0
,
1
(
d

)
0
,
1
,
0
,
1
(
d

)
1
,
1
,
0
,
1
(
d

)
2
,
1
,
0
,
1
(
d

)
3
,
1
,
0
,
1
(
d

)
4
,
1
,
0
,
1
(
d

)
0
,
2
,
0
,
1
(
d

)
1
,
2
,
0
,
1
(
d

)
2
,
2
,
0
,
1
(
d

)
3
,
2
,
0
,
1
(
d

)
4
,
2
,
0
,
1
(
d

)
0
,
3
,
0
,
1
(
d

)
1
,
3
,
0
,
1
(
d

)
2
,
3
,
0
,
1
(
d

)
3
,
3
,
0
,
1
(
d

)
4
,
3
,
0
,
1
(
d

)
0
,
4
,
0
,
1
(
d

)
1
,
4
,
0
,
1
(
d

)
2
,
4
,
0
,
1
(
d

)
3
,
4
,
0
,
1
(
d

Tabelas de Coeﬁcientes da Parametrização do Modelo com Intrusão de Alta Velocidade 89

.
e
t
r
a
p

a
1

.
o
ã
s
r
e
v
n

i

a
n

s
o
d
i
t
b
o

,
I
,
3

M

,
e
d
a
d

i
c
o
l
e
v

a
t
l
a

e
d

o
ã
s
u
r
t
n

i

o
l
e
d
o
m
o
d

o
ã
ç
a
z
i
r
t
e
m
a
r
a
p

a
d

s
e
t
n
e
i
c
ﬁ
e
o
C

:
5
.
B
a
l
e
b
a
T

r
o
l
a
v

)
2
k
,
1
k
,
2
j
,
1
j
(
d

r
o
l
a
v

)
2
k
,
1
k
,
2
j
,
1
j
(
d

r
o
l
a
v

)
2
k
,
1
k
,
2
j
,
1
j
(
d

r
o
l
a
v

)
2
k
,
1
k
,
2
j
,
1
j
(
d

o
d
i
t
r
e
v
n
I

o
l
e
d
o
M

3
.
B

4
0
+
E
6
7
4
4
3
5
1
8
8
6
.
1
 

4
0
+
E
7
9
9
2
8
1
7
7
8
0
.
2
 

4
0
+
E
7
1
4
2
6
8
9
8
7
9
.
3

3
0
+
E
1
0
4
5
0
8
0
7
7
2
.
3

3
0
+
E
4
5
3
5
3
9
9
6
5
0
.
2

3
0
+
E
1
3
3
0
2
6
0
9
7
5
.
3

4
0
+
E
4
4
8
1
3
3
3
4
5
2
.
2

4
0
+
E
6
5
8
6
7
8
2
3
6
7
.
1
 

3
0
+
E
5
2
0
1
2
8
6
1
8
0
.
1
 

4
0
+
E
0
6
1
7
8
4
4
7
1
0
.
1
 

4
0
+
E
6
1
5
9
7
1
1
3
7
7
.
1
 

3
0
+
E
8
9
6
5
4
7
8
0
0
5
.
2
 

3
0
+
E
8
0
7
2
2
6
5
6
3
2
.
4

3
0
+
E
9
6
3
9
6
8
3
9
3
5
.
4

4
0
+
E
6
8
0
3
3
4
9
7
2
3
.
1

3
0
+
E
4
9
6
5
3
0
5
5
7
0
.
6

4
0
+
E
2
3
0
4
0
9
8
7
5
1
.
2
 

3
0
+
E
0
8
2
0
3
4
7
9
5
9
.
5
 

3
0
+
E
8
5
8
4
8
9
1
7
9
9
.
7
 

4
0
+
E
8
0
7
6
6
0
6
8
0
9
.
3

4
0
+
E
1
4
0
4
5
3
0
8
7
6
.
1

4
0
+
E
1
2
6
7
8
2
9
8
6
5
.
3
 

4
0
+
E
2
0
3
4
3
2
1
2
6
9
.
1
 

)
4
,
4
,
1
,
0
(
d

)
0
,
5
,
1
,
0
(
d

)
1
,
5
,
1
,
0
(
d

)
2
,
5
,
1
,
0
(
d

)
3
,
5
,
1
,
0
(
d

)
4
,
5
,
1
,
0
(
d

)
0
,
6
,
1
,
0
(
d

)
1
,
6
,
1
,
0
(
d

)
2
,
6
,
1
,
0
(
d

)
3
,
6
,
1
,
0
(
d

)
4
,
6
,
1
,
0
(
d

)
0
,
7
,
1
,
0
(
d

)
1
,
7
,
1
,
0
(
d

)
2
,
7
,
1
,
0
(
d

)
3
,
7
,
1
,
0
(
d

)
4
,
7
,
1
,
0
(
d

)
0
,
8
,
1
,
0
(
d

)
1
,
8
,
1
,
0
(
d

)
2
,
8
,
1
,
0
(
d

)
3
,
8
,
1
,
0
(
d

)
4
,
8
,
1
,
0
(
d

)
0
,
0
,
0
,
1
(
d

)
1
,
0
,
0
,
1
(
d

4
0
+
E
1
6
7
9
6
0
6
7
2
9
.
3

3
0
+
E
6
8
2
7
4
1
1
1
5
1
.
6

4
0
+
E
2
2
8
6
4
4
3
8
0
6
.
2

4
0
+
E
1
3
8
6
3
9
0
4
6
1
.
6
 

4
0
+
E
9
2
3
9
8
7
4
7
5
6
.
8

4
0
+
E
4
3
6
1
8
3
9
3
6
9
.
7
 

3
0
+
E
1
6
9
8
6
7
9
0
9
4
.
7
 

4
0
+
E
7
9
0
1
5
6
4
4
7
4
.
6
 

4
0
+
E
1
0
9
3
6
7
6
2
5
0
.
1

5
0
+
E
0
4
9
7
7
2
0
3
1
3
.
1

5
0
+
E
2
4
1
2
8
7
0
6
9
2
.
1
 

4
0
+
E
1
6
0
2
9
2
4
1
6
9
.
3
 

4
0
+
E
5
9
5
1
5
0
9
5
0
7
.
9
 

4
0
+
E
2
3
9
7
6
0
3
6
2
4
.
2
 

5
0
+
E
3
5
7
3
6
4
2
2
2
0
.
1
 

5
0
+
E
5
2
4
0
9
4
2
4
5
1
.
1

4
0
+
E
2
9
6
7
1
6
4
7
4
4
.
3
 

4
0
+
E
6
2
1
3
0
6
4
0
1
5
.
4
 

4
0
+
E
9
2
9
5
1
2
1
9
2
4
.
2
 

4
0
+
E
3
7
6
3
6
5
1
2
8
3
.
7
 

4
0
+
E
0
4
7
5
9
3
1
7
7
3
.
8

4
0
+
E
4
4
8
2
1
6
2
2
5
6
.
2
 

4
0
+
E
9
6
7
7
1
6
2
0
6
0
.
5
 

)
1
,
0
,
1
,
0
(
d

)
2
,
0
,
1
,
0
(
d

)
3
,
0
,
1
,
0
(
d

)
4
,
0
,
1
,
0
(
d

)
0
,
1
,
1
,
0
(
d

)
1
,
1
,
1
,
0
(
d

)
2
,
1
,
1
,
0
(
d

)
3
,
1
,
1
,
0
(
d

)
4
,
1
,
1
,
0
(
d

)
0
,
2
,
1
,
0
(
d

)
1
,
2
,
1
,
0
(
d

)
2
,
2
,
1
,
0
(
d

)
3
,
2
,
1
,
0
(
d

)
4
,
2
,
1
,
0
(
d

)
0
,
3
,
1
,
0
(
d

)
1
,
3
,
1
,
0
(
d

)
2
,
3
,
1
,
0
(
d

)
3
,
3
,
1
,
0
(
d

)
4
,
3
,
1
,
0
(
d

)
0
,
4
,
1
,
0
(
d

)
1
,
4
,
1
,
0
(
d

)
2
,
4
,
1
,
0
(
d

)
3
,
4
,
1
,
0
(
d

0
0
+
E
2
9
1
7
3
9
4
3
4
0
.
2

5
0
+
E
6
9
1
7
2
2
3
9
5
1
.
1
 

4
0
+
E
8
8
2
4
3
4
0
2
2
3
.
1

4
0
+
E
6
1
9
1
3
6
8
9
4
4
.
2
 

4
0
+
E
9
0
4
0
0
9
7
3
8
5
.
1
 

4
0
+
E
1
0
8
5
8
2
5
5
2
6
.
3
 

4
0
+
E
6
7
4
2
4
2
9
2
4
7
.
3

3
0
+
E
5
5
8
0
6
3
9
2
6
2
.
8

4
0
+
E
5
1
4
3
6
8
8
3
4
8
.
1
 

4
0
+
E
9
6
4
9
7
9
4
1
7
4
.
1
 

4
0
+
E
5
8
8
3
7
4
3
6
0
0
.
3
 

4
0
+
E
1
6
6
6
3
6
6
2
1
3
.
2

3
0
+
E
8
8
2
4
7
1
9
1
1
4
.
9

3
0
+
E
6
5
7
5
3
6
4
7
9
6
.
3

3
0
+
E
9
8
0
3
8
3
6
2
7
0
.
9

4
0
+
E
4
7
9
2
8
1
9
1
0
6
.
1

2
0
+
E
5
5
1
5
3
4
2
8
3
0
.
2
 

3
0
+
E
9
4
1
3
0
7
1
3
3
5
.
8

4
0
+
E
4
9
3
6
6
6
1
0
1
8
.
1

4
0
+
E
4
5
6
7
9
5
4
7
3
9
.
2

4
0
+
E
3
5
3
4
5
4
4
8
8
8
.
2

4
0
+
E
9
8
8
7
2
7
0
7
3
9
.
1

4
0
+
E
0
7
7
0
4
8
7
1
7
7
.
3
 

)
3
,
4
,
0
,
0
(
d

)
4
,
4
,
0
,
0
(
d

)
0
,
5
,
0
,
0
(
d

)
1
,
5
,
0
,
0
(
d

)
2
,
5
,
0
,
0
(
d

)
3
,
5
,
0
,
0
(
d

)
4
,
5
,
0
,
0
(
d

)
0
,
6
,
0
,
0
(
d

)
1
,
6
,
0
,
0
(
d

)
2
,
6
,
0
,
0
(
d

)
3
,
6
,
0
,
0
(
d

)
4
,
6
,
0
,
0
(
d

)
0
,
7
,
0
,
0
(
d

)
1
,
7
,
0
,
0
(
d

)
2
,
7
,
0
,
0
(
d

)
3
,
7
,
0
,
0
(
d

)
4
,
7
,
0
,
0
(
d

)
0
,
8
,
0
,
0
(
d

)
1
,
8
,
0
,
0
(
d

)
2
,
8
,
0
,
0
(
d

)
3
,
8
,
0
,
0
(
d

)
4
,
8
,
0
,
0
(
d

)
0
,
0
,
1
,
0
(
d

3
0
+
E
4
1
1
1
7
8
1
5
0
3
.
7
 

4
0
+
E
6
7
5
5
7
0
5
9
1
1
.
5
 

4
0
+
E
6
5
0
7
0
0
3
9
6
2
.
8
 

4
0
+
E
6
4
2
3
4
8
8
4
2
5
.
8
 

4
0
+
E
7
8
2
4
1
8
3
2
8
3
.
4
 

2
0
+
E
4
4
6
4
9
8
0
4
4
3
.
1
 

4
0
+
E
0
8
3
8
5
2
0
4
2
7
.
8
 

5
0
+
E
9
2
6
1
9
8
1
3
7
3
.
1
 

5
0
+
E
3
9
6
9
1
6
3
8
1
4
.
1
 

4
0
+
E
8
0
6
2
0
9
3
3
2
3
.
6
 

2
0
+
E
4
6
4
0
7
9
0
5
9
0
.
4
 

5
0
+
E
3
4
4
5
3
0
9
6
4
3
.
1
 

5
0
+
E
5
9
1
6
7
4
8
1
4
0
.
2
 

5
0
+
E
2
1
5
6
0
0
7
5
8
0
.
2
 

4
0
+
E
8
7
8
7
7
9
2
1
4
9
.
7
 

3
0
+
E
4
6
0
9
6
1
3
5
7
9
.
9

5
0
+
E
9
6
7
5
8
3
7
4
1
0
.
1
 

5
0
+
E
0
5
6
3
4
6
6
0
2
4
.
1
 

5
0
+
E
6
7
6
8
3
2
8
5
2
5
.
1
 

4
0
+
E
2
0
2
9
5
2
4
5
4
0
.
3
 

3
0
+
E
3
9
2
5
1
8
3
4
0
3
.
6

4
0
+
E
4
2
1
2
5
0
3
8
3
9
.
7
 

5
0
+
E
2
5
4
8
8
4
0
5
0
0
.
1
 

)
0
,
0
,
0
,
0
(
d

)
1
,
0
,
0
,
0
(
d

)
2
,
0
,
0
,
0
(
d

)
3
,
0
,
0
,
0
(
d

)
4
,
0
,
0
,
0
(
d

)
0
,
1
,
0
,
0
(
d

)
1
,
1
,
0
,
0
(
d

)
2
,
1
,
0
,
0
(
d

)
3
,
1
,
0
,
0
(
d

)
4
,
1
,
0
,
0
(
d

)
0
,
2
,
0
,
0
(
d

)
1
,
2
,
0
,
0
(
d

)
2
,
2
,
0
,
0
(
d

)
3
,
2
,
0
,
0
(
d

)
4
,
2
,
0
,
0
(
d

)
0
,
3
,
0
,
0
(
d

)
1
,
3
,
0
,
0
(
d

)
2
,
3
,
0
,
0
(
d

)
3
,
3
,
0
,
0
(
d

)
4
,
3
,
0
,
0
(
d

)
0
,
4
,
0
,
0
(
d

)
1
,
4
,
0
,
0
(
d

)
2
,
4
,
0
,
0
(
d

Tabelas de Coeﬁcientes da Parametrização do Modelo com Intrusão de Alta Velocidade 90

.
e
t
r
a
p

a
2

.
o
ã
s
r
e
v
n

i

a
n

s
o
d
i
t
b
o

,
I
,
3

M

,
e
d
a
d

i
c
o
l
e
v

a
t
l
a

e
d

o
ã
s
u
r
t
n

i

o
l
e
d
o
m
o
d

o
ã
ç
a
z
i
r
t
e
m
a
r
a
p

a
d

s
e
t
n
e
i
c
ﬁ
e
o
C

:
6
.
B
a
l
e
b
a
T

r
o
l
a
v

)
2
k
,
1
k
,
2
j
,
1
j
(
d

r
o
l
a
v

)
2
k
,
1
k
,
2
j
,
1
j
(
d

r
o
l
a
v

)
2
k
,
1
k
,
2
j
,
1
j
(
d

r
o
l
a
v

)
2
k
,
1
k
,
2
j
,
1
j
(
d

4
0
+
E
9
2
4
9
3
2
8
9
3
6
.
4

4
0
+
E
9
4
9
7
4
3
0
6
6
0
.
3
 

4
0
+
E
3
5
3
9
5
2
0
8
0
8
.
1

4
0
+
E
4
9
5
5
9
2
3
4
7
4
.
5
 

4
0
+
E
0
5
3
7
8
1
3
5
9
5
.
1

4
0
+
E
8
0
3
1
8
7
8
7
7
0
.
1
 

4
0
+
E
0
5
1
4
1
5
1
6
9
2
.
3
 

4
0
+
E
3
8
9
8
2
8
7
6
3
5
.
5
 

4
0
+
E
1
1
9
4
9
3
6
9
1
4
.
4

4
0
+
E
6
7
4
9
3
1
3
2
5
5
.
2

4
0
+
E
7
4
1
6
4
3
3
4
0
5
.
4
 

4
0
+
E
6
5
0
3
6
3
1
0
5
1
.
2

4
0
+
E
9
0
8
5
3
9
6
5
6
6
.
2

4
0
+
E
4
9
8
9
2
4
0
3
9
0
.
7
 

4
0
+
E
9
3
5
8
6
7
0
2
5
5
.
4

4
0
+
E
5
5
7
9
3
2
3
0
4
5
.
2

2
0
+
E
4
4
1
5
5
9
9
3
2
8
.
1

3
0
+
E
9
2
1
0
8
5
1
0
8
4
.
9

3
0
+
E
3
0
0
1
0
7
8
6
0
4
.
5

4
0
+
E
1
5
0
3
2
0
5
4
8
1
.
2

2
0
+
E
7
5
5
1
1
7
4
3
0
6
.
2

4
0
+
E
4
0
1
0
9
3
1
1
2
4
.
1
 

)
3
,
4
,
1
,
1
(
d

)
4
,
4
,
1
,
1
(
d

)
0
,
5
,
1
,
1
(
d

)
1
,
5
,
1
,
1
(
d

)
2
,
5
,
1
,
1
(
d

)
3
,
5
,
1
,
1
(
d

)
4
,
5
,
1
,
1
(
d

)
0
,
6
,
1
,
1
(
d

)
1
,
6
,
1
,
1
(
d

)
2
,
6
,
1
,
1
(
d

)
3
,
6
,
1
,
1
(
d

)
4
,
6
,
1
,
1
(
d

)
0
,
7
,
1
,
1
(
d

)
1
,
7
,
1
,
1
(
d

)
2
,
7
,
1
,
1
(
d

)
3
,
7
,
1
,
1
(
d

)
4
,
7
,
1
,
1
(
d

)
0
,
8
,
1
,
1
(
d

)
1
,
8
,
1
,
1
(
d

)
2
,
8
,
1
,
1
(
d

)
3
,
8
,
1
,
1
(
d

)
4
,
8
,
1
,
1
(
d

4
0
+
E
9
2
5
6
2
1
3
8
1
6
.
3

4
0
+
E
6
3
1
8
3
2
8
2
2
1
.
1

4
0
+
E
8
5
3
1
8
1
6
0
9
4
.
3
 

4
0
+
E
1
1
5
1
0
1
1
5
8
3
.
5

4
0
+
E
5
5
8
1
9
8
2
6
9
6
.
4
 

4
0
+
E
4
5
1
5
5
8
2
0
4
3
.
2

4
0
+
E
7
1
6
6
3
8
3
8
0
5
.
6
 

4
0
+
E
2
3
1
5
8
4
2
4
6
4
.
2

4
0
+
E
9
3
7
7
1
4
6
0
9
3
.
3

4
0
+
E
2
2
5
9
4
0
3
2
7
3
.
2

4
0
+
E
7
7
3
0
4
4
2
2
1
7
.
4
 

3
0
+
E
0
1
0
9
4
9
0
9
1
9
.
1
 

4
0
+
E
2
4
8
1
2
4
4
4
0
1
.
3
 

3
0
+
E
4
8
7
3
5
4
2
1
5
3
.
7

4
0
+
E
1
0
0
9
1
2
9
1
1
5
.
1

4
0
+
E
2
6
9
1
9
7
4
6
0
2
.
4
 

4
0
+
E
9
4
8
0
4
3
3
9
4
0
.
2
 

4
0
+
E
5
9
4
7
9
3
8
8
7
1
.
1
 

3
0
+
E
5
3
1
4
3
6
2
7
0
2
.
5
 

4
0
+
E
3
0
0
1
5
5
5
1
5
3
.
5
 

4
0
+
E
6
1
3
5
6
6
9
0
3
0
.
4

3
0
+
E
7
2
2
7
5
4
4
9
8
9
.
1
 

)
1
,
0
,
1
,
1
(
d

)
2
,
0
,
1
,
1
(
d

)
3
,
0
,
1
,
1
(
d

)
4
,
0
,
1
,
1
(
d

)
0
,
1
,
1
,
1
(
d

)
1
,
1
,
1
,
1
(
d

)
2
,
1
,
1
,
1
(
d

)
3
,
1
,
1
,
1
(
d

)
4
,
1
,
1
,
1
(
d

)
0
,
2
,
1
,
1
(
d

)
1
,
2
,
1
,
1
(
d

)
2
,
2
,
1
,
1
(
d

)
3
,
2
,
1
,
1
(
d

)
4
,
2
,
1
,
1
(
d

)
0
,
3
,
1
,
1
(
d

)
1
,
3
,
1
,
1
(
d

)
2
,
3
,
1
,
1
(
d

)
3
,
3
,
1
,
1
(
d

)
4
,
3
,
1
,
1
(
d

)
0
,
4
,
1
,
1
(
d

)
1
,
4
,
1
,
1
(
d

)
2
,
4
,
1
,
1
(
d

4
0
+
E
2
1
5
4
0
9
1
4
0
4
.
4

3
0
+
E
1
6
6
8
5
7
5
2
6
5
.
6
 

4
0
+
E
7
2
0
6
7
6
5
9
9
4
.
1

3
0
+
E
5
0
0
3
6
9
1
4
3
6
.
5
 

4
0
+
E
2
6
2
7
3
1
1
9
4
4
.
1
 

4
0
+
E
9
9
3
7
4
0
4
4
3
4
.
1
 

4
0
+
E
5
3
8
3
8
4
4
3
2
8
.
3

3
0
+
E
1
8
1
9
9
3
2
6
0
7
.
3

3
0
+
E
9
3
6
6
6
1
4
7
8
4
.
8
 

4
0
+
E
6
3
2
5
2
8
8
4
6
5
.
3

3
0
+
E
5
7
1
4
2
1
6
3
3
1
.
9
 

4
0
+
E
9
9
6
6
6
7
8
6
1
0
.
7

4
0
+
E
8
1
1
8
0
6
7
9
2
0
.
4

4
0
+
E
6
5
3
4
0
7
7
6
2
7
.
2
 

4
0
+
E
4
4
9
1
6
7
3
5
6
6
.
2
 

4
0
+
E
5
1
8
8
8
3
1
3
2
4
.
5
 

4
0
+
E
4
7
6
3
1
0
2
8
5
7
.
2

4
0
+
E
2
1
7
4
9
4
4
6
3
1
.
7

4
0
+
E
8
4
0
7
0
2
5
3
1
7
.
4
 

4
0
+
E
8
5
7
6
3
3
1
0
0
0
.
3

4
0
+
E
9
4
9
9
8
7
6
8
0
0
.
8
 

4
0
+
E
9
0
8
3
8
5
4
6
2
8
.
4
 

)
4
,
4
,
0
,
1
(
d

)
0
,
5
,
0
,
1
(
d

)
1
,
5
,
0
,
1
(
d

)
2
,
5
,
0
,
1
(
d

)
3
,
5
,
0
,
1
(
d

)
4
,
5
,
0
,
1
(
d

)
0
,
6
,
0
,
1
(
d

)
1
,
6
,
0
,
1
(
d

)
2
,
6
,
0
,
1
(
d

)
3
,
6
,
0
,
1
(
d

)
4
,
6
,
0
,
1
(
d

)
0
,
7
,
0
,
1
(
d

)
1
,
7
,
0
,
1
(
d

)
2
,
7
,
0
,
1
(
d

)
3
,
7
,
0
,
1
(
d

)
4
,
7
,
0
,
1
(
d

)
0
,
8
,
0
,
1
(
d

)
1
,
8
,
0
,
1
(
d

)
2
,
8
,
0
,
1
(
d

)
3
,
8
,
0
,
1
(
d

)
4
,
8
,
0
,
1
(
d

)
0
,
0
,
1
,
1
(
d

4
0
+
E
3
3
4
4
4
9
5
5
5
2
.
3
 

4
0
+
E
4
8
0
7
0
8
2
7
0
2
.
3
 

3
0
+
E
1
3
9
0
9
3
1
1
7
2
.
9

3
0
+
E
6
9
7
9
3
7
6
5
6
4
.
8
 

4
0
+
E
2
1
4
6
6
7
6
2
3
7
.
6

5
0
+
E
6
1
1
0
4
8
0
6
1
0
.
1

4
0
+
E
2
5
3
5
4
9
2
7
1
5
.
9

4
0
+
E
5
2
0
7
3
0
0
5
2
8
.
4

4
0
+
E
1
6
0
9
7
0
3
0
2
6
.
1

4
0
+
E
0
2
6
3
0
4
1
7
3
8
.
1
 

4
0
+
E
5
0
6
6
3
5
2
1
0
0
.
5
 

4
0
+
E
7
6
7
1
4
5
9
8
2
2
.
5
 

4
0
+
E
2
0
4
5
1
2
3
1
3
7
.
4
 

4
0
+
E
4
9
0
9
5
5
5
4
9
9
.
1

3
0
+
E
8
7
6
3
9
3
5
8
1
7
.
2
 

4
0
+
E
2
0
4
0
5
1
0
1
1
0
.
2
 

4
0
+
E
3
6
2
3
5
3
0
8
2
9
.
1
 

4
0
+
E
0
4
2
6
0
9
6
8
9
7
.
1
 

4
0
+
E
3
2
7
9
7
2
3
7
6
7
.
2

4
0
+
E
8
2
3
1
7
3
9
1
9
2
.
2
 

4
0
+
E
4
3
9
9
1
5
1
8
5
8
.
3
 

4
0
+
E
4
0
0
0
6
2
3
1
3
4
.
5
 

)
2
,
0
,
0
,
1
(
d

)
3
,
0
,
0
,
1
(
d

)
4
,
0
,
0
,
1
(
d

)
0
,
1
,
0
,
1
(
d

)
1
,
1
,
0
,
1
(
d

)
2
,
1
,
0
,
1
(
d

)
3
,
1
,
0
,
1
(
d

)
4
,
1
,
0
,
1
(
d

)
0
,
2
,
0
,
1
(
d

)
1
,
2
,
0
,
1
(
d

)
2
,
2
,
0
,
1
(
d

)
3
,
2
,
0
,
1
(
d

)
4
,
2
,
0
,
1
(
d

)
0
,
3
,
0
,
1
(
d

)
1
,
3
,
0
,
1
(
d

)
2
,
3
,
0
,
1
(
d

)
3
,
3
,
0
,
1
(
d

)
4
,
3
,
0
,
1
(
d

)
0
,
4
,
0
,
1
(
d

)
1
,
4
,
0
,
1
(
d

)
2
,
4
,
0
,
1
(
d

)
3
,
4
,
0
,
1
(
d

AnexoI

Programação em Paralelo - OpenMP

A programação em paralelo consiste basicamente em dividir tarefas, cujos processamentos são in-
dependentes, em núcleos distintos de processamento, quer seja no mesmo processador (multinúcleo)
ou em processadores diferentes (clusters). Há duas alternativas principais para programar-se em
paralelo: MPI e OpenMP, sendo esta última a escolhida para este trabalho, sobretudo pela sua
simplicidade de implementação.
Todo o processamento foi realizado em computador pessoal, do tipo notebook, marca Dellr, modelo
Xpsr 15-l502x, processador Intelr Core i7-2630qm (Sandy Bridge), com 8 núcleos de processa-
mento, sendo 4 núcleos reais e 4 virtuais.
Para a implementação do OpenMP no código Fortran basta a inserção de algumas diretivas, inciadas
como comentários “!$omp + diretiva”. Além disso, é preciso inserir o comando “-fopenmp” quando
da compilção do código, sob pena do compilador ignorar as diretivas (interpretando-as como simples
comentários), resultando em um prograna serial.
Uma lista com as diretivas possíveis, reproduzida do sítio oﬁcial 1 do projeto OpenMP, segue abaixo;
destas, as mais utilizadas foram: !$omp sections e !$omp parallel do.

1Disponível em: < http://www.openmp.org/mp-documents/OpenMP-4.5-1115-F-web.pdf > Acesso em:

10 dezembro 2015.

91

© 2015 OpenMP ARB  OMP1115FOpenMP API 4.5 Fortran Page 1OpenMP 4.5 API Fortran Syntax Reference GuideFortranOpenMP Application Program Interface (API) is a portable, scalable model that gives parallel programmers a simple and flexible interface for developing portable parallel applications. OpenMP supports multi-platform shared-memory parallel programming in C/C++ and Fortran on all architectures, including Unix platforms and Windows platforms.  See www.openmp.org for specifications.•   Text in this color indicates functionality that is new or changed in the OpenMP API 4.5 specification.•   [n.n.n] Refers to sections in the OpenMP API 4.5 specification. •   [n.n.n] Refers to sections in the OpenMP API 4.0 specification.®Directives and Constructs for FortranOpenMP directives are specified in Fortran by using special comments that are identified by unique sentinels. Also, a special comment form is available for conditional Fortran compilation. An OpenMP executable directive applies to the succeeding structured block. A structured-block is a block of executable statements with a single entry at the top and a single exit at the bottom, or an OpenMP construct. OpenMP directives except SIMD and declare target directives may not appear in PURE or ELEMENTAL procedures.parallel [2.5] [2.5]Forms a team of threads and starts parallel execution.!$omp parallel [clause[ [, ]clause] ...]  structured-block!$omp end parallelclause:if([parallel :] scalar-logical-expression)num_threads(scalar-integer-expression)default(private | firstprivate | shared | none)private(list)firstprivate(list)shared(list)copyin(list)reduction(reduction-identifier : list) proc_bind(master | close | spread)do [2.7.1]  [2.5.1]Specifies that the iterations of associated loops will be executed in parallel by threads in the team. !$omp do [clause[ [, ]clause] ...]  do-loops[!$omp end do [nowait] ]clause:private(list)firstprivate(list)lastprivate(list)linear(list[ : linear-step])reduction(reduction-identifier : list)schedule([modifier [, modifier]  : ] kind[, chunk_size])collapse(n)ordered [(n)]kind:• static:  Iterations are divided into chunks of size  chunk_size and assigned to threads in the team in round-robin fashion in order of thread number.• dynamic: Each thread executes a chunk of iterations then requests another chunk until no chunks remain to be distributed.• guided: Each thread executes a chunk of iterations then requests another chunk until no chunks remain to be assigned.• auto: The decision regarding scheduling is delegated to the compiler and/or runtime system.• runtime: The schedule and chunk size are taken at runtime from the run-sched-var ICV.modifier:• monotonic: Each thread executes the chunks that it is assigned in increasing logical iteration order.• nonmonotonic: Chunks are assigned to threads in any order and the behavior of an application that depends on execution order of the chunks is unspecified.• simd:  Ignored when the loop is not associated with a SIMD construct, otherwise the new_chunk_size for all except the first and last chunks is chunk_size/simd_width  *  simd_width where simd_width is an implementation-defined value.sections [2.7.2] [2.5.2]A noniterative worksharing construct that contains a set of structured blocks that are to be distributed among and executed by the threads in a team. !$omp sections [clause[[,] clause] ...]  [!$omp section]   structured-block [!$omp section     structured-block] ...!$omp end sections [nowait] clause:private(list)firstprivate(list)lastprivate(list)reduction(reduction-identifier : list)      single [2.7.3] [2.7.3]Specifies that the associated structured block is executed by only one of the threads in the team.!$omp single [clause[ [, ]clause] ...]  structured-block!$omp end single [end_clause[ [, ]end_clause] ...]clause:private(list)firstprivate(list)end_clause:copyprivate(list)nowaitworkshare [2.7.4]  [2.7.4]Divides the execution of the enclosed structured block into separate units of work, each executed only once by one thread.!$omp workshare  structured-block!$omp end workshare [nowait] The structured block must consist of only the following:array or scalar assignments FORALL or WHERE statements WHERE, atomic, critical, or parallel constructssimd [2.8.1] [2.8.1]Applied to a loop to indicate that the loop can be transformed into a SIMD loop.!$omp simd [clause[ [, ]clause] ...]  do-loops[!$omp end simd]clause:safelen(length)simdlen(length)linear(list[ : linear-step])aligned(list[ : alignment])private(list)lastprivate(list)reduction(reduction-identifier : list) collapse(n)declare simd [2.8.2] [2.8.2]Applied to a function or a subroutine to enable the creation of one or more versions that can process multiple arguments using SIMD instructions from a single invocation from a SIMD loop.!$omp declare simd [(proc-name)]  [clause[ [, ]clause] ...] clause:simdlen(length)linear(linear-list[ : linear-step])aligned(argument-list[ : alignment])uniform(argument-list)inbranchnotinbranchdo simd [2.8.3] [2.8.3]Specifies a loop that can be executed concurrently using SIMD instructions and that those iterations will also be executed in parallel by threads in the team.!$omp do simd [clause[ [, ]clause] ...]  do-loops[!$omp end do simd [nowait]]clause:Any accepted by the simd or do directives with identical meanings and restrictions.task [2.9.1]  [2.11.1]Defines an explicit task. The data environment of the task is created according to data-sharing attribute clauses on task construct and any defaults that apply.!$omp task [clause[ [, ]clause] ...]  structured-block!$omp end task                  clause may be:if([ task : ] scalar-logical-expression)final(scalar-logical-expression)untieddefault(private | firstprivate | shared | none)mergeableprivate(list)firstprivate(list)shared(list)depend(dependence-type : list)priority(priority-value)Continued4Page 2 OpenMP API 4.5 Fortran  © 2015 OpenMP ARB  OMP1115FDirectives and Constructs for Fortran (continued)taskloop [2.9.2] Specifies that the iterations of one or more associated loops will be executed in parallel using OpenMP tasks.!$omp taskloop [clause[ [, ]clause] ...]  do-loops[!$omp end taskloop ] clause:if([ taskloop : ] scalar-logical-expression)shared(list)private(list)firstprivate(list)lastprivate(list)default(private | firstprivate | shared | none)grainsize(grain-size)num_tasks(num-tasks)collapse(n)final(scalar-logical-expression)priority(priority-value)untiedmergeablenogrouptaskloop simd [2.9.3]Specifies that a loop that can be executed concurrently using SIMD instructions, and that those iterations will also be executed in parallel using OpenMP tasks.!$omp taskloop simd [clause[ [, ]clause] ...]  do-loops[!$omp end taskloop simd]  clause:Any accepted by the simd or taskloop directives with identical meanings and restrictions.taskyield [2.9.4] [2.11.2]Specifies that the current task can be suspended in favor of execution of a different task.!$omp taskyield  target data [2.10.1] [2.9.1]Creates a device data environment for the extent of the region.!$omp target data clause[ [ [, ]clause] ...]  structured-block!$omp end target dataclause:if( [target data : ] scalar-logical-expression)device(scalar-integer-expression) map( [[map-type-modifier[,]] map-type : ] list)use_device_ptr(list)target enter data [2.10.2] Specifies that variables are mapped to a device data environment.!$omp target enter data [clause[ [, ]clause] ...]  clause: if([target enter data : ] scalar-logical-expression)device(scalar-integer-expression) map( [[map-type-modifier[,]] map-type : ] list)depend(dependence-type : list)nowaittarget exit data [2.10.3] Specifies that list items are unmapped from a device data environment.!$omp target exit data [clause[ [, ]clause] ...]  clause: if([target exit data : ] scalar-logical-expression)device(scalar-integer-expression) map( [[map-type-modifier[,]] map-type : ] list)depend(dependence-type : list)nowaittarget [2.10.4] [2.9.2]Map variables to a device data environment and execute the construct on that device.!$omp target [clause[ [, ]clause] ...]structured-block!$omp end targetclause:if([target  : ] scalar-logical-expression)device(scalar-integer-expression) private(list)firstprivate(list)map( [[map-type-modifier[,]] map-type : ] list)is_device_ptr(list)defaultmap(tofrom : scalar)nowaitdepend(dependence-type : list)target update [2.10.5] [2.9.3]Makes the corresponding list items in the device data environment consistent with their original list items, according to the specified motion clauses.!$omp target update clause clause[ [ [, ]clause] ...]  clause: motion-clause or one of:if([target update  : ] scalar-logical-expression)device(scalar-integer-expression) nowaitdepend(dependence-type : list) motion-clause:to(list)from(list)declare target [2.10.6] [2.9.4]A declarative directive that specifies that variables and functions are mapped to a device.!$omp declare target  [clause[ [, ]clause] ...]  clause:to(extended-list)link(list)!$omp declare target (extended-list)extended-list: A comma-separated list of named variables, procedure names, and named common blocks. teams [2.10.7] [2.9.5]Creates a league of thread teams where the master thread of each team executes the region.!$omp teams [clause[ [, ]clause] ...]  structured-block!$omp end teamsclause:num_teams(scalar-integer-expression)thread_limit(scalar-integer-expression)default(shared | firstprivate | private | none)private(list)firstprivate(list)shared(list)reduction(reduction-identifier : list) distribute [2.10.8] [2.9.6]Specifies loops which are executed by the thread teams. !$omp distribute [clause[ [, ]clause] ...]   do-loops[!$omp end distribute]clause:private(list)firstprivate(list)lastprivate(list)collapse(n)dist_schedule(kind[, chunk_size])distribute simd [2.10.9] [2.9.7]Specifies loops which are executed concurrently using SIMD instructions. !$omp distribute simd [clause[ [, ]clause] ...]   do-loops[!$omp end distribute simd]clause: Any of the clauses accepted by distribute or simd.distribute parallel do [2.10.10] [2.9.8]These constructs specify a loop that can be executed in parallel by multiple threads that are members of multiple teams.!$omp distribute parallel do [clause[ [, ]clause] ...]   do-loops[!$omp end distribute parallel do]clause: Any accepted by the distribute or parallel do directives.distribute parallel do simd [2.10.11] [2.9.9]These constructs specify a loop that can be executed in parallel using SIMD semantics in the simd case by multiple threads that are members of multiple teams.!$omp distribute parallel do simd [clause[ [, ]clause] ...]   do-loops[!$omp end distribute parallel do simd]clause: Any accepted by the distribute or parallel do simd  directives.parallel do [2.11.1] [2.10.1]Shortcut for specifying a parallel construct containing one or more associated loops and no other statements.!$omp parallel do [clause[ [, ]clause] ...]   do-loops[!$omp end parallel do]clause: Any accepted by the parallel or do directives, with identical meanings and restrictions.parallel sections [2.11.2] [2.10.2]Shortcut for specifying a parallel construct containing one sections construct and no other statements.!$omp parallel sections [clause[ [, ]clause] ...]   [!$omp section]        structured-block [!$omp section       structured-block] ...!$omp end parallel sections clause: Any of the clauses accepted by the parallel or sections directives, with identical meanings and restrictions. The last section ends at the end parallel sections directive. nowait cannot be specified on an end parallel sections directive.parallel workshare [2.11.3] [2.10.3]Shortcut for specifying a parallel construct containing one workshare construct and no other statements.!$omp parallel workshare [clause[ [, ]clause] ...]   structured-block!$omp end parallel workshare  clause: Any of the clauses accepted by the parallel directive, with identical meanings and restrictions. Continued4© 2015 OpenMP ARB  OMP1115FOpenMP API 4.5 Fortran Page 3Directives and Constructs for Fortran (continued)parallel do simd [2.11.4] [2.10.4]Shortcut for specifying a parallel construct containing one do simd construct and no other statements.!$omp parallel do simd [clause[ [, ]clause] ...]   do-loops[!$omp end parallel do simd]clause: Any accepted by the parallel or do simd directives with identical meanings and restrictions. If an  end parallel do simd directive is not specified, then an end parallel do simd directive is assumed at the end of the do-loops.target parallel [2.11.5]Shortcut for specifying a target construct containing a parallel construct and no other statements.!$omp target parallel [clause[ [, ]clause] ...]   structured-block!$omp end target parallelclause: Any accepted by the target or parallel directives, except for copyin, with identical meanings and restrictions.target parallel do [2.11.6] Shortcut for specifying a target construct containing aparallel do construct and no other statements.!$omp target parallel do  [clause[ [, ]clause] ...]   do-loops[!$omp end target parallel do]clause: Any accepted by the target or parallel do directives, except for copyin, with identical meanings and restrictions.target parallel do simd [2.11.7] Shortcut for specifying a target construct containing aparallel do simd construct and no other statements.!$omp target parallel do simd [clause[ [, ]clause] ...]   do-loops[!$omp end target parallel do simd]clause: Any accepted by the target or parallel do simd directives, except for copyin, with identical meanings and restrictions.target simd [2.11.8]Shortcut for specifying a target construct containing a simd construct and no other statements.!$omp target simd [clause[ [, ]clause] ...]   do-loops[!$omp end target simd]clause: Any accepted by the target or simd directives with identical meanings and restrictions.target teams [2.11.9] [2.10.5]Shortcut for specifying a target construct containing a teams construct and no other statements.!$omp target teams [clause[ [, ]clause] ...]   structured-block!$omp end target teamsclause:  Any accepted by the target or teams directives with identical meanings and restrictions.teams distribute [2.11.10] [2.10.6]Shortcuts for specifying teams constructs containing a distribute construct and no other statements.!$omp teams distribute  [clause[ [, ]clause] ...]   do-loops[ !$omp end teams distribute ] clause: Any accepted by the teams or distribute directives with identical meanings and restrictions.teams distribute simd [2.11.11] [2.10.7]Shortcuts for specifying teams constructs containing a distribute simd construct and no other statements.!$omp teams distribute simd [clause[ [, ]clause] ...]   do-loops[ !$omp end teams distribute simd ] clause: Any accepted by the teams or distribute simd directives with identical meanings and restrictions.target teams distribute [2.11.12] [2.10.8]Shortcuts for specifying a target construct containing a teams distribute construct and no other statements.!$omp target teams distribute [clause[ [, ]clause] ...]   do-loops[ !$omp end target teams distribute ] clause: Any accepted by the target or teams distribute directives with identical meanings and restrictions.target teams distribute simd [2.11.13] [2.10.9]Shortcuts for specifying a target construct containing a teams distribute simd construct and no other statements.!$omp target teams distribute simd [clause[ [, ]clause] ...]   do-loops[ !$omp end target teams distribute simd ] clause: Any accepted by the target or teams distribute simd directives with identical meanings and restrictions.teams distribute parallel do [2.11.14] [2.10.10]Shortcuts for specifying teams constructs containing a distribute parallel do construct and no other statements.!$omp teams distribute parallel do [clause[ [, ]clause] ...]   do-loops[ !$omp end teams distribute parallel do ] clause: Any clause used for teams or distribute parallel do directives with identical meanings and restrictions. target teams distribute parallel do [2.11.15] [2.10.11]Shortcut for specifying a target construct containing a teams distribute parallel do construct and no other statements.!$omp target teams distribute parallel do & !$omp [clause[ [, ]clause] ...]    do-loops[$omp end target teams distribute parallel do] clause:  Any clause used for teams distribute parallel do or target directives with identical meanings and restrictions. teams distribute parallel do simd [2.11.16] [2.10.12]Shortcut for specifying a teams construct containing a distribute parallel do simd construct and no other statements.!$omp teams distribute parallel do simd & !$omp [clause[ [, ]clause] ...]    do-loops[!$omp end teams distribute parallel do simd] clause: Any clause used for teams or distribute parallel do simd directives with identical meanings and restrictions. target teams distribute parallel do simd  [2.11.17] [2.10.13]Shortcut for specifying a target construct containing a teams distribute parallel do simd construct and no other statements.!$omp target teams distribute parallel do simd &  !$omp [clause[ [, ]clause] ...]   do-loops[!$omp end target teams distribute parallel do simd] clause:  Any clause used for teams distribute parallel do simd or target directives with identical meanings and restrictions. master [2.13.1] [2.12.1]Specifies a structured block that is executed by the master thread of the team. !$omp master   structured-block!$omp end master critical [2.13.2] [2.12.2]Restricts execution of the associated structured block to a single thread at a time.  !$omp critical [(name) [hint(hint-expression)] ]  structured-block!$omp end critical [(name)]  barrier [2.13.3] [2.12.3]Placed only at a point where a base language statement is allowed, this directive specifies an explicit barrier at the point at which the construct appears. !$omp barrier  taskwait [2.13.4] [2.12.4]Specifies a wait on the completion of child tasks of the current task. !$omp taskwait  taskgroup [2.13.5] [2.12.5]Specifies a wait on the completion of child tasks of the current task, and waits for descendant tasks.!$omp taskgroup   structured-block!$omp end taskgroupatomic [2.13.6] [2.12.6]Ensures a specific storage location is accessed atomically. May take one of the following seven forms:!$omp atomic [seq_cst[,]] read [[,]seq_cst]   capture-statement[!$omp end atomic] !$omp atomic [seq_cst[,]] write [[,]seq_cst]   write-statement[!$omp end atomic] !$omp atomic [seq_cst[,]] update [[,]seq_cst]   update-statement[!$omp end atomic] !$omp atomic [seq_cst]   update-statement[!$omp end atomic] !$omp atomic [seq_cst[,]] capture [[,]seq_cst]   update-statement capture-statement!$omp end atomic(atomic continues on the next page)Continued4Page 4 OpenMP API 4.5 Fortran  © 2015 OpenMP ARB  OMP1115FDirectives and Constructs for Fortran (continued)Runtime Library Routines for Fortran     Execution environment routines affect and monitor threads, processors, and the parallel environment. The library routines are external procedures.Execution Environment Routinesomp_set_num_threads [3.2.1] [3.2.1]Affects the number of threads used for subsequent parallel regions not specifying a num_threads clause, by setting the value of the first element of the nthreads-var ICV of the current task to num_threads. subroutine omp_set_num_threads(num_threads)integer num_threadsomp_get_num_threads [3.2.2] [3.2.2]Returns the number of threads in the current team. The binding region for an omp_get_num_threads region is the innermost enclosing parallel region. If called from the sequential part of a program, this routine returns 1.integer function omp_get_num_threads()omp_get_max_threads [3.2.3] [3.2.3]Returns an upper bound on the number of threads that could be used to form a new team if a parallel construct without a num_threads clause were encountered after execution returns from this routine. integer function omp_get_max_threads()omp_get_thread_num [3.2.4] [3.2.4]Returns the thread number of the calling thread, within the current team. integer function omp_get_thread_num()omp_get_num_procs [3.2.5] [3.2.5]Returns the number of processors that are available to the device at the time the routine is called.integer function omp_get_num_procs()omp_in_parallel [3.2.6] [3.2.6]Returns true if the active-levels-var ICV is greater than zero; otherwise it returns false.logical function omp_in_parallel()omp_set_dynamic [3.2.7] [3.2.7]Enables or disables dynamic adjustment of the number of threads available for the execution of subsequent parallel regions by setting the value of the dyn-var ICV.subroutine omp_set_dynamic(dynamic_threads)logical dynamic_threadsomp_get_dynamic [3.2.8] [3.2.8]This routine returns the value of the dyn-var ICV, which is true if dynamic adjustment of the number of threads is enabled for the current task. logical function omp_get_dynamic()omp_get_cancellation [3.2.9] [3.2.9]Returns the value of the cancel-var ICV, which is true if cancellation is activated; otherwise it returns false.logical function omp_get_cancellation()omp_set_nested [3.2.10] [3.2.10]Enables or disables nested parallelism, by setting the  nest-var ICV.subroutine omp_set_nested(nested)logical nestedomp_get_nested [3.2.11] [3.2.11]Returns the value of the nest-var ICV, which indicates if nested parallelism is enabled or disabled.logical function omp_get_nested()omp_set_schedule [3.2.12] [3.2.12]Affects the schedule that is applied when runtime is used as schedule kind, by setting the value of the run-sched-var ICV.subroutine omp_set_schedule(kind, chunk_size)integer (kind=omp_sched_kind) kindinteger chunk_sizeSee kind for omp_get_schedule.atomic (continued)!$omp atomic [seq_cst[,]] capture [[,]seq_cst]   capture-statement update-statement!$omp end atomic!$omp atomic [seq_cst[,]] capture [[,]seq_cst]   capture-statement write-statement!$omp end atomiccapture-stmt, write-stmt, or update-stmt may be:capture-statementv = xwrite-statementx = exprupdate-statementx = x operator exprx = expr operator xx = intrinsic_procedure_name (x, expr_list)x = intrinsic_procedure_name (expr_list, x)intrinsic_procedure_name is one of MAX, MIN, IAND, IOR, IEORoperator is one of +, *, -, /, .AND., .OR., .EQV., .NEQV.flush [2.13.7] [2.12.7]Makes a thread’s temporary view of memory consistent with memory, and enforces an order on the memory operations of the variables. !$omp flush [(list)]  ordered  [2.13.8] [2.12.8]Specifies a structured block in a loop, simd, or loop SIMD region that will be executed in the order of the loop iterations.  !$omp ordered [clause[ [, ]clause] ...]   structured-block!$omp end orderedclause:threadssimd(ordered continues in the next column)ordered (continued)!$omp ordered clause[[[, ]clause] ...]  clause:depend (source)depend (sink  :  vec)cancel [2.14.1] [2.13.1]Requests cancellation of the innermost enclosing region of the type specified. !$omp cancel construct-type-clause[ [, ]if-clause]    construct-type-clause:parallelsectionsdotaskgroupif-clause: if(scalar-logical-expression)cancellation point [2.14.2] [2.13.2]Introduces a user-defined cancellation point at which tasks check if cancellation of the innermost enclosing region of the type specified has been activated.  !$omp cancellation point construct-type-clause construct-type-clause:parallelsectionsdotaskgroupthreadprivate [2.15.2] [2.14.2]Specifies that variables are replicated, with each thread having its own copy. Each copy of a threadprivate variable is initialized once prior to the first reference to that copy.!$omp threadprivate(list)  list:  A comma-separated list of named variables and named common blocks. Common block names must appear between slashes. declare reduction [2.16] [2.15]Declares a reduction-identifier that can be used in a reduction clause. !$omp declare reduction( reduction-identifier : type-list :  combiner)  [initializer-clause] reduction-identifier:  A base language identifier, user defined operator, or one of the following operators: +, -, *, .and., .or., .eqv., .negv., or one of the following intrinsic procedure names: max, min, iand, ior, ieor.type-list:  A list of type specifierscombiner:  An assignment statement or a subroutine name followed by an argument listinitializer-clause: initializer (initializer-expr) where initializer-expr is omp_priv = initializer or function-name (argument-list )Continued4OpenMP API 4.5 Fortran 

Page 5

Runtime Library Routines for Fortran (continued) 

Return types are shown in green.    

omp_get_schedule [3.2.13] [3.2.13]
Returns the value of run-sched-var ICV, which is the 
schedule applied when runtime schedule is used. 
subroutine omp_get_schedule(kind, chunk_size)
integer (kind=omp_sched_kind) kind
integer chunk_size
kind for omp_set_schedule and omp_get_schedule is an 

implementation-defined schedule or:
 

omp_sched_static  
= 1 
omp_sched_dynamic   = 2 
omp_sched_guided   = 3 
omp_sched_auto  
= 4

 

omp_get_thread_limit [3.2.14] [3.2.14]
Returns the value of the thread-limit-var ICV, which is the 
maximum number of OpenMP threads available. 
integer function omp_get_thread_limit()

omp_set_max_active_levels [3.2.15] [3.2.15]
Limits the number of nested active parallel regions, by 
setting max-active-levels-var ICV. 
subroutine omp_set_max_active_levels(max_levels)
integer max_levels

omp_get_max_active_levels [3.2.16] [3.2.16]
Returns the value of max-active-levels-var ICV, which 
determines the maximum number of nested active parallel 
regions.
integer function omp_get_max_active_levels()

omp_get_level [3.2.17] [3.2.17]
For the enclosing device region, returns the levels-vars ICV, 
which is the number of nested parallel regions that enclose 
the task containing the call.
integer function omp_get_level()

omp_get_ancestor_thread_num [3.2.18] [3.2.18]
Returns, for a given nested level of the current thread, the 
thread number of the ancestor of the current thread. 
integer function omp_get_ancestor_thread_num(level)
integer level

omp_get_team_size [3.2.19] [3.2.19]
Returns, for a given nested level of the current thread, 
the size of the thread team to which the ancestor or the 
current thread belongs.
integer function omp_get_team_size(level)
integer level

omp_get_active_level [3.2.20] [3.2.20]
Returns the value of the active-level-vars ICV, which 
determines the number of active, nested parallel regions 
enclosing the task that contains the call.
integer function omp_get_active_level()

omp_in_final [3.2.21] [3.2.21]
Returns true if the routine is executed in a final task region; 
otherwise, it returns false.
logical function omp_in_final()

omp_get_proc_bind [3.2.22] [3.2.22]
Returns the thread affinity policy to be used for the 
subsequent nested parallel regions that do not specify a 
proc_bind clause.
integer (kind=omp_proc_bind_kind)& 

function omp_get_proc_bind()

Returns one of: 
= 0 
      omp_proc_bind_false  
      omp_proc_bind_true  
= 1 
      omp_proc_bind_master   = 2 
      omp_proc_bind_close  
= 3
      omp_proc_bind_spread   = 4

omp_get_ num_places [3.2.23]
Returns the number of places available to the execution
environment in the place list.
integer function omp_get_num_places()

omp_get_place_num_procs  [3.2.24]
Returns the number of processors available to the 
execution environment in the specified place.
integer function omp_get_place_num_procs(place_num)
integer place_num

omp_get_place_proc_ids  [3.2.25]
Returns numerical identifiers of the processors available 
to the execution environment in the specified place.
subroutine omp_get_place_proc_ids(place_num, ids)
integer place_num
integer ids (*)

omp_get_place_num  [3.2.26]
Returns the place number of the place to which the 
encountering thread is bound.
integer function omp_get_place_num()

omp_get_partition_num_places  [3.2.27]
Returns the number of places in the place partition of the 
innermost implicit task.
integer function omp_get_partition_num_places()

omp_get_partition_place_nums  [3.2.28]
Returns the list of place numbers corresponding to the 
places in the place-partition-var ICV of the innermost 
implicit task.
subroutine omp_get_partition_place_nums(place_nums)
integer place_nums (*)

omp_set_default_device [3.2.29] [3.2.23]
Assigns the value of the default-device-var
ICV, which determines default target device.
subroutine omp_set_default_device(device_num)
integer device_num

omp_get_default_device [3.2.30] [3.2.24]
Returns the value of the default-device-var
ICV, which determines default target device.
integer function omp_get_default_device()

omp_get_num_devices [3.2.31] [3.2.25]
Returns the number of target devices.
integer function omp_get_num_devices()

omp_get_num_teams [3.2.32] [3.2.26]
Returns the number of teams in the current teams 
region, or 1 if called from outside of a teams region.
integer function omp_get_num_teams()

omp_get_team_num [3.2.33] [3.2.27]
Returns the team number of the calling thread. The team 
number is an integer between 0 and one less than the 
value returned by omp_get_num_teams, inclusive. 
integer function omp_get_team_num()

omp_is_initial_device [3.2.34] [3.2.28]
Returns true if the current task is executing on the host
device; otherwise, it returns false.
integer function omp_is_initial_device()

omp_get_initial_device [3.2.35] 
Returns a device number representing the host device.
integer function omp_get_initial_device()

omp_get_max_task_priority [3.2.36] 
Returns the maximum value that can be specified in the 
priority clause.
integer function omp_get_max_task_priority()

Lock Routines
General-purpose lock routines. Two types of locks are 
supported: simple locks and nestable locks. A nestable 
lock can be set multiple times by the same task before 
being unset; a simple lock cannot be set if it is already 
owned by the task trying to set it.
Initialize lock [3.3.1] [3.3.1]
Initialize an OpenMP lock. 
subroutine omp_init_lock(svar)
integer (kind=omp_lock_kind) svar
subroutine omp_init_nest_lock(nvar)
integer (kind=omp_nest_lock_kind) nvar

Initialize lock with hint [3.3.2]
Initialize an OpenMP lock with a hint. 
subroutine omp_init_lock_with_hint(svar, hint)
integer (kind=omp_lock_kind) svar
integer (kind=omp_lock_hint_kind) hint
subroutine omp_init_nest_lock_with_hint(nvar, hint)
integer (kind=omp_nest_lock_kind) nvar
integer (kind=omp_lock_hint_kind) hint
omp_nest_lock_hint_kind: 
omp_lock_hint_none  
= 0 
omp_lock_hint_uncontended   = 1 
omp_lock_hint_contended  
= 2 
omp_lock_hint_nonspeculative  = 4 
omp_lock_hint_speculative  
= 8

Destroy lock [3.3.3] [3.3.2]
Ensure that the OpenMP lock is uninitialized. 
subroutine omp_destroy_lock(svar)
integer (kind=omp_lock_kind) svar
subroutine omp_destroy_nest_lock(nvar)
integer (kind=omp_nest_lock_kind) nvar

Set lock [3.3.4] [3.3.3]
Sets an OpenMP lock. The calling task region is suspended 
until the lock is set. 
subroutine omp_set_lock(svar)
integer (kind=omp_lock_kind) svar
subroutine omp_set_nest_lock(nvar)
integer (kind=omp_nest_lock_kind) nvar

Unset lock [3.3.5] [3.3.4]
Unsets an OpenMP lock. 
subroutine omp_unset_lock(svar)
integer (kind=omp_lock_kind) svar
subroutine omp_unset_nest_lock(nvar)
integer (kind=omp_nest_lock_kind) nvar

Test lock [3.3.6] [3.3.5]
Attempt to set an OpenMP lock but do not suspend 
execution of the task executing the routine.
logical function omp_test_lock(svar)
integer (kind=omp_lock_kind) svar
integer function omp_test_nest_lock(nvar)
integer (kind=omp_nest_lock_kind) nvar

Timing Routines
Timing routines support a portable wall clock timer. These 
record elapsed time per-thread and are not guaranteed to 
be globally consistent across all the threads participating in 
an application.
omp_get_wtime [3.4.1] [3.4.1]
Returns elapsed wall clock time in seconds. 
double precision function omp_get_wtime()

omp_get_wtick [3.4.2] [3.4.2]
Returns the precision of the timer (seconds between ticks) 
used by omp_get_wtime. 
double precision function omp_get_wtick()

© 2015 OpenMP ARB  

OMP1115F

Page 6 

Clauses

OpenMP API 4.5 Fortran  

The set of clauses that is valid on a particular directive is described with the directive. Most clauses accept a comma-separated list of list items. All list items appearing in a clause 
must be visible, according to the scoping rules of the base language. Not all of the clauses listed in this section are valid on all directives. 

If Clause [2.12] 
The effect of the if clause depends on the construct to 
which it is applied. 

if([directive-name-modifier :] scalar-logical-expression))
For combined or composite constructs, it only applies 
to the semantics of the construct named in the 
directive-name-modifier if one is specified. If none is 
specified for a combined or composite construct then 
the if clause applies to all constructs to which an if clause 
can apply.

linear(linear-list[:linear-step])
Declares one or more list items to be private to a SIMD 
lane and to have a linear relationship with respect to 
the iteration space of a loop. Clause linear-list is list or 
modifer(list). modifier may be one of ref, val, or uval.  

reduction(reduction-identifier : list)
Specifies a reduction-identifier and one or more list items. 
The reduction-identifier must match a previously declared 
reduction-identifier of the same name and type for each 
of the list items.

Depend Clause [2.13.9] 
Enforces additional constraints on the scheduling of 
tasks or loop iterations. These constraints establish 
dependences only between sibling tasks or between loop 
iterations.

depend(dependence-type : list)
Where dependence-type may be in, out, or inout:

in: The generated task will be a dependent task of 
all previously generated sibling tasks that reference 
at least one of the list items in an out or inout 
dependence-type list.
out and inout: The generated task will be a dependent 
task of all previously generated sibling tasks that 
reference at least one of the list items in an in, out, or 
inout dependence-type list.

depend(dependence-type)
Where dependence-type may be source.

depend(dependence-type [: vec])
Where dependence-type may be sink and is the iteration 
vector, which has the form:
x1 [± d1], x2 [± d2], . . . , xn [± dn]

Data Sharing Attribute Clauses [2.15.3] [2.9.3]
Data-sharing attribute clauses apply only to variables 
whose names are visible in the construct on which the 
clause appears.

default(private | firstprivate |shared | none)
Explicitly determines the default data-sharing attributes 
of variables that are referenced in a parallel, teams, or 
task generating construct, causing all variables referenced 
in the construct that have implicitly determined data-
sharing attributes to be shared.

shared(list)
Declares one or more list items to be shared by tasks 
generated by a parallel, teams, or task generating 
construct. The programmer must ensure that storage 
shared by an explicit task region does not reach the end 
of its lifetime before the explicit task region completes its 
execution.

private(list)
Declares one or more list items to be private to a task 
or a SIMD lane. Each task that references a list item 
that appears in a private clause in any statement in the 
construct receives a new list item.

firstprivate(list)
Declares list items to be private to a task, and initializes 
each of them with the value that the corresponding 
original item has when the construct is encountered.

lastprivate(list)
Declares one or more list items to be private to an implicit 
task or to a SIMD lane, and causes the corresponding 
original list item to be updated after the end of the 
region.

Implicitly Declared Fortran reduction-identifiers
Identifier

Initializer

+  

*  

-  

omp_priv = 0

omp_priv = 1

omp_priv = 0

.and.  

omp_priv = .true.

.or.

omp_priv = .false.

.eqv.

omp_priv = .true.

.neqv.

omp_priv = .false.

Combiner
omp_out = omp_in + 
omp_out
omp_out = omp_in * 
omp_out
omp_out = omp_in + 
omp_out
omp_out = omp_in .and. 
omp_out
omp_out = omp_in .or. 
omp_out
omp_out = omp_in .eqv. 
omp_out
omp_out = omp_in 
.neqv. omp_out

max

min

iand

ior

ieor

omp_priv = Least 
representable number in 
the reduction list item type
omp_priv = Largest 
representable number in 
the reduction list item type

omp_priv = All bits on

omp_priv = 0

omp_priv = 0

omp_out = max( 
omp_in, omp_out)

omp_out = min( 
omp_in, omp_out)

omp_out = iand( 
omp_in, omp_out)
omp_out = ior( 
omp_in, omp_out)
omp_out = ieor( 
omp_in, omp_out)

SIMD Clauses [2.8.1]
safelen(length)
If used then no two iterations executed concurrently 
with SIMD instructions can have a greater distance in the 
logical iteration space than its value. 

collapse(n)  
A constant positive integer expression that specifies how 
many loops are associated with the loop construct. 

simdlen(length)
A constant positive integer expression that specifies the 
number of concurrent arguments of the function. 

aligned(argument-list[:alignment])
Declares one or more list items to be aligned to the 
specified number of bytes. alignment, if present, must 
be a constant positive integer expression. If no optional 
parameter is specified, implementation-defined default 
alignments for SIMD instructions on the target platforms 
are assumed.

uniform(argument-list)
Declares one or more arguments to have an invariant 
value for all concurrent invocations of the function in the 
execution of a single SIMD loop.
inbranch
Specifies that the function will always be called from 
inside a conditional statement of a SIMD loop.
notinbranch
Specifies that the function will never be called from inside 
a conditional statement of a SIMD loop. 

Data Copying Clauses [2.14.4] [2.9.4]
copyin(list)
Copies the value of the master thread’s threadprivate 
variable to the threadprivate variable of each other 
member of the team executing the parallel region.
copyprivate(list)
Broadcasts a value from the data environment of one 
implicit task to the data environments of the other 
implicit tasks belonging to the parallel region.

Map Clause [2.14.5]
map([map-type:]ist)
Map a variable from the task’s data environment to the 
device data environment associated with the construct.
map-type:

alloc: On entry to the region each new corresponding 
list item has an undefined initial value.
to: On entry to the region each new corresponding list 
item is initialized with the original list item’s value.
from: On exit from the region the corresponding list 
item’s value is assigned to each original list item
tofrom: (Default) On entry to the region each new 
corresponding list item is initialized with the original 
list item’s value, and on exit from the region the 
corresponding list item’s value is assigned to each 
original list item.
release: On exit from the region, the corresponding list 
item’s reference count is decremented by one.
delete: On exit from the region, the corresponding list 
item’s reference count is set to zero.

map-type-modifer:

Must be always.

Defaultmap Clause [2.15.5.2]
defaultmap(tofrom:scalar)
Causes all scalar variables referenced in the construct  
that have implicitly determined data-mapping attributes 
to have the tofrom map-type.

Tasking Clauses [2.9]
final(scalar-logical-expr)
The generated task will be a final task if the final 
expression evaluates to true.

mergeable
Specifies that the generated task is a mergeable task.

priority(priority-value)
A non-negative numerical scalar expression that specifies 
a hint for the priority of the generated task.

grainsize(grain-size)
Causes the number of logical loop iterations assigned 
to each created task to be greater than or equal to the 
minimum of the value of the grain-size expression and 
the number of logical loop iterations, but less than two 
times the value of the grain-size expression.

num_tasks(num-tasks)
Create as many tasks as the minimum of the 
num-tasks expression and the number of logical loop 
iterations.

© 2015 OpenMP ARB  

OMP1115F

OpenMP API 4.5 Fortran 

Environment Variables [4]

Environment variable names are upper case, and the values assigned to them are case insensitive and may have leading and trailing white space.

Page 7

[4.14]  OMP_MAX_TASK_PRIORITY levels
Sets the max-task-priority-var ICV that controls the use of 
task priorities.

[4.6] [4.6] OMP_NESTED nested
Sets the nest-var ICV to enable or to disable nested 
parallelism. Valid values for nested are true or false.

[4.2] [4.2] OMP_NUM_THREADS list
Sets the nthreads-var ICV for the number of threads to 
use for parallel regions.

[4.5] [4.5] OMP_PLACES places
Sets the place-partition-var ICV that defines the OpenMP 
places available to the execution environment. places is 
an abstract name (threads, cores, sockets, or imple-
mentation-defined), or a list of non-negative numbers.

[4.4] [4.4] OMP_PROC_BIND policy
Sets the value of the global bind-var ICV, which sets the 
thread affinity policy to be used for parallel regions at 
the corresponding nested level. policy can be the values 
true, false, or a comma-separated list of master, close, or 
spread in quotes.

[4.1] [4.1] OMP_SCHEDULE type[,chunk]
Sets the run-sched-var ICV for the runtime schedule type 
and chunk size. Valid OpenMP schedule types are static, 
dynamic, guided, or auto. 

[4.7] [4.7] OMP_STACKSIZE size[B | K | M | G]
Sets the stacksize-var ICV that specifies the size 
of the stack for threads created by the OpenMP 
implementation. size is a positive integer that specifies 
stack size. If unit is not specified, size is measured in 
kilobytes (K).

[4.10] [4.10] OMP_THREAD_LIMIT limit
Sets the thread-limit-var ICV that controls the number of 
threads participating in the OpenMP program.

[4.8] [4.8] OMP_WAIT_POLICY policy
Sets the wait-policy-var ICV that provides a hint to an 
OpenMP implementation about the desired behavior 
of waiting threads. Valid values for policy are ACTIVE 
(waiting threads consume processor cycles while waiting) 
and PASSIVE.

[4.11] [4.11] OMP_CANCELLATION policy
Sets the cancel-var ICV. policy may be true or false. 
If true, the effects of the cancel construct and of 
cancellation points are enabled and cancellation is 
activated

[4.13] [4.13] OMP_DEFAULT_DEVICE device
Sets the default-device-var ICV that controls the default 
device number to use in device constructs. 

[4.12] [4.12] OMP_DISPLAY_ENV var
If var is TRUE, instructs the runtime to display the 
OpenMP version number and the value of the ICVs 
associated with the environment variables as name=value 
pairs. If var is VERBOSE, the runtime may also display 
vendor-specific variables. If var is FALSE, no information 
is displayed.

[4.3] [4.3] OMP_DYNAMIC dynamic
Sets the dyn-var ICV. If true, the implementation may 
dynamically adjust the number of threads to use for 
executing parallel regions.

[4.9] [4.9] OMP_MAX_ACTIVE_LEVELS levels
Sets the max-active-levels-var ICV that controls the 
maximum number of nested active parallel regions.

ICV Environment Variable Values

The host and target device ICVs are initialized before any OpenMP API construct or OpenMP API routine executes. After the initial values are assigned, the values of any 
OpenMP environment variables that were set by the user are read and the associated ICVs for the host device are modified accordingly. The method for initializing a 
target device’s ICVs is implementation defined.

Table of ICV Initial Values (Table 2.1) and Ways to Modify and to Retrieve ICV Values (Table 2.2)  [2.3.2-3] [2.3.2-3]

ICV

dyn-var

nest-var

nthreads-var

run-sched-var

def-sched-var

bind-var

stacksize-var

wait-policy-var

thread-limit-var

Environment variable

Initial value

Ways to modify value

Ways to retrieve value

OMP_DYNAMIC

Initial value is implementation defined if the 
implementation supports dynamic adjustment of the 
number of threads; otherwise, the initial value is false.

omp_set_dynamic()

omp_get_dynamic()

OMP_NESTED

false

omp_set_nested()

omp_get_nested()

OMP_NUM_THREADS

Implementation defined. The value of this ICV is a list. 

omp_set_num_threads()

omp_get_max_threads()

OMP_SCHEDULE

Implementation defined

omp_set_schedule()

omp_get_schedule()

(none)

OMP_PROC_BIND

OMP_STACKSIZE

Implementation defined

Implementation defined. The value of this ICV is a list.

Implementation defined

OMP_WAIT_POLICY

Implementation defined

(none)

(none)

(none)

(none)

(none)

omp_get_proc_bind()

(none)

(none)

Ref.

Sec 4.3

Sec 4.6

Sec 4.2

Sec 4.1

---

Sec 4.4

Sec 4.7

Sec 4.8

OMP_THREAD_LIMIT

Implementation defined

thread_limit clause

omp_get_thread_limit()

Sec 4.10

max-active-levels-var

OMP_MAX_ACTIVE_LEVELS

The initial value is the number of levels of parallelism 
that the implementation supports.

omp_set_max_active_levels()

omp_get_max_active_levels()

Sec 4.9

active-levels-var

levels-var

(none)

(none)

zero

zero

place-partition-var

OMP_PLACES

Implementation defined

cancel-var

OMP_CANCELLATION

false

(none)

(none)

(none)

(none)

default-device-var

OMP_DEFAULT_DEVICE

Implementation defined

omp_set_default_device()

omp_get_default_device()

max-task-priority-var

OMP_MAX_TASK_PRIORITY

zero

(none)

omp_get_max_task_priority()

© 2015 OpenMP ARB  

omp_get_active_level()

omp_get_level()

---

---

omp_get_partition_num_places()
omp_get_partition_place_nums()
omp_get_place_num_procs() 
omp_get_place_proc_ids()

omp_get_cancellation()

Sec 4.5

Sec 4.11

Sec 4.13

Sec 4.14

OMP1115F

