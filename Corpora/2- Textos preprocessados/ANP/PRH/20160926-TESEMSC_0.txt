laborat orio nacional computa cient ıfica programa gradua modelagem computacional programa modular computa alto desempenho simulador reservat orios convencionais folhelhos rafael nardes moreira petr opolis rj brasil mar co programa modular computa alto desempenho simulador reservat orios convencionais folhelhos rafael nardes moreira disserta submetida corpo docente laborat orio nacional computa cient ifica parte requisitos necess arios obten grau mestre ciˆencias modelagem computacional aprovada prof 
 eduardo ucio mendes garcia 
 sc presidente prof 
 elson magalh aes toledo 
 jos roberto pereira rodrigues 
 petr opolis rj brasil mar co moreira rafael nardes mp programacao modular computacao alto desempenho simulador reservatorios convencionais gas folhelhos rafael nardes moreira petropolis rj 
 laboratorio nacional computacao cientifica 
 orientadores eduardo lucio mendes garcia sandra mara cardoso malta 
 dissertacao mestrado laboratorio nacional computacao cientifica 
 programacao orientada objetos 
 garcia eduardo lucio mendes 
 malta sandra mara cardoso 
 mct lncc iv 
 ladies gentlemen detected gravitational waves 
 david reitze caltech physicist ligo lab director 
 moment eyes sky couldnt hear music 
 szabolcs marka columbia university astrophysicist 
 iv dedicat oria dedico trabalho pais fernando maria helena 
 agradecimentos fam ılia namorada oferecem mim todo incentivo compreens pudesse esperar 
 orientador bidu incentivo trabalho disponibilidade proximidade durante ultimo ano 
 coorientadora sandra malta acompanhamento opini oes reuni oes peri odicas 
 professora carla osthoff acompanhamento trabalho interesse colaborar sugerindo ferramentas software bibliografia uteis trabalho 
 colega patr ıcia costa paciˆencia responder perguntas cada colocarse disposi pr oxima 
 professor roberto souto disponibilidade sempre solicitado prontid disponibilizar aquina experimentos quanto fez necess ario 
 demais professores programa osgradua lncc quais interagi aprendi durante dois ultimos anos 
 anp agencia nacional petr oleo natural biocombust ıveis apoio financeiro 
 vi resumo disserta apresentada lncc mct parte requisitos necess arios obten grau mestre ciˆencias 
 programa modular computa alto desempenho simulador reservat orios convencionais folhelhos rafael nardes moreira mar co orientador eduardo ucio mendes garcia 
 sc coorientador sandra mara cardoso malta 
 modelagem computacional reservat orios instrumento permite descri precisa fenˆomenos ısicos existentes processo recupera oleo tendo grande interesse tanto ind ustria quanto ciˆencia 
 ind ustria oleo grande demanda simuladores comerciais reservat orios 
 outro lado simuladores cient ıficos capazes oferecer pesquisadores dom ınio controle liberdade necess arios atividade acadˆemica 
 dentre principais demandas software cient ıfico geral est design escal avel relacionado desenvolvimento odigo maneira organizada modular contribuindo evolu execu escal avel relacionada implementa ecnicas computa paralela alto desempenho raz grandes massas dados manipuladas modelos ericos computacionalmente intensivos produzidos ciˆencia 
 trabalho trata emprego ecnicas programa modular orienta objetos computa paralela openmp mpi simulador cient ıfico escrito fortran utilizado modelagem erica problemas escoamento reservat orios convencionais folhelhos 
 vii abstract dissertation presented lncc mct partial fulfillment requirements degree master sciences 
 modular programming high performance computing gas shale reservoir simulator rafael nardes moreira march advisor eduardo ucio mendes garcia 
 sc coadvisor sandra mara cardoso malta 
 computer modeling reservoirs tool provides accurate description existing physical phenomena oil gas recovery process interest industry science 
 oil gas industry demand commercial simulators remarkable 
 time scientific simulators able provide researchers freedom control needed academic activity 
 among major demands scientific software scalable design correlated organized modular code development scalable execution related implementation techniques parallel high performance computing due large amount manipulated data computeintensive numerical models produced science 
 dissertation aims application techniques modular object oriented programming parallel computing openmp mpi scientific simulator developed fortran used numerical modeling problems related gas flow unconventional gasshale reservoirs 
 viii sum ario introdu 
 simula reservat orios lncc 
 modelo escalas fratura bloco 
 programa modular orienta objetos 
 computa paralela desempenho simulador 
 demandas evolu software cient ıfico 
 princ ıpios programa modular 
 justificativas vantagens desvantagens programa modular 
 programa orientada objetos 
 mem oria compartilhada 
 mem oria distribu ıda 
 ambientes computa paralela 
 refatora odulo simulador inclus paradigma ix orientado objetos 
 evolu simulador escoamentos meios porosos 
 organiza simulador arquivos compila separada 
 orienta objetos odulo sistemas equa oes 
 identifica entidades interesse 
 introduzindo atributos etodos classes 
 implementa orienta objetos fortran heran ca 
 implementa polimorfismo fortran 
 nova organiza simulador novos odulos contendo classes 
 paraleliza simulador escalas shale gas 
 alise inicial perfil serial desempenho aplica intel vtune 
 estrat egia paraleliza openmp 
 testes desempenho paraleliza openmp 
 ambiente execu metodologia testes 
 resultados experimento openmp 
 resultados experimento openmp 
 discuss resultados otimiza openmp 
 estrat egia paraleliza mpi 
 testes desempenho paraleliza openmp mpi 
 ambiente execu metodologia testes 
 resultados experimento openmpmpi 
 resultados experimento openmpmpi 
 discuss resultados mpi 
 conclus oes perspectivas referˆencias bibliogr aficas lista figuras figura 
 geometria realista reservat orio folhelhos 
 geometria idealizada reservat orio folhelhos 
 modelo fratura bloco 
 vetor est atico unico comportando ultiplos vetores menores diferentes tamanhos definidos tempo execu 
 organiza ıveis ultiplos arquivos fonte 
 organiza simulador arquivosfonte 
 estrutura asica classes sistemas estruturas dados 
 estrutura classes sistemas equacoes maiores detalhes 
 estrutura classes estruturas dados maiores detalhes 
 organiza simulador novos odulos fonte 
 percentual tempo total execu rotina solver gauss 
 percentual tempo total execu rotina solver intel pardiso 
 tempo total execu caso experimental solver gauss 
 tempo total execu caso experimental solver intel pardiso 
 alise rotina processadorbloco solver gauss 
 alise rotina processadorbloco solver pardiso 
 alise condi oes corrida feita ferramente intel inspector 
 organiza objetos sistemas estruturas dados vers paralelizada openmp 
 perfis press longo fratura metros mˆes meses anos 
 produ acumulada kg 
 speedups vers openmp experimento 
 speedups vers openmp experimento 
 tempos execu cada problema bloco experimento 
 tempos execu cada problema bloco experimento 
 speedups cl ausula schedule dynamic experimento 
 speedups cl ausula schedule dynamic experimento 
 tempos execu cada problema bloco fratura elementos malhas elementos bloco 
 inclina oes linhas tendˆencia figuras 
 fun tamanho malhas bloco 
 speedups cl ausula schedule dynamic experimento malhas bloco aumentadas elementos 
 speedups cl ausula schedule dynamic experimento malhas bloco aumentadas elementos 
 estrat egia paraleliza processos mpi 
 edias tempos execu minutos vers openmpmpi experimento 
 speedups vers openmpmpi experimento 
 edias tempos execu minutos vers openmpmpi experimento 
 speedups vers openmpmpi experimento 
 xiii lista tabelas tabela 
 parˆametros ısicos relativos campo realista utilizado testes 
 tempos execu minutos vers openmp experimento 
 tempos execu minutos vers openmp experimento 
 tempos execu minutos vers openmpmpi experimento 
 tempos execu minutos vers openmpmpi experimento 
 xiv lista siglas abreviaturas tad tipo abstrato dados mef etodo elementos finitos uc unidade controle ula unidade ogicoatitm etica cpu central processing unit vpu vector processing unit gpu graphics processing unit xv cap ıtulo introdu reservat orios convencionais folhelhos inglˆes shale gas reservoirs representam atualmente fonte energia altamente relevante muitos pa ıses 
 eua exemplo tais reservas podem representar importante papel autossuficiˆencia energ etica pa ıs dentro alguns anos 
 grande quantidade potenciais reservas deste tipo existentes inclusive brasil motiva justifica estudos area quais fazem ainda relevantes decorrˆencia necessidade emprego ecnicas explora espec ıficas adequadas caracter ısticas peculiares tais reservat orios baixa permeabilidade forma oes geol ogicas existˆencia ultiplos ıveis porosidade 
 modelagem computacional reservat orios instrumento permite descri precisa fenˆomenos ısicos existentes processo recupera tendo interesse tanto ind ustria busca explora eficiente ciˆencia assistindo desenvolvimento modelos ısicos matem aticos capazes relacionar grandezas envolvidas equa oes regem fenˆomenos ısicos 
 ind ustria oleo grande demanda simuladores comerciais exemplo cmg computer modeling group eclipse 
 entretanto simuladores cient ıficos tˆem caracter ısticas importˆancia pr oprias 
 simuladores cient ıficos oferecem cientistas pesquisadores dom ınio aplica oes flexibilidade possibilidades ajustes atendem forma adequada demandas espec ıficas 
 muitas vezes simuladores comerciais produtos completos englobam grande quantidade componentes alguns quais podem ser interesse trabalhos acadˆemicos 
 simuladores cient ıficos contraste frequentemente permitem maior liberdade realiza experimentos espec ıficos permitindo maior controle inclusive maior precis determinados casos interesse 
 trabalho trata emprego ecnicas programa modular computa alto desempenho simulador cient ıfico baseado implementa computacional etodo elementos finitos proposta hughes utilizado simula erica problemas escoamento monof asico reservat orios convencionais folhelhos acordo modelos ısico matem atico propostos costa 
 dentre motiva oes desenvolvimento deste trabalho est relativa carˆencia ˆambito desenvolvimento software cient ıfico principalmente comparado software comercial corporativo certos cuidados conhecimentos pr aticas suportem desenvolvimento ordenado modular escal avel software fato software cient ıfico geral demanda ecnicas computa alto desempenho tanto manipular grandes massas dados quanto estar associado frequentemente modelos ericos computacionalmente intensivos 
 segundo rouson al 
 caracter ısticas desej aveis software cient ıfico design escal avel obtido desenvolvimento ordenado odigo programa modular conceitos projeto software execu escal avel obtida uso ecnicas computa paralela alto desempenho 
 contribui deseja oferecer neste trabalho engloba portanto dois aspectos organiza est atica odigofonte execu 
 quanto primeiro aspecto trabalho compreende reestrutura odulos simulador referente constru solu sistemas equa oes lineares referentes etodo elementos finitos 
 desenvolvidos novos odulos incorporando paradigma programa orientado objetos substituir odulo original 
 incorpora conceitos orienta objetos pretendese promover facilita entendimento humano usabilidade funcionalidades providas novos odulos principalmente meio encapsulamento dados opera oes promovendo abstra detalhes 
 rela contribui trabalho refere computa alto desempenho utilizados padr oes programa paralela sistemas computacionais baseados mem oria unificada distribu ıda respectivamente openmp mpi desenvolvimento estrat egias paraleliza modelo adotado neste simulador 
 simula reservat orios lncc pesquisadores area etodos ericos equa oes diferenciais lncc tˆem trabalhado desde implementa oes etodo elementos finitos mef baseadas odigo apresentado hughes 
 implementa oes atendem demandas diferentes aplica oes cient ıficas todas tendo ponto comum modelos matem aticos recaem sobre solu erica equa oes diferenciais 
 dentre aplica oes utilizam etodo elementos finitos lncc est desenvolvidas grupo simula oes computacionais reservat orios petr oleo 
 grupo desenvolvido longo tempo simuladores relacionados ciˆencia escoamentos transportes meios porosos atendendo demandas internas espec ıficas seguindo processo continuamente evolutivo incorporando poucos fenˆomenos relacionados exemplo hidrodinˆamica transporte solutos processos geomecˆanicos 
 apesar alta demanda simuladores ind ustria lncc enquanto institui atuante area ciˆencia desenvolve simuladores cient ıficos tratam fenˆomenos espec ıficos sendo precisos casos 
 embora caracterizados existˆencia limita oes simuladores cient ıficos bancadas laborat orio servem grupo permitem experimentos maior liberdade 
 simulador reservat orios convencionais shale gas desenvolvido utilizado lncc possui projeto longo prazo 
 significa grupo cria grande simulador meta 
 entretanto novas funcionalidades tˆem sido incorporadas simulador passar tempo dando origem diferentes vers oes adaptadas atender diferentes demandas 
 embora contribui oes deste trabalho possam ser incorporadas diferentes vers oes deste outros simuladores similares baseados mesma implementa original mef compartilham odulo solu sistemas equa oes vers simulador utilizada neste trabalho compreende simula erica problemas escoamento monof asico reservat orios convencionais folhelhos blocos rocha matriz fraturas hidr aulicas induzidas acordo modelo proposto costa cujas linhas gerais abordadas 
 modelo escalas fratura bloco baixa permeabilidade forma oes geol ogicas onde ocorre shale gas implica necessidade indu fraturas processo faturamento hidr aulico constitu ıdo meio suficientemente perme avel onde possa fluir facilmente 
 modelos hidrodinˆamicos considerando dois ıveis porosidade microblocos fissuras induzidas constituem base estado arte modelagem reservat orios shale gas 
 interior fissuras provocadas faturamento fissuras induzidas podese modelar escoamento meio equa oes diferenciais regem escoamento monof asico fluido compress ıvel meio olido ıgido conforme modelo costa 
 microblocos rocha matriz atuam armazenando funcionam tal modelo fontes massa problema escoamento fraturas induzidas 
 simulador tomado ponto partida neste trabalho obedece modelagem ısica matem atica dom ınio desenvolvida costa 
 linhas gerais reservat orios folhelhos caracterizados perfura horizontal tratados nesse modelo sequˆencia blocos rocha matriz fraturas induzidas peri odicas igualmente espa cadas longo toda extens po co horizontal 
 idealmente fraturas devem ser consideradas entidades bidimensionais enquanto blocos devem ser considerados tridimensionais conforme ilustrado figura 
 podese observar escoamento radial fratura dire po co 
 geometria realista reservat orio folhelhos 
 entretanto modelo costa possui simplifica oes considerando alongamento interface fratura po co toda largura fratura eliminando hip otese escoamento radial 
 considerase flui fratura po co apenas dire 
 nova configura mostrada figura 
 geometria idealizada reservat orio folhelhos 
 desconsiderando escoamento radial fraturas modelo utiliza ainda redu dimens passa tratar fraturas linhas blocos planos 
 simula erica escoamento fratura modelo adota malha unidimensional elementos finitos passo bloco adotamse ultiplas malhas unidimensionais esquematizado figura 
 blocos atuam fontes massa problema fraturas 
 dado bloco cada arios problemas unidimensionais est relacionado ponto malha unidimensional problema fratura 
 modelo portanto caracterizase resolu umero elevado problemas elementos finitos independentes blocos resulta ultiplos sistemas lineares independentes 
 caracter ıstica ser visto cap ıtulo diretamente relacionada estrat egias paraleliza desenvolvidas 
 modelo fratura bloco 
 programa modular orienta objetos vers simulador tomada ponto partida neste trabalho ap evolu oes incrementais ultimos anos possui algum ıvel modularidade 
 odigofonte est subdividido odulos agrupam funcionalidades suficientemente relacionadas 
 apesar disso neste trabalho desejamos promover passo evolutivo quanto modularidade deste simulador cient ıfico avan co est relacionado reformula incorpora paradigma orienta objetos odulos 
 acordo rouson al 
 grande parte conceitos projeto software norteiam desenvolvimento ordenado eficiente programas est relacionada paradigma programa orientado objetos 
 refatora odulo quest envolve encapsulamento sistemas equa oes solvers estruturas dados relacionadas sistemas arcabou co orientado objetos oferecendo facilidades utiliza diferentes op oes solvers quais podem ser internos completamente implementados dentro aplica poco γx γfratura bloco cient ıfica cliente externos uso bibliotecas matem aticas desenvolvidas terceiros incluem solvers 
 est caso intel pardiso parte biblioteca intel mkl 
 maior modularidade especialmente manifestarse sob forma paradigma orienta objetos contribuir melhor usabilidade capacidade evolu deste simulador 
 conceitos centrais orienta objetos encapsulamento dados opera oes heran ca polimorfismo ser explorados odulo original dˆe origem outros menores sob forma classes quais relacionam forma tal possa promover facilita entendimento funcionalidades comportamento cada unidade software 
 classes funcionar entidades encapsuladoras contribuindo agrupamento dados opera oes relacionados entidades interesse representadas sistemas equa oes estruturas dados armazenamento matrizes esparsas realtivas sistemas cujos dados poder ser manipulados tipo solver 
 novo conjunto odulos orienta objetos permitir outros outros simuladores similares baseados mesma implementa original mef maior facilidade substitui solvers uso outras op oes facilitando promovendo maior isolamento trabalhos realizados incorpora solvers externos implementa novas alternativas internas neste quesito 
 computa paralela desempenho simulador entendimento modelo introduzido 
 percebese neste simulador existe situa convidativa desenvolvimento estrat egias paraleliza aproveitem total independˆencia ultiplos sistemas equa oes precisam ser resolvidos simula escoamento blocos 
 assim sendo neste trabalho propostas duas solu oes valem desse fato serem discutidas detalhes cap ıtulo 
 implementa paradigma orienta objetos funcionar facilitadora desenvolvimento tais solu oes quais ir envolver coexistˆencia ultiplos sistemas equa oes independentes mem oria 
 classes tornar tarefa natural intuitiva dada possibilidade ultiplas instˆancias objetos classe representa sistemas equa oes 
 ideia asica tr solu oes paralelas desenvolvidas neste trabalho poder ser enxergada abordagem granularidade grossa execu paralela modelo vez tratar paraleliza solvers sim execu simultˆanea arias instˆancias problemas completos cada demandando solu sistema independente 
 paralelismo estar portanto ıvel abstra acima implementa oes internas solvers 
 significa qualquer solver utilizado poder beneficiarse estrat egia paraleliza unica previamente desenvolvida 
 solu oes paralelas desenvolvidas utilizam padr oes programa paralela openmp mpi voltados sistemas computacionais mem oria unificada distribu ıda respectivamente 
 ambas ter mesma proposta asica permitir arias unidades execu threads processos resolvam paralelo arios problemas referentes blocos cada quais compreende duas etapas constru solu sistemas equa oes referentes implementa etodo elementos finitos 
 organiza disserta trabalho est organizado seguinte forma cap ıtulo apresentamos maneira conceitual duas grandes demandas software cient ıfico geral programa modular computa paralela fornecendo justificativas relevˆancia explorando conceitualmente importantes ecnicas desenvolvimento software visam atendˆelas 
 cap ıtulo descrevemos processo refatora odulo referente sistemas equa oes lineares 
 apresentadas evolu oes organiza est atica odigofonte quais odigo simulador escoamentos passou desde vers original seguida maior detalhamento evolu oes feitas neste trabalho incorpora paradigma orienta objetos 
 cap ıtulo descrito processo desenvolvimento solu oes paralelas utilizando openmp mpi simulador 
 realizados ainda testes desempenho interpreta cr ıtica resultados seguidas ciclo otimiza 
 finalmente cap ıtulo apresentadas conclus oes trabalho 
 cap ıtulo demandas evolu software cient ıfico neste cap ıtulo tratados forma geral duas grandes demandas frentes evolu software cient ıfico modulariza desempenho computacional 
 tais caracter ısticas est relacionadas tempo vida produtos software 
 naturalmente produtos efˆemeros necessitam geral apresentar tais caracter ısticas produtos software ciˆencia moderna cada vez menos frequentemente encaixam nessa categoria 
 deixa claro grandes problemas ciˆencia moderna recaem desenvolvimento modelos ısicos matem aticos combinam dinˆamicas diversas esferas conhecimento resolver problemas muitas vezes englobam fenˆomenos cujas escalas tempo espa co separadas arias ordens magnitude 
 constitui desafios ponto vista estabilidade consistˆencia acur acia simula oes computacionais cient ıficas 
 sendo assim notase caracter ısticas tamanho complexidade problemas ciˆencia moderna fazem produtos software tendam possuir longa vida longos ciclos evolutivos 
 primeira classe demandas software cient ıfico aparece notarmos ciˆencia baseia modelos evoluem tempo incorporam detalhes tornamse completos tamb complexos 
 assim software cient ıfico deve ser produto certo ıvel maleabilidade adaptabilidade facilidade incorpora funcionalidades capacidade evolu 
 tal tipo demandas traz consigo desafios relacionados diretamente organiza est atica estrutural odigofonte 
 adi referidas demandas estruturais existem demandas relacionadas desempenho execu 
 software cient ıfico est geral embasado modelos ericos computacionalmente intensivos quais frequentemente possuem alto custo computacional 
 entretanto todas simula oes cient ıficas precisam ser realizadas dentro limite tempo aceit avel satisfa ca expectativas usu arios 
 demandas relacionadas desempenho trazem desafios relacionados utiliza eficiente recursos hardware dispon ıveis 
 quer projeto desenvolvimento execu programas termo escalabilidade ganhado importˆancia discuss oes acerca software cient ıfico 
 dizemos software escal avel est preparado evoluir crescer incorpora novas funcionalidades aumento desempenho torna capaz manipular eficiˆencia carga crescente trabalho meio utiliza aximo poss ıvel recursos computacionais dispon ıveis 
 nesse contexto rouson al 
 anuncia dois tipos escalabilidade escalabilidade design escalabilidade desempenho execu 
 escalabilidade design refletese projeto software voltado crescimento evolu 
 projetar maneira escal avel resulta processo desenvolvimento escal avel vez faz notar odigofonte 
 frequentemente desej avel software cient ıfico odigo compreens ıvel boa usabilidade adaptabilidade facilidade expans 
 odigo apresenta tipo escalabilidade desenvolvido forma ordenada modular oferecendo facilidades entendimento humano trabalhos evolu expans futuras 
 quanto execu desenvolver odigos desempenho escal avel significa desenvolver odigos capazes apenas beneficiarse aximo poss ıvel recursos computacionais dispon ıveis tamb ter ganhos desempenho caso recursos hardware disponibilizados 
 dadas caracter ısticas hardware atual veremos odigos desempenho escal avel exploram paralelismo forma eficiente 
 pr oximas oes deste cap ıtulo exploraremos conceitos dois opicos diretamente relacionados escalabilidades design execu programa modular computa paralela respectivamente 
 programa modular desenvolvimento software epoca primeiros computadores digitais fun enormes limita oes aquinas daquele tempo marcado ecnicas visavam extrair aximo recursos computacionais dispon ıveis 
 todo paradigma desenvolvimento privilegiava poderia boa ordena organiza fluxo execu programas detrimento performance 
 pr atica comum negligenciar caracter ısticas relacionadas ordena clareza odigo escrito fun necessidade construirse fluxo execu eficiente poss ıvel 
 umero vari aveis programa exemplo precisava ser controlado rigor fazemos hoje programa moderno 
 precisavase limitar umero vari aveis economia uso mem oria 
 sabemos ponto vista puramente pr atico problema algum mesma vari avel assuma diferentes funcionalidades longo programa 
 entretanto dif ıcil perceber fato vari avel possuir arias fun oes longo odigo pode representar preju ızo entendimento vez impossibilita utiliza nome vari avel relacionado funcionalidade espec ıfica 
 programas epoca primeiros computadores portanto desenvolvidos quase inteiramente foco viabilidade termos desempenho funcionalidade epoca constitu ıa grande desafio 
 bloco monol ıtico odigo apresenta comum programa computador dessa epoca 
 dividir programa arios blocos oes odigo demandava gerenciamento mem oria custoso epoca 
 caracter ısticas faziam programas escritos geralmente apenas programador vez podia ter oes minimamente independentes 
 medida computadores ambientes programa linguagens evolu ıram programas tamb crescendo tamanho complexidade 
 cada vez problemas maiores complexos podiam ser resolvidos meios computacionais menor esfor co 
 ind ustria servi cos ciˆencia passaram somente explorar inclusive depender fortemente sistemas computa realiza muitas atividades 
 dessa forma fica claro software passava demandar ıveis altos qualidade confiabilidade riscos relacionados utiliza controlados minimamente toler aveis 
 acompanhando evolu recursos computacionais veio mudan ca fator limitante fator inibidor desenvolvimento software varej 
 recursos computacionais avan caram forma permitir certo conforto desenvolvedores 
 necess ario guiar desenvolvimento software majoritariamente quest oes relacionadas viabilidade ecnica 
 recursos computacionais passaram ser limitadores quanto otimiza trabalho pr oprios programadores 
 produtividade tornava fator chave 
 precisavase buscar aperfei coamento processo desenvolvimento traria apenas maior produtividade tamb maior confiabilidade produto desenvolvido 
 conceito programa monol ıtico unico desenvolvedor passou ser adequado nova realidade 
 programas passavam ser cada vez maiores complexos cr ıticos 
 grandes equipes desenvolvimento necess arias precisavam ser cada vez produtivas 
 deviam buscar ecnicas permitissem cria novos programas forma eficiente divis trabalho facilita reutiliza trabalho anterior 
 problemas complexos podem geral ser reduzidos conjunto subproblemas menores solu oes independentes 
 estrat egia dado nome dividir conquistar 
 ado permite apenas divis trabalho integrantes equipe desenvolvimento tamb favorece reutiliza solu oes implementadas varej 
 solu unica problema grande complexo dificilmente ser reutilizada solu oes subproblemas associados podem ser reutilizadas maior facilidade dado arios problemas complexos podem possuir passos intermedi arios subproblemas comum cuja solu sido implementada momento anterior 
 princ ıpios programa modular embora programas computador possam ser simplesmente entendidos sequˆencias instru oes realidade bastante diferente faz ver sob otica linguagens programa alto ıvel fortran java 
 conjuntos instru oes indivis ıveis programas compostos elementos certo grau complexidade possuem algum significado entendimento humano 
 tais elementos vez podem ser compostos outros menores 
 todos combinados constituem todo chamamos programa sistema software 
 considerandose grande variedade linguagens paradigmas programa al diferentes granularidades elementos componentes podem apresentar sob diferentes formas fun oes procedimentos tipos dados classes arquivos fonte citar alguns exemplos 
 longo deste texto utilizamos termos elementos programa software unidades programa software maneira indistinta sentido generalizado qualquer defini restritiva forma possam referir quaisquer componentes sistema software 
 segundo von staa programas porte edio diante necessitam ser particionados segmentos odigo minimamente independentes 
 desenvolvimento programas porte suficientemente grande essencial promova organiza ambiente trabalho minimizando umero falhas consequentes perdas geradas retrabalho corrigilas 
 programa modular instrumento capaz oferecer maiores garantias desenvolvimento dar maneira organizada von staa 
 ideia define princ ıpio fundamental programa modular particionar odigofonte aproxima estrat egia dividir conquistar 
 desenvolver software modular basicamente desenvolver software promovendo particionamento odigo encapsulamento dados processos ultiplas unidades software cada correspondendo parcela odigo certo grau independˆencia gera manipula edi 
 unidades software respons aveis segmenta odigofonte programa modular recebem nome odulos fonte 
 adiante exploraremos conceito odulo adotado literatura ser discutidas detalhes ecnicas implementa programa modular 
 nesse momento interessados apenas promover entendimento odulos enquanto unidades rompem conceito programa monol ıtico indivis ıvel confrontando programa monol ıtica programa modular 
 hora suficiente pensemos conceitualmente odulos oes odigo certo grau independˆencia encapsulam processos solu subproblemas encapsulam dados representam certos aspectos dom ınio modelado forma apresenta odulos car ater secund ario entendimento conceitua essencial programa modular 
 fator encapsulamento propriedade certos elementos programa agruparem interior dados algum grau logicamente relacionados processos operam sobre dados 
 relevante aqui forma cada odulo ter vez pode estar fortemente conectado caracter ısticas espec ıficas certas tecnologias linguagens programa 
 deve sim ser observado maior destaque forma particionamento odigo associado encapsulamento promovido odulos pode contribuir solu eficiente problemas grandes complexos 
 particionamento odigo faz solu problema complexo possa ser decomposto solu muitos problemas menores simples forma coordenada promovendo divis trabalho organiza facilita entendimento humano 
 encapsulamento vez ajuda tornar invis ıvel usu arios detalhes desnecess arios implementa levando rompimento barreiras complexidade 
 estudo linguagens programa odulo frequentemente definido elemento software corresponde unidade suficientemente individualizada ponto possa ser desenvolvida compilada separadamente demais partes comp oem sistema software todo 
 von staa varej defini oes adotadas seguem caminho conceituando odulos unidades compil aveis forma independente 
 odulo pode conter diversos elementos classes procedimentos fun oes declara oes tipos constituindo todos juntos unica unidade compila 
 embora ambos autores dado destaque semelhante quesito compila individual von staa deixa claro existe consenso absoluto literatura acerca conceito odulo 
 abstra oes segundo varej abstra conceito importante vastamente utilizado todas areas ciˆencia sendo suma importˆancia resolu problemas complexos 
 modelagem representa realidade posterior resolu problema interesse tarefa comum ciˆencia 
 devemos perceber representa realidade jamais poder ser feita toda riqueza detalhes 
 abstra permite representar forma seletiva apenas aspectos realidade fundamentais resolu problema interesse escondendo detalhes irrelevantes determinado contexto 
 area linguagens programa varej estabelece duas perspectivas asicas quais abstra insere 
 primeiramente simples utiliza linguagem programa alto ıvel representa ıvel abstra 
 trabalho programador suficiente enxergue computador aquina capaz entender comandos linguagem programa alto ıvel ainda verdade 
 programador est nesse momento abstraindo hardware linguagens baixo ıvel dado detalhes irrelevantes contexto trabalho 
 segunda perspectiva onde utilizase conceito abstra entendimento linguagens programa oferecem programador meios necess arios tamb crie pr oprias abstra oes 
 nessa perspectiva faz clara forte rela abstra oes programa modular 
 odulos elementos componentes entidades capazes promover abstra oes 
 abstra oes criadas programador podem ser usadas outros programadores diferentes momentos resolu diferentes problemas 
 devese perceber conhecimento implementa interna todos odulos outros elementos programa modelam solu subproblemas muitas vezes fundamental resolu problema maior interesse 
 assim podemos dizer odulos podem ter implementa interna abstra ıda programadores 
 programador interessado resolver dado problema computacional pode fazer uso arios odulos conhecer coisa alguma sobre implementa interna desde conhe ca bem funcionalidade oferecida forma devem comunicar mundo exterior interface 
 interface constitui conjunto regras padr oes possa estabelecer comunica elementos 
 assinatura fun exemplo estabelece padr meio argumentos fun poder trocar dados meio exterior representando portanto interface 
 acordo varej programas computador podem ser definidos conjuntos instru oes descrevendo realizar processos manipular alterar produzir dados 
 considerando defini anterior sabendo papel odulos enquanto elementos capazes promover abstra oes meio encapsulamento processos dados podemos classificar abstra oes criadas programador dois tipos abstra oes processos abstra oes dados 
 abstra oes processos abstra oes processos sobre fluxo controle programas tratam encapsular seq uˆencias instru oes comandos descrevem processo 
 elementos programa utilizados feita abstra processos subprogramas 
 al encapsular odigo definem regi oes limitados dentro programa onde podemos criar vari aveis constantes tipos utiliza escopo local 
 subprogramas podem ser tipo fun procedimento 
 fun oes representam abstra oes express oes possuem valor retorno 
 procedimentos representam abstra oes comandos vez apenas encapsulam fluxo controle definindo novo comando passa ser dispon ıvel usu arios 
 contraste fun oes procedimentos retornam valores 
 ponto comum subprogramas geral atuam sentido aumentar conjunto instru oes oferecidos linguagem programa uso conceito abstra oes 
 interface meio conjunto regras defini oes odulos elementos constituintes classes procedimentos fun oes comunicam usu ario outros elementos 
 programador escreve subprogramas fun oes procedimentos est criando abstra oes sentido esconde encapsula detalhes implementa determinado fluxo execu 
 est sendo providas novas funcionalidades reutiliza facilitada futuro 
 abstra oes criadas programador forma subprogramas acabam estender funcionalidades conjunto instru oes oferecidos linguagem programa 
 combinam comandos express oes forma oferecer outros novos 
 qualquer momento futuro programador pode fazer uso abstra oes pensar resolver problemas maiores 
 nesse momento poder ter aten oes focadas ıvel alto resolu problema interesse cujas etapas resolu podem ser facilmente resolvidas uso subprogramas 
 abstra oes dados abstra oes dados forma similar abstra oes processos combinam arios dados forma oferecer novo dado tipo dado 
 embora ainda ıvel bastante baixo enxergarmos mem oria computador conjunto elulas mem oria elulas mem oria vez cole oes bits fazendo abstra dados 
 todas linguagens programa alto ıvel oferecem abstra oes dados ıvel alto fornecerem tipos dados inteiros ponto flutuante vetores 
 programadores linguagens alto ıvel utilizam tipos dados pensar forma fato armazenados mem oria 
 podemos observar apenas abstra oes dados oferecidas linguagens programa demonstraram suficientes programa qualidade 
 preciso permitir programadores criem pr oprias abstra oes combinando dados dispon ıveis forma dar origem pr oprios tipos dados 
 tipos dados listas pilhas filas exemplos abstra oes dados criadas programador 
 justificativas vantagens desvantagens programa modular programa modular traz consigo erie vantagens processo desenvolvimento software 
 nesta ser apresentadas justificativas suporte emprego 
 facilita rompimento barreiras complexidade al permitir distribui trabalho adotar estrat egia dividir conquistar 
 sabemos problemas grandes complexos tˆem muitas vezes solu facilitada pensados erie problemas menores serem solucionados odulos independentes 
 odulos independentes podem ser desenvolvidos diversos programadores trabalhando paralelo 
 identificase nesse sentido potencial economia tempo desenvolvimento vez arias pessoas poder trabalhar paralelamente desenvolvimento programa 
 permite uso odigo 
 odulos podem idealmente devem ser constru ıdos forma possam ser usados outros programas 
 programadores desenvolvem odulos forma bem documentada deixando funcionalidade clara potenciais clientes podese obter consider avel economia esfor co trabalho 
 comum programas projetos diferentes podem valer odulos provedores funcionalidades demandadas recorrentemente desenvolvimento programas 
 considerarmos programas pertencentes dom ınio aplica tendˆencia uso ainda vantajoso 
 comum empresas institui oes desenvolvam arios produtos software dentro dom ınio aplica 
 desenvolver software modular pode representar constru ativo software permite corpora oes serem velozes competitivas desenvolvimento sistemas 
 permite desenvolvimento incremental gerencimento processo desenvolvimento software 
 programa modular facilita estabelecimento muitas baselines odulos fonte 
 significa ter maior grau controle altera oes realizadas 
 odulos entregues podem ter altera suficientemente controlada evitando contratempos advindos altera oes indisciplinadas odigo 
 medida novos odulos odulos existentes alterados sistema software todo evolui maneira incremental 
 cada nova itera representa nova vers denominada construto 
 dessa forma programa modular torna natural evolu incremental programas 
 reduz custo compila 
 considerarmos odulos unidades independentemente compil aveis fica claro altera oes pontuais certos odulos ir requerer todo programa recompilado 
 projetos pequeno porte compila pode representar tarefa custosa grandes projetos pode requerer grandes esfor cos consumir tempo programadores 
 permite otimiza oes desempenho feitas maneira gradual 
 odulos programa podem ser perfeitamente funcionais ainda idealmente otimizados 
 primeiro momento desenvolvedores podem estar interessados desenvolver unicamente vers funcional programa 
 cada odulos pode ainda passar individualmente processo evolutivo diz respeito desempenho 
 modulariza oferece maior flexibilidade decis quais odulos devem ser otimizados quais momentos longo processo desenvolvimento 
 oferece possibilidade decida todos odulos precisam realmente ser otimizados 
 comum depare situa oes quais poucas tarefas representam grande parte custo computacional programa todo 
 nesse caso esfor cos otimiza podem ser concentrados odulos custosos computacionalmente 
 existem entretanto contrapartidas advindas utiliza programa modular 
 algumas responsabilidades compromissos precisam ser assumidos programadores preciso pensar forma modular estar disposto desenvolver odigo mente 
 significa estar disposto particionar odigo provendo funcionalidades pare ca forma apida resolver problema imediato 
 necess ario especificar odulos idealmente document alos forma facilitar utiliza mesmos outros programadores 
 interessados encapsulamento odigo interessa usu arios precisem ler odigofonte compreender funcionalidade cada odulo 
 preciso tomar decis oes justificadas sobre particionar odigo abstrair abstrair 
 saber identificar potenciais trechos odigo alta possibilidade reutiliza cujo entendimento humano dif ıcil fundamental nessa tarefa 
 preciso saber dividir tarefas forma eficiente garantindo trabalho programador afete interven oes demais integrantes equipe 
 preciso conhecer interfaces odulos bem respeit alas 
 sobretudo necess ario bom projeto arquitetura processo desenvolvimento dˆe forma ordenada possam ser auferidos benef ıcios esperados programa modular 
 preciso sabe forma poder ser assegurada qualidade tudo produzido partir integra diversos odulos 
 visto existem algumas responsabilidades serem assumidas programadores interessados desenvolver software modular 
 muitas vezes podem questionar exemplo sobre qu justific avel programa modular qu dispendiosos ser esfor cos determinar exatamente deve ser particionado odigo programa quais ser formas apresenta odulos deve ser especificado cada odulo deve dar intera diversos odulos programa quais ser regras 
 casos programa ser desenvolvido objetiva resolver computacionalmente problema grande propor alta complexidade cen ario favor avel programa modular 
 nesses casos onde barreiras complexidade intimidam programador praticamente natural pense maneira modular dada dificuldade resolver problema todo vez 
 problemas menos complexos entanto compreens ıvel programador sinta tentado seguir ogica monol ıtica 
 frequentemente deseja fazer decis oes projeto pensar segmenta odigo deve dar 
 apesar sempre programa modular parecer atrativa programadores situa oes quais realmente vale pena restritas 
 problema ser resolvido apresente muita complexidade programa modular oferece benef ıcios al supera barreiras complexidade 
 von staa apresentada justificativa econˆomica programa modular baseada etodos estima tamanho esfor co custo desenvolvimento programas 
 etodos empregados est baseados erie parˆametros obtidos meio estat ısticas colhidas grande umero projetos reais 
 estudo confronta esfor co desenvolvimento modular esfor co monol ıtico considerando diferentes parˆametros exemplo tamanho programa linhas odigo umero odulos tamanho edio odulos 
 conclus tal estudo exceto programas pequenos esfor co programa modular bastante menor esfor co monol ıtico consideramos esfor cos adicionais advindos necessidade especifica implementa interfaces integra diferentes odulos 
 somase fato conforme tamanho programa aumenta diferen ca esfor co duas formas desenvolvimento torna evidente sempre favor abordagem modular 
 ecnicas modulariza programas grande porte caracterizados envolver grande umero linhas odigo grandes equipes desenvolvimento geralmente constituem solu computacional complexa problemas igualmente complexos 
 exposto padr programa monol ıtico adequado tipo sistemas 
 assistir principalmente desenvolvimento desse tipo programas desenvolvidas ecnicas modulariza 
 ecnicas tratam implementar odigo conceitos programa modular discutidos aqui segmenta odigofonte encapsulamento abstra oes 
 embora foco principal assistir desenvolvimento grandes programas muitas ecnicas deixam ser uteis programas pequeno porte 
 visto anteriormente estudo linguagens programa odulos entendidos unidades software compil aveis separadamente 
 cada odulo pode ser composto arios elementos distintos fun oes procedimentos vari aveis constantes tipos 
 elementos reunidos odulo est alguma forma relacionados possuem objetivo comum 
 acordo varej odulos bem projetados possuem unico objetivo claro bem boa defini interface demais odulos 
 entendimento prop osito odulo conhecimento exato funcionalidades oferecidas preocupa usu ario 
 forma objetivo atingido entretanto preocupa implementador 
 usu ario entendemos programador ir utilizar recursos odulo desenvolvimento outro elemento software pode ser exemplo outro odulo programa completo 
 podemos dizer elementos clientes odulo quest 
 seguir exploraremos algumas ecnicas modulariza abordagem independente linguagem programa 
 ser apresentadas principais estrat egias implementa desenvolvidas pudesse desenvolver programas forma compartimentada organizada eficiente uso abordagem monol ıtica 
 estrat egias podem aplicar internamente unico arquivo odigofonte subdividir programas ultiplos arquivos compila separada 
 subprogramas desenvolvimento conceito subprogramas procedimentos fun oes representou primeiro passo desenvolvimento software pudesse caminhar dire programa modular 
 subprogramas permitem particionamento programa diversas oes odigo logicamente relacionadas 
 ideia cada subprograma represente claramente funcionalidade bem definida funcionando instrumento abstra processos conforme visto 
 subprogramas portanto jamais devem ser entendidos instrumentos modulariza particionam odigo levando conta extens resultaria modulariza baixa qualidade 
 existe raz subprogramas tamanhos semelhantes 
 deve ser levado conta identifica funcionalidades possam ser clientes todos elementos programa fazem uso funcionalidades dados providos outros elementos 
 uso subprogramas evita trechos odigo exaustivamente repetidos longo programa facilita uso odigo 
 determinado processo fluxo execu precisa ser realizado muitas vezes poss ıvel ter ultiplas chamadas unico subprograma 
 facilita somente implementa tamb manuten programa 
 momento altera processo implementado subprograma precisa ser feita ser poss ıvel alterar odigo forma localizada 
 contraste programas trechos odigo exaustivamente repetidos demandariam busca exaustiva todas ocorrˆencias trecho altera 
 subprogramas permitem ainda processo descrito mesmos aplicado sobre conjuntos dados diferentes 
 poss ıvel gra cas processo parametriza meio podemos fornecer dados subprogramas 
 dessa forma procedimentos fun oes podem operar sobre dados diferentes cada chamada resultando respectivamente comportamentos valores retorno distintos 
 pacotes desenvolvimento grandes sistemas software implementar modulariza exclusivamente meio subprogramas geral estrat egia considerada suficiente 
 tipo modulariza acaba promovendo segmenta odigo granularidade fina 
 caso sistemas grandes faz umero grande elementos programa espalhados odigo 
 necess ario haver ıvel modulariza granularidade maior 
 al disso dado programa modular marcada uso odigo notase especialmente grandes sistemas existe grande possibilidade conflitos nomes elementos diversas fontes odigo reutilizados 
 preciso alguma forma solucionar conflitos nome 
 pacotes elementos programa nome pr oprio agrupam diversos outros elementos sendo alguns vis ıveis usu arios outros 
 tempo representam forma modulariza granularidade grossa elementos capazes resolver conflitos nome justamente fato possu ırem nomes pr oprios 
 existir conflito nomes elementos provenientes ultiplas fontes odigo sendo fontes ultiplos pacotes poss ıvel especificar corretamente pacote elemento quer acessar 
 basta utilize especifica completa nome inclui nome pacote nome elemento componente quest 
 tipos dados discutido 
 novos tipos dados representam abstra oes dados feitas programador 
 unem cole dados relacionados unico elemento programa 
 usu arios desses tipos dados podem enxerg alos todo coeso necess ario pensar implementados 
 dados tipo registro struct structure record fortran posteriormente substitu ıdos declara type denominados tipos dados simples 
 tipo modulariza consiste reunir combinar grupo dados relacionados unica entidade encapsuladora nomeada 
 grupo dados nomeado pode assim ser tratado todo vantagens incluem facilita uso melhor legibilidade odigo 
 principal ponto fraco desse tipo modulariza permitir ocultamento informa visto acesso dados internos tipo livre usu arios 
 ocultamento dados permitido tipos abstratos dados ser discutido seguir 
 vez tipos abstratos dados tads elementos software quais determinada estrutura dados criada representar novo tipo 
 tornada conhecida somente atrav es opera oes realizadas sobre dados 
 implementador tad decide ir representar valores tipo abstrato implementa conjunto opera oes forma fun oes procedimentos operam sobre dados novo tipo 
 implementa tads necess ario linguagem forne ca recursos ocultamento informa tornando implementa interna tad invis ıvel usu ario normalmente feito especifica interface 
 nela expostos somente componentes devem ser ublicos geral apenas opera oes oferecidas tad sendo dados internos invis ıveis usu arios 
 estrat egia tornar ublicas apenas opera oes manter dados inacess ıveis usu arios information hiding implica conjunto valores internos tipo acessado modificado sempre maneira indireta exclusivamente execu opera oes consultoras atualizadoras respectivamente 
 opera oes atualizadoras podem ainda proteger dados contra altera oes feitas maneira incorreta impedindo dados assumam valores indevidos 
 opera oes consultoras atualizadoras frequentemente denominadas getters setters mutators accessors forma geral fun oes acesso 
 usu ario portanto apenas utiliza tad caixa preta resolver problema acesso direto dados 
 al opera oes acesso tads frequentemente existem opera oes construtoras destrutoras 
 acordo varej construtoras respons aveis criar inicializar tads devem ser executadas antes quaisquer outras opera oes garanta perfeito funcionamento mesmas 
 opera oes destrutoras utilizadas uso tad necess ario respons aveis atividades finaliza dentre quais destacase desaloca regi mem oria utilizada tad 
 ultiplos arquivos compila separada ecnicas modulariza abordadas momento podem ser aplicadas modulariza programas arquivo fonte unico 
 crescimento programas entretanto tipo abordagem come ca tornarse invi avel vez traz problemas pr aticos tanto desenvolvimento quanto manuten uso odigo 
 programadores frequentemente encontram dificuldade tˆem produtividade comprometida escrita manuten programas grandes propor oes completamente contidos unico arquivo fonte 
 todas vezes faz necess aria altera odigo fonte unico extenso arquivo fonte deve ser examinado programador fim encontre regi precisa ser alterada 
 dois programadores pretendem alterar cada parte espec ıfica programa precisar alterar arquivo fim trabalho haver esfor co adicional possa unir altera oes feitas ambos 
 trabalho programador precisa ser interrompido retomado temse custo adicional novamente vasculhe extenso arquivo fim encontrar local partir trabalho deve continuar 
 outra quest relevante nesse contexto fato muitos elementos programa programa podem ser reutilizados somente dentro programa unico tamb programas distintos 
 comum tanto empresas quanto comunidade cient ıfica grupos pessoas interessadas desenvolver aplica oes algum grau semelhan ca interajam si 
 muitas aplica oes diferentes podem compartilhar trechos comum 
 programas unico arquivo fonte dificultam processo uso pois exigem funcionalidade ser utilizada outros programas localizada dentro extenso arquivo copiada programa far uso mesma 
 naturalmente dividir programas arquivos separados surge solu problemas citados 
 cada arquivo pode conter trechos odigo associados funcionalidade grupo funcionalidades suficientemente relacionadas segundo algum crit erio ogico divis fa ca sentido equipe desenvolvedores 
 pr oprios arquivos acabam funcionando indexadores programadores encontrem rapidamente regi oes odigo desejam reaproveitar onde desejam realizar altera oes 
 entretanto ultiplos arquivos si resolvem problema comum grandes projetos software custo compila 
 programas pequenos custo tempo compila pode muitas vezes ser negligenciado 
 grandes projetos custo tempo compila todo odigo torna algo impactante produtividade programadores 
 adotase estrutura modulariza arquivos interesse poss ıvel compila separado cada odulos fonte forma altera oes localizadas odulos espec ıficos necess ario recompilar todo odigofonte somente somente odulos alterados 
 conforme destacado varej possa permitir compila separado odulos surge necessidade certo relaxamento verifica erros parte compilador 
 consideremos ıtulo exemplo determinado arquivo fonte escrita cole procedimentos fun oes serem utilizadas outros arquivos fontes clientes 
 feitas altera oes unidades clientes interessante possam ser recompiladas requerida recompila arquivo cont cole subprogramas utilizados 
 recompila sendo feita exclusivamente unidades clientes alteradas compilador poder verificar todas subrotinas utilizadas fato existem odulos onde supostamente devem estar implementadas 
 preciso saber rotinas est sendo utilizadas maneira correta quanto tipo argumentos passados exemplo 
 compila separado possa coexistir verifica tipos estrat egia usada muitas linguagens programa subdividir cada odulos fonte dois arquivos arquivo interface arquivo implementa 
 arquivos odulos interface tamb chamados odulos defini existem somente declara oes defini oes elementos vari aveis tipos subprogramas ser usados arquivos odulos clientes 
 arquivos implementa odulos implementa vez onde est contidas todas implementa oes completas elementos software declarados arquivo interface 
 odulos clientes faz usualmente importar apenas arquivos defini header files 
 inclus odulos defini gera impacto praticamente desprez ıvel custo compila unidades clientes visto tais odulos correspondem apenas defini oes vari aveis constantes tipos assinaturas subprogramas 
 apesar baixo custo compila arquivos defini possuem informa oes suficientes possa realizar verifica tipos 
 sendo assim inclus odulos defini todos arquivos clientes compila tornase al apida segura 
 unidades clientes podem ser recompiladas separado preciso realizar recompila odulos implementa utilizados cuja compila custosa tampouco necess ario abrir rigor verifica oes erro compilador 
 processo compila programas divididos arios arquivos odulos implementa fornecidos compilador originam cada odulos compilados correspondente odulo objeto 
 finalmente odulos objeto integrados programa especial ligador linker respons avel unir arquivos objeto gerar unico arquivo execut avel 
 programa orientada objetos orienta objetos paradigma desenvolvimento programas particularmente interessante precisase modelar resolver odulo defini elemento cont apenas odigo defini interface odulo fonte 
 odulo implementa elemento implementa fato todas funcionalidades providas odulo fonte encapsulando todo odigo mesmas 
 computacionalmente problemas possam ser expressos termos diversos conjuntos dados minimamente relacionados submetidos conjuntos opera oes 
 deve fato programa orientada objetos fortemente focalizada entidades mundo real processos opera oes realizados tais entidades quais dados sujeitam 
 classes podem representar maneira eficiente entidades mundo real 
 permitem defini novos tipos oferecendo meios encapsulamento dados oprea oes sobre dados 
 primeiros sob forma atributos ultimas forma procedimentos fun oes denominados etodos 
 estrutura classes assemelha decomposi programas odulos entretanto diferente odulos quais podem ser simplesmente arquivos contendo cole oes fun oes classes podem ser instanciadas correspondendo cada instˆancia objeto mem oria 
 classes funcionam modelos cont informa oes necess arias aloca dados objetos inicializa atributos 
 vimos tipos abstratos dados tads programadores capazes criar novos tipos promovendo encapsulamento dados processos ocultamento informa prote dados 
 boa parte linguagens programa estrutura dividir odulos fonte dois arquivos interface outro implementa discutida 
 estrat egia adotada implementa tads 
 advento linguagens programa orientadas objetos classes surgiram nova maneira implementar tads 
 classes oferecem todos recursos tads encapsulamento dados processos ocultamento informa fun oes acesso opera oes construtoras destrutoras 
 al oferecerem todos mecanismos necess arios implementa tad classes oferecem prote dados meio modificadores acesso apresentam benef ıcios legibilidade redigibilidade objeto instˆancia classe 
 podese instanciar construir criar ultiplos objetos mem oria partir unica classe confiabilidade varej 
 segundo von staa utiliza linguagens programa orientadas objetos tomandose algum cuidado projetar classes poss ıvel tornem integralmente utiliz aveis diferentes programas viabilizando uso quantidades significativas odigo 
 autor destaca tal forma uso verbatim est principais formas redu custos melhoria qualidade software 
 motiva contribui oes presente trabalho cria arcabou co recursos paradigma programa orientada objetos odulo simulador cient ıfico potencial uso outros programas 
 cap ıtulo ser abordada refatora odulo 
 classes tornam ainda especiais opera oes construtoras destrutoras 
 opera oes construtoras classes chamadas etodos construtores executadas instˆancia objeto classe respons aveis basicamente inicializar campos classe valores neutros exemplo zero caso membros valor erico valor null caso ponteiros 
 alternativamente podem ser atribu ıdos valores significado valor indefinido facilmente detect aveis localiza erros inicializa caso campos venham ser usados antes atribu ıdo qualquer valor 
 etodos destrutores vez respons aveis opera oes finaliza realizadas uso classes necess ario 
 dentre tais opera oes comum desaloca regi oes mem oria objetos ser usados 
 tads modelagem arias entidades mundo real aspectos comum produz aspectos indesej aveis resolvidos uso classes 
 representar exemplo entidades pessoa aluno professor tads precisamos tipos dados muitos atributos comum 
 aluno professor ambos pessoas 
 entanto uso tads podemos representar uso verbatim forma uso feitas altera oes unidade reutilizada 
 entidades aluno professor aproveitando comum duas tamb entidade pessoa 
 cria enorme quantidade replica odigo 
 orienta objetos podese criar estruturas classe baseadas heran ca conceitos fundamenais orienta objetos lado polimorfismo 
 heran ca heran ca relacionamento classes onde classe denominada herdeira classe filha especializa refina torna particulares propriedades outra classe denominada superclasse classe ae 
 exemplo citado anteriormente entidades pessoa aluno professor representadas classes poderiam configurar rela heran ca 
 classes aluno professor herdeiras classe pessoa possuem mesmos atributos etodos classe pessoa 
 dizse rela heran ca transitiva pois classe herdeira pode vez ser superclasse outras herdeiras 
 exemplo professor herda pessoa pode ser superclasse herdeiras professorsubstituto professortitular 
 membros adicionais podem existir classes herdeiras visto especializam superclasses 
 caso citado tanto aluno professor herdariam exemplo atributos nome sobrenome superclasse pessoa 
 aluno poderia implementar membros nota nota etodos aprovar reprovar professor vez poderia implementar membros salario datadeadmissao etodo calcularsalario 
 qualquer objeto instanciado superclasse pode ser refinado imposi tipos type casting objeto classe herdeira 
 instanciarmos objeto pessoa classe pessoa pode ser especializado casting tipos objeto tipo aluno pois todos membros aluno conhecidos objeto classe pessoa 
 criarmos vez disso objeto aluno classe aluno poder ser promovido objeto classe pessoa inclusive ser posteriormente refinado novamente aluno jamais professor 
 polimorfismo outro conceito extremamente importante paradigma orientado objetos diretamente relacionado conceito heran ca polimorfismo palavra cujas origens gregas remetem ideia muitas faces 
 conceito heran ca permite etodos superclasses redefinidos classes herdeiras 
 nesse contexto redefinir significa escrever novamente tais fun oes assinaturas idˆenticas implementa oes internas peculiares cada classes filhas 
 fun oes dessa natureza ditas fun oes polimorfas constituem tipo polimorfismo comum implementado maioria linguagens programa denominado polimorfismo universal subclasses 
 imaginemos estrutura superclasse pol ıgono duas classes herdeiras quadrado triangulo quais possuem implementa oes distintas etodo calculararea assinatura idˆentica 
 defini sobre implementa ser aplicada depende classe objeto quest etodo aplica 
 acordo von staa propriedade promove facilidades programa visto pr oprio objeto determina deve ser processado retirando programador responsabilidade determinar forma objetos devem ser processados dependendo classe 
 al caso discutido polimorfismo pode aparecer ainda outras maneiras 
 caso etodo implementado arias vezes assinaturas diferentes ocorre tipo polimorfismo denominado sobrecarga etodos 
 sr comportamento etodos variar acordo convers oes impl ıcitas tipos sobre dados recebidos parˆametros polimorfismo conhecido polimorfismo coer 
 computa paralela fato simula oes computacionais cient ıficas utilizamse frequentemente modelos numericamente intensivos 
 visando validar teorias fazer predi oes acerca objetos estudo comum cientistas realizem grande umero simula oes tais modelos utilizando diferentes conjuntos parˆametros entrada 
 dessa forma natural existam demandas desempenho modelos computacionais cient ıficos forma simula oes possam ser realizadas tempos execu compat ıveis interesses ciˆencia 
 maiores desfiadores problemas ciˆencia moderna geralmente lidam combina oes fenˆomenos diferentes areas conhecimento englobando enorme gama escalas tempo espa co 
 simula oes computacionais cient ıficas escalas maiores tempo espa co est relacionadas extens dom ınio problemas modelados enquanto menores est relacionadas resolu desejada necess aria modelos 
 modelar problemas diminuindo extens dom ınios equipar aveis escalas ınimos detalhes menores fenˆomenos ısicos possa descrever frequentemente algo determina requisitos mem oria 
 outro lado reduzir janelas tempo escalas temporais menores intervalos algo implicar desafios relacionados tempo computa 
 grande parte discuss oes atuais ˆambito programa cient ıfica est focadas desempenho escal avel rouson al 
 ıcio desde cap ıtulo vimos escalabilidade execu est relacionada aproveitamento eficiente aximo recursos hardware dispon ıveis 
 al disso odigo escal avel ponto vista execu deve estar preparado crescer quesito desempenho forma compat ıvel eventual incremento recursos computacionais oferecidos 
 motivos deixam claro porquˆe ciˆencia importar tanto axima utiliza recursos computacionais dispon ıveis 
 evolu hardware ultimas ecadas tomou claramente dire desenvolvimento aquinas cada vez paralelas kirk hwu 
 escalabilidade execu programas est fortemente condicionada explora eficiente aquinas paralelas 
 arquiteturas paralelas grande variedade arquiteturas hardware computa paralela 
 redes oes trabalho clusters oes trabalho ultiplos processadores alguns arios ambientes onde pode explorar computa paralela 
 estudo computa paralela taxonomia flynn sido frequentemente utilizada longo ultimas ecadas classificar arquiteturas computadores quais divididas quatro grupos acordo umero fluxos instru oes instruction streams dados data streams podem ser operados simultaneamente aquina 
 oes seguintes exploramos cada grupos sisd simd misd mimd 
 single instruction single data sisd sistema sisd mostrado figura 
 unico fluxo instru oes opera unico fluxo dados 
 arquitetura sistema cl assico von neumman 
 aquina executa apenas instru vez pode buscar armazenar dado vez 
 single instruction multiple data simd sistemas arquitetura simd mostrado figura 
 unico fluxo instru oes distribu ıdo arios processadores cada fluxo dados 
 mesmas instru oes portanto aplicadas paralelo conjuntos dados diferentes 
 acordo pacheco sistema simd caracterizado presen ca unidade controle uc ultiplas figura 
 arquitetura sisd unidades logicoaritm eticas ulas 
 cada instru distribu ıda uc todas ulas aplicam dados entrada forma ıncrona 
 sistemas simd ideais paraliza loops simples operam longos arrays dados 
 tipo paralelismo obtido dividindo dados processadores aplicando mesmas instru oes sobre subconjuntos dados chamado paralelismo dados data parallelism 
 ıcio anos fabricante sistemas simd thinking machines maior fabricante aquinas paralelas planeta 
 final anos unicos sistemas simd produzidos passaram ser processadores vetoriais vector processors ainda presentes arquiteturas modernas cpus sob forma unidades especializadas opera oes vetoriais chamadas vector processing units vpus munidas registradores instru oes vetoriais al unidades funcionais vetorizadas pipelining 
 recentemente unidades processamento gr afico gpus tamb fazem uso computa simd 
 segundo pacheco aplica oes gr aficas frequentemente utilizam fun oes shader muitas vezes resultam unico fluxo controle aplicado diferentes elementos faz desempenho gpus otimizado computa simd 
 obtido unidade controle instrucoes processador dados inclus grande umeros ulas unico core gpus 
 multiple instruction single data misd existem sistemas computa bem conhecidos enquadrem modelo misd citado taxonomia flynn apenas motivos completude 
 multiple instruction multiple data mimd sistema modelo mimd mostrado figura 
 cada processador pr oprio fluxo instru oes opera sobre pr oprios dados individuais 
 unidade controle instrucoes processador dados dados processador dados dados processador dados dados processador dados dados figura 
 arquitetura mimd mattson al 
 modelo mimd geral ser util entendimento pr atico aquinas reais 
 categoria normalmente reclassificada acordo organiza mem oria 
 modelo pode ser decomposto aquinas mem oria compartilhada mem oria distribu ıda 
 mem oria compartilhada sistema mem oria compartilhada todos processadores compartilham unico espa co endere camento mem oria comunicam si escrita leitura vari aveis compartilhadas 
 sistemas mem oria compartilhada subdividem sistemas smp symmetric multiprocessors sistemas non uniform memory acess 
 sistemas smp todos processadores acessam todas regi oes mem oria maneira uniforme mesma velocidade 
 sistemas aceis programar pois programadores respons aveis distribui estruturas dados processadores 
 umero elevado unidades processamento aumenta disputa acesso mem oria 
 raz sistemas desse tipo costumam possuir umero limitado processadores largura banda acesso mem oria fator limitante unidade controle instrucoes processador dados dados unidade controle instrucoes processador dados dados unidade controle instrucoes processador dados dados unidade controle instrucoes processador dados dados rede interconexao desempenho 
 sistemas toda mem oria fisicamente acess ıvel todos unidade processamento entretanto alguns blocos mem oria podem estar diretamente associados certos processadores outros 
 dessa forma acesso completamente uniforme todas regi oes mem oria 
 pode reduzir disputa acesso mem oria diminuir efeitos gargalo desempenho devido largura banda mem oria 
 tempos acesso dado processador diferentes regi oes mem oria podem sofrer varia oes sendo sens ıveis qu pr oxima cada regi est processador 
 diminuir efeitos acesso uniforme cada processador possui mem oria cache protocolo coerˆencia caches arios processadores faz modelo receba frequentemente nome ccnuma cache coherent non uniform memory acess 
 programar tais sistemas equivalente programar par sistemas smp extraia melhor desempenho necess ario maior aten localidade dados efeitos cache 
 mem oria distribu ıda sistemas mem oria distribu ıda cada processador possui pr oprio espa co endere camento individual 
 implica comunica processadores possa fazer meio vari aveis compartilhadas caso anterior 
 sistemas mem oria distribu ıda comunica troca mensagens quais devem ser feitas explicitamente programador 
 al disso programadores precisam responsabilizar divis dados mem orias processadores 
 apesar representar responsabilidade tamb representa oportunidade 
 aplica oes estruturas dados grandes incapazes residir inteiramente mem oria aquina mem oria compartilhada poss ıvel utilizar ambientes mem oria distribu ıda particion alas 
 dependendo topologia tecnologias empregadas interconex processadores sistemas mem oria distribu ıda velocidade comunica pode variar drasticamente desde praticamente apidas quanto mem oria unificada arias ordens magnitude lenta caso clusters pcs conectados via redes ethernet 
 clusters sistemas computa mem oria distribu ıda compostos computadores conectador alguma infraestrutura rede 
 tecnologia redes cont ınuo avan co comunica cada vez apida clusters tˆem tornado cada vez comuns poderosos sendo principal representa pr atica dessa classe sistemas 
 ambientes computa paralela ambiente computa paralela configura conjunto tecnologias ferramentas recursos linguagens programa necess arios desenvolvimento aplica oes paralelas 
 produto final provido conjunto todos componentes ambiente programa modelo programa fornece abstra hardware sobre programadores atuam 
 computadores paralelos existe grande variedade modelos programa dependendo caracter ısticas particulares hardware definem processadores integrados formar sistema unico 
 modelos programa utilizados baseiam classifica oes vistas oes anteriores mem oria compartilhada mem oria distribu ıda troca mensagens combina ambas 
 nesta faremos apresenta dois difundidos modelos programa paralela existentes openmp open multiprocessing mem oria compartilhada mpi message passing interface mem oria distribu ıda 
 modelo openmp openmp conjunto diretivas fun oes biblioteca desenvolvimento programas paralelos ambientes mem oria compartilhada 
 combinado fortran cria linguagem multithread unidades execu programas openmp threads quais compartilham unico espa co endere camento 
 dessa forma comunica atrav es manipula vari aveis compartilhadas 
 defini formal openmp cont duas especifica oes fortran outra embora ambas bastante similares 
 baseados modelo fork join programas openmp come cam execu unica thread master pontos espec ıficos programa criamse threads adicionais fork 
 ultiplas threads executam paralelo trechos odigo denominados regi oes paralelas 
 fim regi oes paralelas cada thread aguarda todas demais conclu ıdo execu trecho voltam unir join unica thread master 
 modelo openmp criado objetivo ser simples desenvolvedores aplica oes 
 apesar melhor desempenho ser sempre desej avel decis frequente abrirse desempenho aximo caso venha tornar dif ıcil custoso desenvolvimento manuten aplica oes 
 openmp desenvolvido dois princ ıpios asicos equivalˆencia sequencial paralelismo incremental 
 equivalˆencia sequencial significa programa paralelo deve gerar mesmos resultados utilizandose threads resultado vers paralela deve ser igual resultado execu serial 
 segundo mattson al 
 programa equivalˆencia sequencial acil manter acil desenvolver compreender 
 paralelismo incremental estilo programa paralela onde programa evolui gradualmente vers serial vers paralela 
 programador inicia trabalhos vers serial aplica funcionamento 
 seguida identifica regi oes odigo onde vale pena explorar paralelismo usualmente chamadas hotspots 
 assim paralelismo adicionado forma incremental cada dessas regi oes 
 abordagem cada fase processo temse vers completamente funcional pode ser testada aumentando chance sucesso 
 infelizmente sempre ser poss ıvel paralelismo incremental conduza equivalˆencia sequencial 
 muitas vezes algoritmo paralelo precisa refatorar completamente alogo serial 
 existem tamb algoritmos paralelos simplesmente funcionam unica thread maneira serial 
 apesar dificuldades dois conceitos equivalˆencia sequencial paralelismo incremental guiaram desenvolvimento modelo openmp considerados boas pr aticas programa 
 modelo mpi mpi message passing interface criado ıcio ecada modelo programa padr sistemas computa mem oria distribu ıda troca mensagens 
 unidade execu mpi processos naturalmente cada possui espa co endere camento pr oprio 
 conceito central mpi troca mensagens 
 cada processo precisa agrupar informa oes mensagem envi ala outros processos devem estar preparados recebˆelas 
 comunica responsabilidade programador 
 mpi distribu ıdo forma biblioteca originalmente vers oes fortran apesar outras linguagens tamb terem sido contempladas 
 existem muitas implementa oes mpi uso difundido duas comuns lam mpi mpich ambas disponibilizadas gratuitamente mantenedores 
 simples mecanismo troca mensagens mpi oferece rotinas sincroniza processos distribui dados diferentes processos funcionalidades suportam desenvolvimento programas paralelos 
 ideia asica troca mensagens levanta questionamentos sobre detalhes feito pr atica 
 processos podem fazer enquanto enviam mensagens mensagens podem ser identificadas forma cada envio pareado respectivo recebimento questionamentos comuns 
 mpi define solu oes outras quest oes conceitos grupos processos contextos comunica 
 grupo processos engloba todos processos envolvidos computa 
 ıcio execu programa todos processos est agrupados unico grupo 
 posteriormente programador pode subdividi los agrupandoos grupos menores envolvidos determinada atividade pode controlar grupos interagem 
 contextos comunica fornecem meio agrupados conjuntos comunica oes relacionadas 
 qualquer troca mensagens necess ario mesmas identificadas forma saiba deve recebˆelas enviou 
 mpi mensagens identificadas ids processos enviam daqueles devem recebˆelas 
 apesar intuitivo conceito identificar mensagens ids processos pode funcionar certas situa oes especialmente aplica oes complexas incluem bibliotecas reutilizadas outros programas 
 bibliotecas incluem chamadas mpi existe risco aplica cliente bibliotecas compartilhem ids processos origem destino acidentalmente 
 ainda porque programador aplica normalmente desconhece detalhes implementa oes bibliotecas utilizadas 
 contextos comunica aparecem solu problema 
 cada envio cada recebimento pertence unico contexto comunica 
 cria arios contextos pode evitar problemas citados 
 contextos comunica grupos processos encapsulados mpi unica entidade denominada comunicador communicator 
 apesar ser necess ario lidar diretamente comunicadores todos programas maioria fun oes mpi faz referˆencia comunicador essencial programadores interessados desenvolver componentes software reutiliz aveis manipulem comunicadores 
 cap ıtulo refatora odulo simulador inclus paradigma orientado objetos neste cap ıtulo abordadas evolu oes odigofonte simulador ciˆencia escoamentos reservat orios folhelhos desenvolvido utilizado pesquisadores alunos lncc 
 foco organiza est atica estrutural odigofonte cap ıtulo apresenta analisa primeiramente evolu anterior trabalho simulador passou desde vers inicial 
 seguida cap ıtulo apresenta descreve maiores detalhes contribui espec ıfica presente trabalho nesse quesito consiste reestrutura odulos simulador incorpora paradigma orienta objetos 
 ser produto projeto inicial longo prazo ter prop osito cient ıfico simulador passado processo evolutivo continuado atende demandas pontuais usu arios especialistas dom ınio aplica frequentemente desejam incorporar novas funcionalidades realizar experimentos espec ıficos dando origem diferentes vers oes passam levar conta diferentes fenˆomenos ısicos 
 medida tais demandas espec ıficas atendidas aspectos modulares acabaram sendo gradativamente incorporadas odigo simulador deixa clara tendˆencia programas cient ıficos geral evoluam sentido tornaremse produtos cada vez flex ıveis adapt aveis componentes reaproveit aveis 
 odulo reestruturado neste trabalho corresponde odigofonte simulador respons avel montagem solu sistemas equa oes lineares etodo elementos finitos possui componentes alto potencial uso neste outros simuladores cient ıficos similares 
 evolu simulador escoamentos meios porosos visto cap ıtulo simulador utilizado neste trabalho bem outros desenvolvidos lncc tomam ponto partida implementa etodo elementos finitos proposta hughes programa dlearn pode ser encontrado link http www 
 escrito originalmente padr fortran durante ecada tamb desenvolvidos outros programas semelhantes adina software bathe programa elementos finitos dlearn hughes destacou epoca sendo bom programa per ıodo criado 
 programa precisou lidar contornar limita oes restri oes impostas pr oprio padr linguagem exemplo limita umero caracteres nomes vari aveis subprogramas dificultava legibilidade entendimento humano ausˆencia aloca dinˆamica mem oria vez tornava dif ıcil tarefa adequar programa diferentes tamanhos problemas 
 devido tamanho vari avel diferentes estruturas dados diferentes problemas algo ineficiente definir valores fixos tamanhos pode ocasionar erros sen desperd ıcio mem oria 
 programa original hughes contornava problema prevendo esp ecie emula aloca dinˆamica uso grande array est atico dentro virtualmente alocados ultiplos vetores menores tempo execu aux ılio vari aveis indicam ponto ıcio cada 
 ilustra tal estrat egia 
 grande vetor est atico presente implementa original hughes simula espa co aloca dinˆamica mem oria residem arios vetores menores dentre alhs brhs lm id idiag quais podem ser localizados interior meio vari aveis inteiras mpalhs mpbrhs mplm mpid mpidiag ındices elementos quais iniciavam cada areas reservadas vetores correspondentes 
 vetor est atico unico comportando ultiplos vetores menores diferentes tamanhos definidos tempo execu 
 ponto vista organiza estrutural embora concentrada unico arquivo fonte tal implementa base possui certo ıvel modulariza gra cas organiza estrutura subprogramas 
 hughes apresenta organiza programa fornecendo ındice pouco centena subprogramas quais maioria tipo procedimento subroutine minoria tipo fun function 
 sabemos dentre subprogramas forma padr troca informa oes passagem lista parˆametros 
 listas parˆametros frequentemente tornam grandes programas modulares crescem 
 al desta forma troca informa oes programa quest utiliza outro conceito fornecido linguagem fortran fim blocos common declara oes regi oes mem oria compartilhadas acess ıveis qualquer unidade programa contenha bloco common nome 
 representam forma troca informa oes meio partilha brhs alhs lm idiag id mpbrhs mpalhs mplm mpid mpidiag 
 blocos common permitem supbrogramas partilhem dados meio compartilhamento regi mem oria comum 
 necess ario todos blocos common nome possuam umero vari aveis nomes iguais mesmas 
 base ordena tipos vari aveis compilador estabelece correspondˆencias ultiplas vari aveis representam formas alternativas referenciar mesma regi mem oria 
 implementa hughes blocos common usados implementa estrat egia simula aloca dinˆamica mostrada anteriormente figura 
 grande vetor est atico apontadores ıcio subvetores compartilhados diversas unidades programa meio blocos common 
 mostra trecho odigo correspondente implementa original 
 linha aparece vetor bloco common nome blank common linha aparece common spoint armazena posi oes cont ıguas mem oria vari aveis ındices ıcio cada subvetor 
 rotina driver implementa original hughes uso bloco common importante 
 subroutine driver ntstep neq nalhs 
 solution driver program 
 common spoint mpd mpx mpid mpf mpg mpg mpdiag mpngrp mpalhs mpbrhs include memorysize 
 inc common maxsize 
 end subroutine driver partir padr fortran blocos common deixaram ser principal forma compartilhamento dados unidades programa dando lugar forma alternativa chamada module sobre voltaremos falar adiante 
 tendo ponto partida referida implementa etodo elementos finitos muitas aplica oes cient ıficas desenvolvidas lncc 
 final ecada programa axis toledo al 
 area alise tens oes olidos sob rota desenvolvido lncc projeto colabora copesp primeira tais aplica oes utilizar separa arquivos compila separada 
 compartilhamento dados blocos common continuava ser explorado ultiplos arquivos 
 grupo pesquisas reservat orios petrol ıferos seguiuse caminho simuladores grupo passaram ser divididos ultiplos arquivos principalmente devido alto custo compila 
 simulador deste trabalho tamb est dividido dessa forma adiante ser dados detalhes sobre organiza 
 final ecada simulador passou avan co significativo transi padr fortran incluindo aloca dinˆamica estruturas dados mem oria 
 estruturas dados dinˆamicas surge problema forma compartilhamento dados blocos common usada ent permite compartilhamento vari aveis alocadas dinamicamente 
 conforme adiantado partir fortran existe alternativamente common outro elemento programa denominado module 
 modules unidades independentemente compil aveis al promover modulariza encapsulamento dados processos possuem importante papel compartilhamento dados permitindo tamb compartilhadas vari aveis alocadas dinamicamente 
 fortran module entidade cont erie defini oes valores iniciais dados representa forma alternativa compartilhamento dados diferente unidades programa chapman 
 mesma forma ocorre blocos common diferentes unidades utilizam mesmos dados valores presentes unica regi mem oria 
 motiva inclus modules simulador entretanto possibilidade compartilhamento novas vari aveis alocadas dinamicamente imposs ıvel blocos common 
 mostram trechos dois odulos simulador mfratura mbloco quais veremos adiante respons aveis formula variacional relacionada problemas ısicos modelados simulador 
 trechos podese notar existˆencia vari aveis aloca dinˆamica anota allocatable quais compartilhadas outras unidades programa fazerem parte module 
 uso modules compartilhamento vari aveis alocadas dinamicamente odulo mfratura 
 real allocatable solucaof solucaotmpantf solucaonaolinearantf real allocatable ff fluxf 
 end module mfratura listagem 
 uso modules compartilhamento vari aveis alocadas dinamicamente odulo mbloco 
 real allocatable solucaob solucaotmpantb solucaonaolinearantb real allocatable msolucaob msolucaotmpantb real allocatable fb fluxb 
 end module mbloco unidades clientes usam dados processos encapsulados odulo deve existir declara use seguida nome odulo fortran 
 dessa forma podem acessar mesmos dados valores presentes odulo 
 dizse odulos fortran constituem forma compartilhamento dados alternativa lista parˆametros subprogramas 
 mostra subrotina processadorescalas programa principal faz uso certas vari aveis presentes odulos mfratura mbloco mostrados anteriormente 
 dentre vari aveis est algumas alocadas dinamicamente mostrado listagens 
 uso modules compartilhamento vari aveis alocadas dinamicamente simulador rotina processadorescalas cliente 
 subroutine processadorescalas use mfratura niterf ndoff nlvectf fluxf use mfratura dtempof solucaof ff sumnumiterf 
 use mbloco msolucaob msolucaotmpantb ndofb dtempob niterb sumnumiterb 
 end subroutine processadorescalas al encapsular dados promover compartilhamento unidades module podem ainda conter procedimentos fun oes integralmente implementadas interior 
 procedimentos contidos odulos chamados module procedures fortran 
 pr atica comum dividirse odulosfonte odulo interface implementa 
 fortran uso unidade module necess ario crie separadamente odulos defini implementa 
 module engloba simultaneamente conceitos odulo implementa defini 
 module procedures diferenciam procedimentos fun oes escritos module fato primeiros tˆem interface sempre dispon ıvel clientes 
 subrotinas escritas dentro module outra unidade compila faz uso desse module declara use automaticamente interface tais subrotinas tornase dispon ıvel unidades clientes 
 chapman evidenciase diferen ca procedimentos module module procedures diz respeito classifica interfaces 
 module procedure acessado declara use dito possuir interface expl ıcita vez todos detalhes sobre parˆametros formais explicitamente conhecidos compilador fortran 
 outro lado procedimentos module possuem interface impl ıcita dado compilador fortran possui informa oes sobre procedimentos est compilando qualquer unidades clientes 
 nesse momento compilador simplesmente assume programador est utilizando procedimentos maneira correta quanto umero tipos argumentos passados chapman 
 outra vantagem oferecida modules est relacionada exigˆencia pr opria linguagem procedimentos possuem parˆametros tipo ponteiro pointer arrays alocados dinamicamente allocatable precisam obrigatoriamente ter interface expl ıcita portanto vis ıvel clientes 
 sendo assim modules facilitam tarefa visto padr explicitam interface todos procedimentos internos 
 mostra trechos odulo mfratura onde podese ver declara vari avel solucaof aloca dinˆamica mem oria linha 
 podese ver ainda rotina printsolf 
 vari avel solucaof posteriormente utilizada argumento chamada desta subrotina veremos adiante 
 odulo contendo subrotina parˆametro alocado dinamicamente 
 real allocatable solucaof 
 allocate solucaof ndoff numnpf 
 subroutine printsolf solucao numnp tempo 
 imprime solucao fratura 
 end subroutine printsolf end module mfratura listagem 
 mostra rotina processadorescalas pertencente programa principal 
 rotina faz uso vari avel solucaof utiliza primeiro argumento chamada rotina printsolf 
 poss ıvel pois visto listagem 
 printsolf module procedure faz parte module mfratura tal interface vis ıvel cliente 
 chamada subrotina parametro alocado dinamicamente 
 use mfratura solucaof use mfratura printsolf 
 call printsolf solucaof xf numnpf tempo 
 organiza simulador arquivos compila separada adiantado vers simulador tomada base neste trabalho possui modulariza arquivos compila separada 
 alguma simplifica podemos enxergar tais arquivos organizados estrutura ıveis definem diferentes potenciais uso mostrado figura 
 organiza ıveis ultiplos arquivos fonte exce unica feita arquivofonte cont rotina principal driverescalas 
 cada arquivo compreende unidade module fortran 
 tomamos liberdade referir arquivos odulos forma indistinta embora caso arquivo odulo principal exista fato unidade module 
 primeiro ıvel mostrado figura 
 baixo nenhum ıvel uso est odulo principal desempenha apenas papel cliente demais odulos descreve fluxo asico execu simulador 
 rotinas deste odulo usadas apenas interior 
 uso odigo deste odulo pode darse apenas forma adapta visto outras vers oes simulador reservat orios podem ser desenvolvidas adaptandose odulo 
 entretanto devido natureza enquanto odulo principal guia execu aplica reutiliza componentes internos forma uso verbatim inexistente 
 segundo ıvel est odulos desempenham papel provedores funcionalidades tempo clientes outros odulos 
 nessa categoria enquadramse odulos referentes problemas ısicos simulador fratura 
 tais odulos componentes internos reutilizados alguma frequˆencia dentro simulador 
 terceiro ıvel encontramse odulos base provedores funcionalidades alto ıvel uso relacionadas dom ınio aplica 
 significa tais odulos tˆem grande potencial uso verbatim somente dentro simulador tamb outras aplica oes baseadas mesma implementa etodo elementos finitos proposta hughes caso arios outros simuladores cient ıficos desenvolvidos lncc 
 organiza simulador arquivosfonte figura 
 mostra arquivosfonte divididos ıveis descritos anteriormente 
 ıvel est odulo programa principal driverescalas 
 nele est definido fluxo execu programa composto leitura dados entrada processamento processamento onde apresentados resultados 
 tanto odulo utiliza funcionalidades providas outros dois ıveis 
 ıvel odulos fratura 
 respons aveis formula variacional implementa erica problemas ısicos escoamento fratura hidr aulica bloco rocha matriz respectivamente 
 ıvel odulos leituraescrita 
 respons avel leitura arquivos entrada informa oes malha coordenadas al escrita resultados malha 
 repons avel gera coordenadas nodais conectividades busca vizinhos funcoesdeforma inclui fun oes interpola lagrangeanas informa oes integra erica finalmente odulo algmatricial 
 respons avel constru solu sistemas equa oes lineares etodo elementos finitos incluindo montagem estruturas dados implementa solver interno 
 orienta objetos odulo sistemas equa oes contribui deste trabalho odigo simulador concentrada odulo algmatricial 
 consiste reformula deste odulo passa dar lugar outros menores incluindo paradigma orienta objetos alguns conceitos heran ca polimorfismo 
 considerando odulo quest est terceiro ıvel mostrado figura 
 possui alto potencial uso percebese benef ıcios decorrentes reestrutura podem estender outras aplica oes semelhantes dentro lncc 
 reestrutura objetivase conferir simulador caracter ısticas modulares contribuindo melhor entendimento humano capacidade evolu 
 conforme visto cap ıtulo odigos implementam conceitos modularidade orienta objetos beneficiamse abstra oes meio encapsulamento dados opera oes ganhando usabilidade 
 entidades encapsuladas encorajam facilitam uso aplica oes odigofonte extenso 
 identifica entidades interesse odulo refatorado compreende dados opera oes relativos constru solu sistemas equa oes tamb estruturas dados capazes tratar esparsidade matrizes relacionadas tais sistemas 
 odulo inclui originalmente apenas op solver interno implementando elimina gauss 
 muitas aplica oes cient ıficas fazem uso solvers bibliotecas algebra linear dentre quais podemos citar fins exemplo lapack petsc umfpack intel mkl 
 alguns simuladores cient ıficos ericos desenvolvidos lncc determinado momento evolu ca iniciativas individuais demandas espec ıficas passaram utilizar solvers externos pardiso intel mkl hypre los alamos 
 tais iniciativas demandaram odulo algmatricial 
 consideravelmente modificado passando englobar apenas novas op oes solvers tamb diferentes estruturas dados adequandose diferentes solvers 
 al trabalhosos processos adapta desse tipo frequentemente resultam altera oes feitas maneira esparsa odigofonte impacta negativamente usabilidade evolu 
 reestrutura feita neste trabalho funciona camada software orienta objetos substitui odulo citado encapsula diferentes classes dados opera oes relativos sistemas equa oes estruturas dados solvers 
 novos odulos classes permitem maior organiza odigo facilitam troca inclus novos solvers estruturas dados sistemas equa oes neste outros simuladores baseados mesma implementa original 
 cuja implementa original simplificada mostrada listagem 
 une vari aveis subrotinas cuja alise cuidadosa permite identifica grupos dados opera oes certo ıvel similaridade podem ser melhor distribu ıdos outras unidades encapsuladoras melhor modulariza 
 paradigma orienta objetos permitir realiza desta tarefa naturalidade trar benef ıcios somente organiza odigofonte evolu futura tamb facilitar implementa estrat egia paraleliza odigo simulador ser visto cap ıtulo 
 module malgmatricial integer integer real neqf nalhsf nedf neqb nalhsb nedb allocatable alhsf brhsf allocatable alhsb brhsb real integer allocatable idf idiagf lmf integer allocatable idb idiagb lmb 
 subrotinas public back factor public diag load addnsl addlhs addrhs public btod kdbc ftod colht 
 end module malgmatricial algumas vari aveis rotinas mostradas listagem 
 est relacionadas sistema propriamente dito outras estruturas dados utilizadas 
 assim abordagem adotada neste trabalho estabelece existˆencia estrutura duas classes base representam entidades interesse sistemas equa oes estruturas dados 
 solvers podem ser vistos conjuntos opera oes atuam sobre dados sistema 
 solver ser portanto entendido procedimento faz parte todo sistema equa oes cuja fun resolvˆelo 
 trabalho inclui provimento duas op oes solver sendo interno implementando elimina gauss presente odulo original outro externo intel mkl pardiso ambos encapsulados arcabou co orienta objetos 
 tipos solvers definem tipos sistemas equa oes forma sistemas tipo gauss tipo pardiso vez sistemas precisam incluir rotinas vari aveis espec ıficas lidar tipos espec ıficos solver 
 cada solvers requer tipo estrutura dados tratar esparsidade matrizes forma espec ıfica 
 tais estruturas dados tipo skyline sistemas tipo gauss tipo crs sistemas tipo pardiso 
 mostra diagrama uml simplificado estrutura classes adotada onde observa conceito heran ca tanto tipos sistemas equa oes tipos estruturas dados 
 estrutura asica classes sistemas estruturas dados sistemas tipo gauss tipo pardiso possuem semelhan cas diferen cas 
 pontos comum est encapsulados classe ae sistemaequacoes 
 classes sistemagauss sistemapardiso ligadas primeira seta indica relacionamento heran ca 
 diferen cas implementadas classes filhas 
 estruturas dados estruturaskyline estruturacrs respectivamente tamb possuem pontos comum pontos diferen ca herdando pontos comum classe ae estruturadados sendo diferen cas implementadas classes filhas 
 introduzindo atributos etodos classes alise vari aveis rotinas odulo algmatricial 
 bem semelhan cas sistemas tipo gauss pardiso permite observar todos sistemas forma matricial 
 possuem atributos comum matriz vari avel alhs vetor vari avel brhs al estrutura dados poder ser tipo skyline crs 
 quanto opera oes etodos classes podemos observar todos sistemas possuem comum opera solver representada etodo solver al outras opera oes adicionais etodo elementos finitos relacionadas exemplo montagem matrizes globais caso addlhs addrhs coloca condi oes contorno load ftod 
 mostra diagrama uml classes sistemas equa oes estruturadadosabstractestruturaskylineestruturacrssistemaequacoesabstractsistemagausssistemapardiso ıvel maiores detalhes 
 estrutura classes sistemas equacoes maiores detalhes 
 entendimento todas rotinas odigo considerado irrelevante nesse momento interessados explorar reestrutura odulo original conceitos orienta objetos heran ca polimorfismo encapsulamento 
 dessa forma concentrandonos explora tais conceitos chamamos aten dois etodos espec ıfico solver addlhs 
 todos sistemas possuem etodo solver capaz resolvˆelo 
 entretanto tipos diferentes sistemas diferentes solvers naturalmente devem comportar maneira diferente 
 cen ario evoca automaticamente conceito polimorfismo visto cap ıtulo 
 algo semelhante ocorre etodo addlhs respons avel adicionar contribui sistemaequacoesabstract alhs real allocatable brhs real allocatable estdados class estruturadados pointer solverm abstract addlhsm abstract addrhsm ftodm loadm kdbcm btodm colocarcondcontornosistemagauss construtorsistemagauss solverm addlhsm backm factormsistemapardiso pt integer iparm integer dparm real construtorsistemapardiso solverm addlhsm matrizes elemento matriz global etodo elementos finitos 
 caso classes estruturas dados ocorre cen ario similar mostrado diagrama figura 
 podemos identificar tanto estruturas dados tipo skyline quanto tipo crs possuem atributos comum trio vetores lm id idiag aparecem portanto classe ae 
 toda estrutura dados tamb possui etodo montarestruturadados embora comporte maneira diversa classes filhas 
 significa tamb etodo onde aparece conceito polimorfismo 
 estrutura classes estruturas dados maiores detalhes 
 oes seguintes abordaremos implementa pr atica odigo simulador conceitos discutidos aqui 
 ser apresentados trechos odigo linguagem fortran mostrando implementadas classes conceitos heran ca polimorfismo discutidos ponto 
 estruturadadosabstract lm integer allocatable id integer allocatable idiag integer allocatable ai integer allocatable neq integer nalhs integer ned integer blocooufratura character montarestruturadados abstractestruturaskyline montarestruturadados colhtm diagmestruturacrs lmstencileq integer allocatable posponteiro integer contponteiro integer nonzeros integer montarestruturadados criarponteirosmatesparsa 
 implementa orienta objetos fortran heran ca acordo chapman linguagem fortran utilizada neste trabalho orienta objetos implementada uso modules tipos dados derivados definidos palavra type quais podem conter opera oes interior implementados integralmente dentro unidade module 
 vemos classe ae sistemaequacoes implementada 
 classe representada tipo derivado sistemaequacoes definido linha 
 implementa classe fortran 
 type public abstract sistemaequacoes real public allocatable alhs brhs class estruturadados pointer estdados contains 
 metodos classe sistemaequacoes procedure solverminterface public deferred solverm procedure addlhsminterface public deferred addlhsm procedure public addrhsm procedure public ftodm 
 end type sistemaequacoes 
 implementacao metodos classe subroutine addrhsm pelresf pnel pnee pndof pnen 
 end module ainda listagem 
 vemos ap palavra contains linha etodos classe listados procedimentos tipo type bound procedures seguida implementados ap palava contains linha ainda dentro odulo msistemaequacoes 
 mostra classe filha sistemapardiso implementada 
 defini similar feito classe ae 
 chamamos aten anota extends sistemaequacoes feita defini tipo derivado linha 
 indica classe sistemapardiso filha classe sistemaequacoes portanto herda atributos etodos funcionando especializa 
 implementa classe herdeira fortran 
 type public extends sistemaequacoes sistemapardiso 
 atributos sistema pardiso integer pt iparm real dparm contains 
 metodos sistema pardiso procedure public solverm procedure public addlhsm procedure public construtorsistemapardiso end type sistemapardiso contains 
 implementacao metodos classe subroutine solverm psolucao plabel 
 end subroutine solverm 
 implementa polimorfismo fortran repararmos diagrama uml figura 
 veremos classe sistemaequacoes lado etodos solver addlhs existe anota abstract 
 quer dizer dois etodos abstratos implementa definida classe ae onde existe apenas declara interface 
 implementa completa etodos feita classes filhas sistemagauss sistemapardiso especializam classe ae implementam tais etodos diferentes formas 
 mostra defini tais interfaces classe sistemaequacoes 
 defini interfaces etodos abstratos classe sistemaequacoes 
 abstract interface subroutine solverminterface psolucao plabel import sistemaequacoes class sistemaequacoes character len plabel real allocatable psolucao end soubroutine solverminterface 
 end module msistemaequacoes seguir vemos listagem 
 implementa etodo solver subclasse sistemagauss 
 vemos comportamento etodo nesta subclasse chamar etodos factor back linhas respons aveis fatora substitui retrocedida etapas existentes implementa original possu ıa apenas solver baseado elimina gauss 
 veremos seguir comportamento etodo diferente outra subclasse 
 polimorfismo implementa etodo solver classe sistemagauss 
 soubroutine solverm psolucao plabel implicit none class sistemagauss 
 call thisfactorm call thisbackm 
 call thisbtodm psolucao ndof numnp end soubroutine solverm 
 end module msistemagauss adiantado observase listagem 
 comportamento polim orfico etodo solver cuja implementa interna completamente diferente subclasse sistemapardiso chamando rotina solverpardisoppdnodal realiza opera oes espec ıficas solver pardiso 
 polimorfismo implementa etodo solver classe sistemapardiso 
 subroutine solverm psolucao plabel implicit none class sistemapardiso 
 call solverpardisoppdnodal simetria plabel etapa 
 call thisbtodm psolucao ndof numnp end subroutine solverm 
 end module msistemapardiso 
 nova organiza simulador novos odulos contendo classes visto longo 
 odulo original algmatricial 
 deu lugar outros seis odulos classes mostrados ıvel figura 
 nesta abordamos forma seis odulos integramse restante simulador feitas instˆancias objetos classes citadas oes anteriores odigo 
 organiza simulador novos odulos fonte 
 englobam aspectos relacionados problemas ısicos escoamento fratura hidr aulica bloco matriz 
 raz decidiuse objetos classes sistemas equa oes estruturas dados devem existir dentro desses odulos 
 faz sentido pensar fratura bloco possuemsistemas equa oes estruturas dados tais sistemas 
 haveria portanto instˆancia sistemaequacoes fratura hidr aulica outra bloco 
 sendo alido estruturas dados 
 mostram trechos odulos fratura 
 onde declaradas vari aveis verdade ponteiros quais momento apropriado far referˆencia regi oes mem oria ser alocados objetos classes criadas 
 interessante observar ponteiros objetos tipos sistemaequacoes estruturadados superclasses mostradas oes anteriores 
 ponteiros classe ae podem apontar objetos classes filhas ser feito momento oportuno acordo escolha usu ario 
 objetos classes sistemaequacoes estruturadados odulo mfratura module mfratura 
 class sistemaequacoes pointer umsisteqfratura class estruturadados pointer umaestdadosfratura 
 end module mfratura listagem 
 objetos classes sistemaequacoes estruturadados odulo mbloco module mbloco 
 class sistemaequacoes pointer umsisteqbloco class estruturadados pointer umaestdadosbloco 
 end module mbloco caso bloco interessante lembrar dados referentes sistema sobrescritos cada passo processo iterativo resolve ultiplos problemas unidimensionais elementos finitos descrito cap ıtulo mostrado figura 
 caso fratura existe apenas malha portanto sistema sobrescrito momento algum 
 programa principal reservoirsimulator localizado arquivo driverescalas 
 feita decis sobre tipos sistema estruturas dados serem utilizados 
 seguir ser mostrados alguns trechos deste arquivo fonte destacados alguns pontos relevantes 
 primeiramente destacamos programa principal faz uso ponteiros presentes fratura 
 mostrados anteriormente listagens 
 pode ser visto listagem 
 declara oes use linhas 
 programa principal fazendo uso ponteiros declarados odulos fratura 
 sistemas equacoes presentes mfratura mbloco use mfratura umsisteqfratura use mbloco umsisteqbloco 
 estruturas dados presentes mfratura mbloco use mfratura umaestdadosfratura use mbloco umaestdadosbloco 
 end program reservoirsimulator seguida feita decis sobre tipos sistemas estruturas dados utilizados 
 feito meio diretivas compila encontradas linhas listagem 
 flag withpardiso definida devemos ter sistemas tipo gauss estruturas skyline 
 caso flag definida significa op usu ario solver pardiso ent devemos ter sistemas desse tipo estruturas tipo crs 
 conceito utilizado aqui typed allocation aloca tipada 
 assim podemos alocar objetos classes sistemaequacoes estruturadados definindo neste momento desejamos alocar objetos subclasse espec ıfica 
 feito sistemas tipo gauss estruturas skyline linhas 
 sistemas tipo pardiso estruturas crs feito linhas 
 aloca objetos classes sistemas equa oes estruturas dados 
 implicit none ifndef withpardiso 
 fratura allocate sistemagauss umsisteqfratura allocate estruturaskyline umaestdadosfratura 
 bloco allocate sistemagauss umsisteqbloco allocate estruturaskyline umaestdadosbloco endif ifdef withpardiso 
 fratura allocate sistemapardiso umsisteqfratura allocate estruturacrs umaestdadosfratura 
 bloco allocate sistemapardiso umsisteqbloco allocate estruturacrsumaestdadosbloco endif 
 ligando ponteiros umsisteqfraturaestdados umaestdadosfratura umsisteqblocoestdados umaestdadosbloco 
 call preprocessadorfratura call preprocessadorbloco 
 end program reservoirsimulator chamamos aten opera oes feitas linhas tamb listagem 
 aloca objetos onde estabelecemos liga atributo estdados objetos classes sistema estruturas dados rec alocadas 
 conveniente atentar diagrama figura 
 onde vemos todo sistema atributo estrutura dados 
 ap etapa cria sistemas aparecem ainda listagem 
 linhas chamadas rotinas preprocessadorfratura preprocessadorbloco repons aveis ultiplas tarefas inicializa referentes modelos bloco fratura 
 mostra rotina preprocessadorfratura 
 rotina preprocessadorbloco similar faz opera oes alogas caso bloco 
 allocate umsisteqfraturaestdadosid ndoff numnpf umsisteqfraturaestdadosid call leituracodigoscondcontorno umsisteqfraturaestdadosid ndoff numnpf iin iecho iprtin umsisteqfraturaestdadosneq allocate umsisteqfraturaestdadosidiag umsisteqfraturaestdados neq umsisteqfraturaestdadosidiag allocate umsisteqfraturaestdadoslm ndoff nenf numelf 
 select type umsisteqfratura type sistemagauss optsolverfgauss call umsisteqfraturaconstrutorsistemagauss type sistemapardiso optsolverfpardisoesparso call umsisteqfraturaconstrutorsistemapardiso nsdf nenf numconexoesporelem end select 
 end subroutine preprocessadorfratura end module mfratura linhas vemos respectivamente aloca dinˆamica vetores id idiag lm pertencentes estruturas dados armazenamento matrizes esparsas mostrados diagrama figura 
 interessante lembrar alguns vetores figura 
 quais implementa original hughes contidos dentro grande vetor est atico 
 dentre tarefas realizadas rotinas preprocessadorfratura preprocessadorbloco destacamos ainda chamadas duas novas rotinas importantes construtorsistemagauss construtorsistemapardiso acordo tipo sistemas escolhido 
 chamadas tais rotinas quais etodos subclasses sistemas podem ser vistas linhas listagem 
 etodos cumprem aproximadamente fun etodos construtores respons aveis algumas tarefas inicializa sistemas devem ser feitas imediatamente ap aloca objeto 
 importˆancia tais etodos est fato neles feita aloca dinˆamica matrizes vetor carga sistemas equa oes 
 dessa forma assim novo sistema alocado etodo construtor correspondente chamado faz aloca dinˆamica matriz alhs vetor brhs pertencentes sistemas equa oes 
 mostram rotinas quest 
 destacamos aloca vari aveis alhs brhs 
 subroutine construtorsistemagauss implicit none class sistemagauss allocate thisalhs thisestdadosnalhs allocate thisbrhs thisestdadosneq end subroutine construtorsistemagauss end module msistemagauss listagem 
 subroutine construtorsistemapardiso pnsdf pnenf pnumconexoesporelem use mmalha numconexoesporelem implicit none class sistemapardiso integer intent pnsdf pnenf integer pnumconexoesporelem allocate thisalhs thisestdadosnalhs allocate thisbrhs thisestdadosneq pnumconexoesporelempnenf end subroutine construtorsistemapardiso 
 end module msistemapardiso finalmente fim programa principal todos sistemas estrtuturas dados desalocados mostra listagem 
 desaloca sistemas estruturas dados program reservoirsimulator 
 deallocate umsisteqfratura deallocate umaestdadosfratura deallocate umaestdadosbloco deallocate umsisteqbloco end program reservoirsimulator pr oximo cap ıtulo veremos reestrutura orienta objetos desenvolvida nesse trabalho facilitou implementa estrat egia paraleliza simulador 
 desenvolvimento solu paralela produziu altera aloca sistema equa oes bloco deixa ser unico passa dar lugar arios sistemas alocados dinamicamente convivendo simultaneamente mem oria deixando ser sobrescrito cada itera la co resolve ultiplos problemas relativos bloco 
 tal abordagem ser detalhada cap ıtulo 
 cap ıtulo paraleliza simulador escalas shale gas neste cap ıtulo abordamos desenvolvimento estrat egias paraleliza padr oes openmp mpi odigo simulador escoamentos reservat orios folhelhos 
 inicialmente feita alise perfil desempenho serial aplica uso ferramenta especializada 
 seguida apresentadas evolu oes odigo necess arias implementa paralelismo 
 fim apresentados testes desempenho criticados resultados 
 alise inicial perfil serial desempenho aplica intel vtune primeiro passo formula estrat egias paraleliza propostas neste trabalho envolveu fase alise desempenho identifica odigo simulador regi oes consomem tempo execu 
 avalia correta perfil desempenho odigo suporta desenvolvimento estrat egias paraleliza medida esfor cos otimiza direcionados regi oes demandantes odigo onde aumento desempenho ter maior impacto desempenho geral aplica 
 obten perfil desempenho odigo utilizada ferramenta perfilamento odigo intel vtune amplifier xe dispon ıvel cluster altixxe lncc 
 acordo jeffers reinders vtune ferramenta capaz fornecer diversas etricas respeito execu programa exemplo uso mem oria cache al ajudar identifica regi oes maior custo execu conhecidas hotspots 
 arcabou co orienta objetos desenvolvido neste trabalho incorporado simulador permite utiliza dois diferentes solvers solver interno implementando elimina gauss al solver externo intel pardiso biblioteca intel mkl 
 neste momento inicial interessados apenas analisar perfil desempenho aplica confrontar dois solvers neste simulador 
 tanto realizadas alises intel vtune execu oes seriais odigo simulador ambos referidos solvers 
 nesta alise inicial comparativa solvers utilizamos caso fratura malha unidimensional elementos 
 bloco cada malha possui elementos tempo simula total meses 
 apesar tratarse primeiro caso teste experimental ainda pretens oes interpreta resultados ısicos tamanhos malhas utilizados nesta etapa compat ıveis adotados simula oes semelhantes costa 
 tipo alise feito ferramenta perfilamento denominado basic hotspot analysis segundo jeffers reinders recomendado vis geral perfil desempenho identifica subrotinas custosas tempo execu 
 mostram aba caller callee lista todas rotinas odigo simulador ordenadas tempo execu total considerando soma todas vezes chamadas executadas 
 umeros percentuais rela tempo total execu aplica 
 percentual tempo total execu rotina solver gauss figura 
 mostrada execu solver interno elimina gauss passo figura 
 execu feita solver exerno intel pardiso 
 ambos casos notase semelhan ca rotina processadorbloco cuja linha est destaque figuras corresponde grande percentual tempo execu total aplica 
 percentual tempo total execu rotina solver intel pardiso rotina destaque processadorbloco respons avel linhas gerais resolver problema unidimensional dentre arios relativos bloco exposto cap ıtulo 
 tal rotina cuja implementa antes qualquer interven paraleliza mostrada listagem 
 respons avel montar problema matricial relacionado sistema equa oes lineares chamada rotina montarsistemab resolver sistema chamada etodo polimorfo solver visto cap ıtulo 
 rotina processadorbloco odulo principal driverescalas 
 use mbloco umsisteqbloco use mbloco umaestdadosbloco 
 call montarsistemab umsisteqbloco dt solucaotmpantbaux solucaobaux call umsisteqblocosolverm solucaobaux bloco 
 end subroutine processadorbloco visto cap ıtulo 
 cada ponto malha elementos finitos problema fratura existe problema relativo bloco 
 dessa forma rotina processadorbloco executada tantas vezes quantos pontos malha fratura 
 grande umero chamadas rotina junto custo chamada fazem corresponda alt ıssimo percentual tempo total execu aplica visto figuras 
 fato cada chamada tal rotina resolve sistema equa oes independente permite considerar execu paralelo 
 ideia asica estrat egia paralelismo desenvolvida ser melhor detalhada oes seguintes 
 voltemonos agora diferen cas dois solvers 
 experiˆencia anterior colegas dentro lncc implementa simuladores similares deste trabalho mostra especificamente caso problemas unidimensionais elementos finitos utiliza solver baseado elimina gauss vantajosa tempo execu utiliza alguns outros solvers externos dentre pardiso 
 fim confirmar tal hip otese neste simulador espec ıfico apresentamos dados tamb obtidos mesma alise ferramenta intel vtune amplifier xe capazes clarificar diferen ca pr atica dois solvers dispon ıveis especificamente nesta aplica lida unicamente malhas unidimensionais acordo modelo apresentado 
 podese observar aba summary vtune mostra tempo total execu aplica 
 utiliza solver interno elimina gauss tempo total execu simulador caso teste pouco segundos 
 tempo total execu caso experimental solver gauss uso solver pardiso entretanto tempo total aproximou minuto segundos segundos refor ca hip otese utiliza solver gauss problemas malhas unidimensionais interessados resolver neste momento vers atual simulador vantajosa termos dempo execu 
 tempo total execu caso experimental solver intel pardiso examinando resultados figuras 
 pouco fundo concentraremos rotina processadorbloco aparece destaque figuras respons avel alt ıssimo percentual tempo execu aplica 
 analisam especificamente rotina processadorbloco mostrando quais rotinas filhas chamadas interior desmembrando tempo execu gasto cada 
 duas figuras destacamos linha rotina solver pois interessados confrontar dois solvers 
 obervamse dados execu solver interno gauss 
 notase segundos gastos rotina processadorbloco apenas segundos gastos rotina solver propriamente dito linha destacada figura 
 alise rotina processadorbloco solver gauss contraste figura 
 onde mostrados resultados execu solver pardiso percebese total segundos gastos rotina processadorbloco segundos gastos rotina referente solver sendo neste caso impactante montagem sistema 
 alise rotina processadorbloco solver pardiso ultima alise portanto confirma hip otese execu tornouse lenta solver pardiso especificamente raz custo execu rotina solver propriamente dito qualquer outro tipo processamento relacionado 
 dessa forma consideramos solver interno adequado modelo ısico matem atico atual utilizado simulador 
 provimento solver externo entretanto deixa ser justific avel representar avan co simulador 
 embora atualmente modelo desenvolvido costa utilizado simulador fa ca uso apenas malhas unidimensionais qualquer itera futura contemple utiliza malhas bidimensionais tridimensionais poder fazer usu ario deste simulador necessite lan car solver externo adequado tais situa oes 
 intel pardiso disponibilizado outro decida implementar facilitado uso arcabou co orienta objetos desenvolvido neste trabalho 
 implementar nova classe sistemas equa oes integr ala simulador tarefa convidativa integrar novo solver antigo odulo malgmatricial visto cap ıtulo 
 estrat egia paraleliza openmp neste momento conveniente retomar caracter ıstica modelo ısico matem atico proposto costa adotado simulador 
 conforme visto cap ıtulo figura 
 modelo simula escoamento reservat orio convencional composto bloco fratura induzida baseado ultiplos problemas unidimensionais elementos finitos referentes bloco quais est relacionados pontos malha unidimensional problema fratura fornecendo termo fonte massa ultimo 
 modelo confere odigo caracter ıstica ser naturalmente paraleliz avel visto solu oes ultiplos problemas bloco originalmente feitas forma serial apesentam qualquer tipo dependˆencia si 
 caracter ıstica conhecida inglˆes embarassing parallelism sugere ser constrangedor explore oportunidade convidativa execu paralela tais atividades 
 estrat egia paralelismo desenvolvida neste trabalho explora portanto solu paralelo ultiplos problemas unidimensionais elementos finitos referentes bloco 
 proposta aqui paraleliza solver sim desenvolvimento estrat egia tornar paralela execu modelo inclui solu ultiplos problemas independentes bloco 
 tratase estrat egia paraleliza ıvel alto abstra granularidade grossa sentido cada unidades execu openmp threads resolvem problemas completos 
 considerando odulo refatorado neste trabalho visa disponibilizar solvers diferentes inclusive facilitar inclus outros confere odigo certo grau heterogeneidade fluxo execu 
 estrat egia paraleliza desenvolvida adequada caracter ıstica medida permite simulador beneficie paralelismo escalabilidade execu independente solver uso 
 ideia cada thread openmp resolva subconjunto umero total problemas unidimensionais bloco 
 cada destes problemas corresponde basicamente chamada rotina processadorbloco visto 
 monta problema matricial relacionado sistema resolve 
 odigo simulador vers serial existe rotina respons avel resolver todos problemas relacionados bloco resolverprobvariosblocos mostrada listagem 
 linha poss ıvel observar loop resolve cada problema ap outro chamando rotina processadorbloco arias vezes al armazenar cada itera contribui problema posi vetor fluxomassicodeblocoparafratura ser utilizado problema fratura 
 rotina serial resolve ultiplos problemas bloco 
 integer numblocos real fluxomassicodeblocoparafratura numblocos fluxomolms integer iblocos iblocos numblocos call processadorbloco 
 fluxomassicodeblocoparafratura iblocos fluxomolms end 
 fim loop problema micro blocos end subroutine resolverprobvariosblocos nesta rotina resolverprobvariosblocos ser inseridas diretivas compila padr openmp pareliza loop resolve arios sistemas equa oes 
 entretanto importante observar vers serial odigo objeto classe sistemaequa oes possui dados sobrescritos cada itera loop mostrado linha listagem 
 mostra rotina processadorbloco cada vez executada reconstr oi matrizes sistemas resolve 
 linhas mostram vari aveis alhs brhs sendo reinicializadas valor zero rotina 
 neste momento percebese grande utilidade novos odulos baseados paradigma orientado objetos 
 preciso arios sistemas coexistindo simultaneamente mem oria estrat egia paraleliza funcione cada thread openmp capaz operar sistema diferente 
 classe sistemaequacoes pode ser alcan cado naturalidade vez podemos instanciar ultiplos objetos classe 
 novo objeto dever ser criado cada chamada rotina processadorbloco 
 reformula rotina processadorbloco feita objetos classe sistemaequacoes referentes bloco criados interior 
 mostra parte nova vers rotina 
 linha vemos ponteiro umsisteqbloco classe ae sistemaequacoes enquanto linhas objeto propriamente dito criado alocado mem oria relacionado ponteiro linha 
 linha atributo estdados sistema ralacionado estrutura dados presente odulo mbloco 
 reformula rotina processadorbloco subroutine processadorbloco 
 use mbloco umaestdadosbloco 
 ponteiro sistema class sistemaequacoes pointer umsisteqbloco ifndef withpardiso allocate sistemagauss umsisteqbloco endif ifdef withpardiso allocate sistemapardisoumsisteqbloco endif 
 ligando ponteiros umsisteqblocoestdados umaestdadosbloco 
 select type umsisteqbloco type sistemagauss optsolverbauxgauss call umsisteqblococonstrutorsistemagauss type sistemapardiso optsolverbauxpardisoesparso call umsisteqblococonstrutorsistemapardiso nsdb nenb numconexoesporelemaux end select 
 call montarsistemab umsisteqbloco dt solucaotmpantbaux solucaobaux call umsisteqblocosolverm solucaobaux bloco 
 deallocate umsisteqbloco end subroutine processadorbloco processo descrito anteriormente exatamente antes feito odulo principal driverescalas 
 naquela situa utilizando ponteiro umsisteqbloco presente odulo mbloco 
 ponteiro apontava objeto tipo sistema equa oes alocado programa principal 
 mostrado detalhes trechos odigo exibidos cap ıtulo 
 nova vers tanto ponteiro sistema aloca objeto mem oria est dentro rotina processadorbloco 
 chamamos aten fato ap aloca sistema ainda dentro rotina processadorbloco aparece agora chamada etodos construtorsistemagauss construtorsistemapardiso quais conforme discutido cap ıtulo 
 fazem aloca dinˆamica matrizes sistemas equa oes 
 finalmente final rotina processadorbloco linha sistema desalocado 
 permite portanto identifica evolu oes feitas rotina processadorbloco ser necess arias desenvolvimento estrat egia paraleliza desenvolvida 
 resumidamente duas diferen cas importantes ponteiro objetos classe sistemaequacoes referentes bloco deixa estar odulo mbloco portanto deixa ser unico passando ser vari avel fun interna rotina processadorbloco residindo pilha stack 
 cada vez chamada rotina cria novo ponteiro sistema equa oes 
 aloca dinˆamica objetos serem apontados tais ponteiros tamb feita interior rotina 
 significa cada chamada mesma novo objeto alocado referenciado ponteiro local 
 consluise caso rotina processadorbloco chamada arias vezes paralelo ultiplos ponteiros sistemas ultiplos objetos classe sistemaequacoes coexistindo mem oria apontados tais ponteiros 
 pertimitir paralelizar loop resolve arios problemas bloco 
 altera oes refletiramse programa principal anteriormente mostrado listagem 
 onde havia quatro decla oes use ponteiros odulos mfratura mbloco linhas 
 mostra altera oes relevantes programa principal 
 referidas quatro declara oes use restaram apenas trˆes sendo duas ponteiros odulo mfratura linhas referentes sistema estrutura dados fratura caso bloco restou apenas linha fazendo uso ponteiro estrutura dados odulo mbloco 
 altera oes programa principal 
 sistema equacoes estrutura dados mfratura use mfratura umsisteqfratura use mfratura umaestdadosfratura 
 apenas estrutura dados presente mbloco use mbloco umaestdadosbloco 
 end program reservoirsimulator visto caso fratura altera vez paralelismo tratar unicamente problemas bloco 
 continuaremos tendo apenas sistema equa oes fratura al estrutura dados 
 caso bloco ultiplos sistemas apenas unica estrutura dados todos 
 ser apontada unico ponteiro mbloco 
 lembramos estruturas dados tratam definir forma espec ıfica dados referentes matrizes sistemas ser armazenados considerando esparsidade estruturas contˆem matrizes sistemas propriamente ditas quais atributos classe sistemaequacoes 
 altera oes descritas ponto permitem finalmente aplicar diretivas compila padr openmp rotina resolverprobvariosblocos cuja vers serial apresentada listagem 
 trecho odigo mostrado listagem 
 podese ver nova vers rotina resolverprobvariosblocos diretivas openmp paraleliza loop linha resolve arios problemas bloco 
 vers rotina resolverprobvariosblocos paralelizada openmp subroutine resolverprobvariosblocos 
 implicit none integer numblocos nustep real fluxomassicodeblocoparafratura numblocos fluxomolms dt integer iblocos integer ompgetthreadnum 
 loop paralelizado openmp 
 $omp parallel firstprivate nustep tempo fluxomolms condcontorno dt iblocos numblocos call processadorbloco 
 fluxomassicodeblocoparafratura iblocos fluxomolms end 
 fim loop problema micro blocos 
 $omp end parallel end subroutine resolverprobvariosblocos linhas poss ıvel observar diretivas $omp parallel $omp end parallel utilizadas divis itera oes loop threads 
 tamb linha observase cl ausula firstprivate seguida erie vari aveis 
 necess ario corrigir erros execu decorrˆencia condi oes corrida causadas paralelismo 
 alguns recursos vari aveis compartilhados threads deveriam sˆelo 
 escritas simultˆaneas causavam erros resultados obtidos vers paralela 
 defeitos puderam ser corrigidos utiliza ferrmenta especialida thread debugging 
 tratase intel inspector dispon ıvel recursos computacionais lncc 
 ferramenta capaz apontar vari aveis est causando condi corrida 
 utiliza guiou remo erros nesta aplica tela alises feitas ferramenta mostrada figura 
 posse informa oes obtidas ferramenta poss ıvel utilizar assertividade cl ausula firstprivate faz vari aveis listadas possuam opias privadas cada thread evitando condi oes corrida 
 alise condi oes corrida feita ferramente intel inspector 
 linhas gerais ideia solu paralela cada thread openmp instancie sistema equa oes problemas bloco resolva desaloque final solu 
 processo segue repetindo problemas esgotem vez umero problemas invariavelmente ordens grandeza maior umero threads 
 threads podem instanciar novos sistemas equa oes simplesmente chamando nova vers rotina processadorbloco feito linha 
 importante lembrar neste momento rotina processadorbloco corresponde apenas solu sistemas lineares propriamente ditos 
 inclui al solver chamada rotina montarsistemab visto figuras 
 significa estrat egia paraleliza engloba tanto montagem matrizes sistemas quanto solu mesmos permite ter ganhos duas frentes ocorreria paraleliza solver 
 organiza final ponteiros objetos sistemas estruturas ap implementa estrat egia paraleliza descrita funcionasse corretamente forma ilustrado figura 
 organiza objetos sistemas estruturas dados vers paralelizada openmp mostrados figura 
 odulo mfratura dois ponteiros dois objetos referentes fratura sistema estrutura dados odulo mbloco apenas ponteiro estrutura dados ser utilizada todos problemas bloco erie ponteiros pilha stack referentes chamadas fun processadorbloco ocorrem paralelo 
 testes desempenho paraleliza openmp nesta ser abordados testes desempenho realizados aplica paralela 
 simula oes realizadas adotados dados ısicos realistas baseados heap estrutura dados fratura sistema fratura modulo mfratura 
 pointer umaestdadosfratura pointer umsisteqfratura 
 sistema bloco estrutura dados bloco modulo mbloco 
 pointer umaestdadosbloco stack umsisteqbloco umsisteqbloco umsisteqbloco 
 umsisteqbloco campo real 
 adaptada costa mostra parˆametros ısicos utilizados simula oes realizadas 
 parˆametros ısicos relativos campo realista utilizado testes 
 adaptado costa permeabilidade k∗ nd porosidade matriz φp press inicial reserv 
 psi press po co psi temperatura reserv 
 satura pl psi vl scf ton kg × − 
 adotadas experimentos duas configura oes tamanhos malhas fratura bloco experimento malha elementos fratura elementos bloco algo compat ıvel tamanhos utilizados costa ambas refinamento inicial 
 caso fratura regi pr oxima po co caso bloco regi pr oxima fratura 
 experimento neste experimento malhas bloco idˆenticas anterior 
 fim aumentar umero sistemas equa oes referentes bloco observar comportamento vers paralelizada comparar resultados ısicos desempenho computacional adotada fratura malha maior desta vez uniforme 
 apesar tratarse malha uniforme espa camento pontos malha existente experimento regi refinada mantido faz chegar umero elementos malha uniforme ser adotada fratura 
 experimento permitir avaliar solu paralela sens ıvel refinamento malhas 
 ambas configura oes tamanhos malha realizadas simula oes tempo total anos 
 experimento elementos malha fratura obtida seguinte sa ıda pressao reservatorio pressao poco quantidade gas total quantidade gas recuperavel quantidade gas produzido quantidade gas produzido valor pressao ultimo tempo simulacao fator recuperacao sobre gas total fator recuperacao sobre gas recuperavel 
 anos resultado todo reservatorio quantidade gas total quantidade gas recuperavel quantidade gas produzido 
 experimento elementos malha uniforme fratura obtida sa ıda seguir diferen cas relevantes resultados esperado pressao reservatorio pressao poco quantidade gas total quantidade gas recuperavel quantidade gas produzido quantidade gas produzido valor pressao ultimo tempo simulacao fator recuperacao sobre gas total fator recuperacao sobre gas recuperavel 
 anos resultado todo reservatorio quantidade gas total quantidade gas recuperavel quantidade gas produzido 
 valida resultados obtidos tamb feita compara sa ıdas vers simulador utilizada costa 
 mostram gr aficos relativos exeperimento elementos malha fratura 
 tais gr aficos apresentam diferen cas vis ıveis rela obtidos experimento dada semelhan ca resultados 
 vemos perfis press longo metros dimens fratura tempos espec ıficos mˆes meses anos 
 perfis press longo fratura metros mˆes meses anos 
 mostra produ acumulada kg reservat orio 
 produ acumulada kg 
 ambiente execu metodologia testes testes aplica paralelizada openmp realizados aquina duas cpus multicore seguintes especifica oes processadores quadcore intel xeon cpu 
 ghz total cores 
 pressao fratura mpa metros tempo anos producao kg gb mem oria ram ddr sistema operacional ubuntu 
 lts compilador utilizado gfortran vers 
 todos experimentos paralelos tomada tempo repetidos vezes cada configura umero unidades execu threads 
 fim cada experimento consideradas edias execu oes cada caso threads 
 oes seguintes apresentamos resultados tomadas tempo aplica paralelizada openmp 
 resultados experimento openmp nesta apresentamos resultados tomadas tempo vers paralelizada openmp 
 mostra tempos totais execu aplica minutos threads 
 cada umero threads aplica executada vezes 
 linha destaque tabela apresentadas edias tempos execu 
 ultima linha apresenta speedup obtido cada caso onde speedu empo serial empo paralelo tabela 
 tempos execu minutos vers openmp experimento 
 execu execu execu execu execu execu edia minutos speedup obtido thread threads 
 mostrado gr afico speedups obtidos openmp verde compara caso ideal speedup linear vermelho 
 speedups vers openmp experimento 
 resultados experimento openmp testes realizados experimento repetidos experimento malha uniforme elementos fratura 
 seguir exibidos tabela tempos obtidos gr afico speedups mesmos exibidos anteriormente experimento 
 tempos execu minutos vers openmp experimento 
 execu execu execu execu execu execu edia minutos speedup obtido thread threads 
 speedup numero threads speedup linearspeedup obtido openmp figura 
 speedups vers openmp experimento 
 discuss resultados otimiza openmp fim testes anteriores poss ıvel observar paraleliza openmp apresentou significativos ganhos desempenho atingindo threads speedups experimento experimento 
 speedups etricas afetadas balanceamento carga forma feita distribui carga processamento diferentes threads unidades execu 
 balanceamento insuficiente algumas threads terminam trabalho antes demais precisam esperar ociosamente outras poderiam estar realizando parte trabalho extra est destinado demais 
 impacta negativamente speedup obtido 
 sabese modelo problemas relativos bloco parte inferior pr oximos po co problemas demorados localizados parte superior 
 fato significaria threads respons aveis problemas superiores terminariam trabalho primeiro ter ıamos situa desbalanceamento ainda mensurada poderia estar afetando speedup obtido 
 fim confirmar hip otese problemas inferiores 
 speedup numero threads speedup linearspeedup obtido openmp custosos avaliamos separadamente tempos totais execu gastos cada problemas bloco desbalanceamento carga pudesse ser visualizado termos pr aticos 
 mostram experimentos tempos execu acumulados todos passos tempo simula cada problemas bloco sendo valores esquerda relativos problemas superiores afastados po co direita relativos problemas pr oximos po co 
 tempos execu cada problema bloco experimento 
 tempos execu cada problema bloco experimento 
 ambos resultados parecidos 
 mostram oscila consider avel custos problemas bloco longo toda externs fratura ambos casos apresentam linha tendˆencia inclina embora pequena capaz demonstrar fato ex 
 tempo execucao identificador problema problema proximo poco ex 
 tempo execucao identificador problema problema proximo poco problemas pr oximos po co tendem ser lentos gerando algum desbalanceamento carga 
 padr openmp oferece recursos melhor balanceamento carga threads 
 cl ausula schedule usada paraleliza loop pode definir diversas formas itera oes loop ser divididas threads promover melhor balanceamento carga 
 forma padr utilizada omiss cl ausula schedule chamada escalonamento est atico divide todo espa co itera oes loop blocos itera oes tamanho aproximadamente igual quociente umero total itera oes loop umero threads 
 tais blocos itera oes chunks ent designados threads ainda tempo compila 
 resultados expostos aqui utilizam escalonamento est atico 
 repetidos cl ausula schedule definindo nova maneira dividir espa co itera oes threads capaz diminuir efeitos desbalanceamento escalonamento dinˆamico 
 loop paralelizado simulador mostrado listagem 
 adicionada cl ausula schedule dynamic 
 utiliza escalonamento dinˆamico recomendado situa oes onde custo itera oes loop constante todas itera oes organizadas esp ecie fila trabalho interna meio distribu ıdas threads medida terminam trabalho 
 dessa forma evitase threads ociosas tempo 
 mostram novos speedups obtidos experimento experimento utilizando cl ausula schedule dynamic 
 speedups cl ausula schedule dynamic experimento 
 speedups cl ausula schedule dynamic experimento 
 resultados poss ıvel perceber cl ausula schedule dynamic elevou consideravelmente speedups obtidos apesar inclina oes linhas tendˆencia figuras 
 neste momento interessante saber ocorreria situa oes onde inclina oes pronunciadas 
 umero tarefas mantendo malha fratura elementos aumentadas malhas bloco elementos 
 mostra resultados tomadas tempo 
 speedup numero threads speedup linearspeedup obtido schedule staticspeedup obtido schedule dynamic 
 speedup numero threads speedup linearspeedup obtido schedule staticspeedup obtido schedule dynamic similares figura 
 elementos malhas bloco 
 tempos execu cada problema bloco fratura elementos malhas elementos bloco podese observar varia oes diminu ıram consideralvemnte 
 linha tendˆencia continua apontando maior custo problemas pr oximos po co dessa vez inclina maior 
 diferen ca percebida inclina oes indica caso elementos malhas bloco maior diferen ca custos problemas pr oximos po co distantes 
 valores tais inclina oes mostrados figura 
 fun umero elementos malhas bloco 
 inclu ıdo experimento adicional intermedi ario elementos malhas bloco 
 inclina oes linhas tendˆencia figuras 
 fun tamanho malhas bloco 
 resultados indicam malhas maiores bloco maiores ser 
 identificador problema problema proximo poco tempo execucao 
 enumero elementos cada malha blocoinclinacao linhas tendencia figuras 
 caso intermediario problemas desbalanceamento caso omitida cl ausula schedule portanto utilizado escalonamento est atico 
 nesses casos esperase efic acia cl ausula schedule dynamic maior sendo maiores tamb speedups utiliza 
 apresentamos seguir resultados speedup experimentos malhas bloco aumentadas elementos uso cl ausula schedule dynamic 
 speedups cl ausula schedule dynamic experimento malhas bloco aumentadas elementos 
 speedups cl ausula schedule dynamic experimento malhas bloco aumentadas elementos 
 resultados mostram verdade benef ıcios cl ausula 
 speedup numero threads speedup linearspeedup obtido schedule staticspeedup obtido schedule dynamic 
 speedup numero threads speedup linearspeedup obtido schedule staticspeedup obtido schedule dynamic schedule dynamic menor impacto nesses casos 
 maior inclina linha tendˆencia figura 
 indica maior diferen ca custos problemas parte inferior bloco parte superior ganhos speedup atribu ıdos uso escalonamento dinˆamico menos importantes casos experimentos mostrados figuras 
 onde notase maior distˆancia static dynamic 
 observa oes permitem concluir efic acia cl ausula schedule dynamic relacionada grande oscila custos cada problema conhecida tendˆencia custosos pr oximo po co 
 testes adicionais todos outros tipos escalonamento oferecidos padr openmp realizados experimentos padr sendo melhores resultados obtidos cl ausula schedule dynamic 
 levantamos hip otese casos malhas maiores bloco ultimos casos testados outros tipos scheduling possam levar melhores resultados 
 raz menor oscila tempos cada problema nesses casos custos inerentes dynamic scheduling relacionados constru fila controla distribui itera oes threads provavelmente est sendo suficientemente sobrepujados pouca melhoria balanceamento oferecida 
 estrat egia paraleliza mpi oes anteriores poss ıvel observar ganhos significativos desempenho simulador estret egia paraleliza desenvolvida uso padr openmp 
 visto cap ıtulo padr openmp voltado sistemas mem oria compartilhada sendo aplicado frequentemente paraleliza aplica oes executadas ambientes cpus multicore existentes cada cluster altixxe descrito adiante utilizado testes mpi neste trabalho 
 aplica estrat egia utilizando padr mpi permitiria utiliza arios cluster vez tal padr destinado sistemas mem oria distribu ıda 
 objetivo expandir resultados obtidos openmp unica aquina desenvolvida uso mpi segunda estrat egia paraleliza funcionar conjunto primeira 
 implementa estrat egia mpi concentramos novamente rotina resolverprobvariosblocos mostrada 
 vers oes serial listagem 
 seguir apresentaremos partes trˆes trechos odigo altera oes feitas rotina inclus paraleliza mpi 
 observamos erie novas vari aveis partir linha serem usadas neste pr oximos dois trechos mostrados 
 destacamos vari aveis numprocs meuid linha servir armazenar respectivamente tamanho comunicador mpi quantos processos estar executando paralelo identifica cada processo 
 duas vari aveis atribu ıdos valores uso duas rotinas mpi mpicommsize mpicommrank cujas chamadas podem ser vistas linhas 
 vers rotina resolverprobvariosblocos paralelizada openmpmpi 
 use mpi implicit none integer numblocos nustep real fluxomassicodeblocoparafratura numblocos fluxomolms dt integer iblocos integer error integer numprocs meuid integer meucomeco meufim meutamanho resto parteinteira integer tamanho cont 
 tamanho comunicador mpi real receivebuffer numblocos allocatable sendarray real call mpicommsize mpicommworld numprocs error call mpicommrank mpicommworld meuid error 
 end subroutine resolverprobvariosblocos id eia asica paraleliza mpi ir conviver feito openmp ilustrada figura 
 consiste dividir inicialmente fratura umero partes tamanho igual destinar cada execu todos problemas bloco relacionados fratura 
 cada processo mpi tratar portanto resolver umero predefinido problemas bloco relativos parcela fratura 
 assemelhase feito automaticamente padr openmp paraleliza loop quest escalonamento est atico 
 internamente cada processo continuar utilizando paralelismo multithread openmp resolver subconjunto problemas visto cada dotado cpus multicore 
 estrat egia paraleliza processos mpi 
 adiante odigo fun resolverprobvariosblocos ap trecho exibido listagem 
 existe loop resolve arios problemas poco bloco processo processo 
 parte mostrada listagem 
 chamamos aten linha onde percebese cada processo realizar parte loop original resolvendo apenas parcela problemas bloco ilustrado figura 
 portanto atribuindo valores apenas parte vetor fluxomassicodeblocoparafratura linha 
 vers rotina resolverprobvariosblocos paralelizada openmpmpi 
 resto mod numblocos numprocs parteinteira numblocos numprocs meucomeco parteinteira meuid resto 
 meuid meucomeco meucomeco meuid meufim meucomeco parteinteira else meucomeco meucomeco resto meufim meucomeco parteinteira endif 
 $omp parallel firstprivate nustep tempo fluxomolms condcontorno dt iblocosmeucomeco meufim call processadorbloco iblocos nustep tempo fluxomolms condcontorno iblocos dt fluxomassicodeblocoparafratura iblocos fluxomolms end 
 fim loop problema micro blocos 
 $omp end parallel 
 end subroutine resolverprobvariosblocos finalmente ap trecho apresentado listagem 
 cada processo possui apenas parte vetor fluxomassicodeblocoparafratura devidamente calculada 
 necess ario nesse momento exista comunica processos cada possa enviar demais parcela vetor 
 feito uso rotina mpi mpiallgather cuja chamada pode ser vista listagem 
 fim rotina todos processos possuem vetor fluxomassicodeblocoparafratura completo contribui demais 
 vers rotina resolverprobvariosblocos paralelizada openmpmpi subroutine resolverprobvariosblocos 
 comunicacao processos meutamanho meufim meucomeco 
 allocated sendarray allocate sendarray meutamanho endif sendarray meutamanho fluxomassicodeblocoparafratura meucomecomeufim call mpiallgather sendarray meutamanho mpireal receivebuffer meutamanho mpireal mpicommworld error fluxomassicodeblocoparafratura numblocos receivebuffer numblocos end subroutine resolverprobvariosblocos 
 testes desempenho paraleliza openmp mpi nesta abordamos testes desempenho feitos segunda estrat egia paraleliza desenvolvida utilizando openmp mpi conjunto 
 casos teste mesmos experimentos utilizados testes openmp descritos 
 ambiente execu metodologia testes todos testes realizados paraleliza openmpmpi executados cluster altixxe lncc 
 cluster composto execu cada seguinte especifica modelo altixxe processadores quad core intel xeon cpu 
 ghz total cores gb mem oria ddr compilador utilizado gfortran vers 
 implementa mpi utilizada openmpi 
 metodologia testes utilizada mesma 
 testes mpi submetidos jobs gerenciador filas sun grid engine sge aplica testada fila acesso configura descrita anteriormente 
 raz testes feitos aximo processos cada utilizando threads openmp internamente 
 resultados experimento openmpmpi nesta apresentamos resultados tomadas tempo vers paralelizada via openmp mpi experimento 
 exibe parte esquerda tempos totais execu aplica minutos threads somente openmp parte direita tempos execu utilizando vers ıbrida openmp mpi sempre threads variando umero processos 
 cada caso aplica executada vezes 
 linha destaque tabelaa apresentadas edias tempos execu 
 ultima linha apresenta speedup obtido cada caso 
 tempos execu minutos vers openmpmpi experimento 
 threads openmp processos mpi threads openmp execu execu execu execu execu execu edia minutos speedup obtido 
 gr afico figura 
 mostra edias tempos execu destacadas tabela 
 edias tempos execu minutos vers openmpmpi experimento 
 mostrado gr afico speedups 
 exibidos visualiza comparativa speedups obtidos vers inclui somente openmp verde quais juntamse speedups vers ıbrida azul ambos compara caso ideal speedup linear vermelho 
 thread threads threads threads threads threads processo threads processos threads processos threads processostempo execucao min unidades execucao figura 
 speedups vers openmpmpi experimento 
 resultados experimento openmpmpi testes realizados experimento repetidos experimento malha uniforme elementos fratura 
 seguir exibidos tabela tempos obtidos gr afico edias tempo gr afico speedup mesmos exibidos anteriormente experimento 
 tempos execu minutos vers openmpmpi experimento 
 threads openmp processos mpi threads openmp execu execu execu execu execu execu edia minutos speedup obtido 
 speedup numero unidades execucao processos threads speedup linearspeedup obtido openmpspeedup obtido openmp mpi figura 
 edias tempos execu minutos vers openmpmpi experimento 
 speedups vers openmpmpi experimento 
 discuss resultados mpi quanto estrat egia paraleliza ıbrida openmp mpi obtivemos resultados speedup experimento experimento 
 embora tais umeros distantes speedup linear consideramos boa aproxima inicial paraleliza modelo aquinas mem oria distribu ıda ainda pode ser aperfei coada 
 paraleliza mpi estar ıamos limitados apenas execu 
 thread threads threads threads threads threads processo threads processos threads processos threads processostempo execucao min unidades execucao 
 speedup numero unidades execucao processos threads speedup linearspeedup obtido openmpspeedup obtido openmp mpi problemas quanto balanceamento carga vistos openmp tamb ocorrem paraleliza mpi neste caso agravante divis inicial fratura oes tamanho pr edefinido ideia central estrat egia paraleliza divis trabalho assemelha escalonamento est atico openmp 
 esperase desbalanceamento possa ser corrigido mesma facilidade encontrada caso openmp oferece flexibilidade nesse sentido pouca altera odigo meio uso cl ausula schedule 
 balanceamento carga mpi dever envolver ecnicas desenvolvidas programador fim divida problemas bloco processos forma adequada 
 solu paralela avan cada mpi dever dividir espa co itera oes loop mostrado listagem 
 processos forma elaborada mostrada figura 
 ponto melhoria aqui identificado utiliza alternativa rotina mpiallgather cuja chamada mostrada listagem 
 rotina promove comunica oes desnecess arias todos processos cada envie todos demais parcela vetor fluxomassicodeblocoparafratura 
 necess ario apenas processo contenha vetor completo prossiga execu programa 
 economia comunica oes processos poder beneficiar consider avelmente desempenho geral aplica 
 cap ıtulo conclus oes perspectivas nesta disserta descrevemos trabalho centrado aspectos computacionais realizado simulador relacionado ciˆencia escoamentos meios porosos 
 baseado implementa original ecada destacou epoca poderoso programa elementos finitos simulador pode atualmente beneficiarse algumas ecnicas programa modernas 
 trabalho representou passo evolutivo deste simulador manifestou duas formas emprego programa orientada objetos odulos desenvolvimento estrat egias computa paralela reduzir tempo execu 
 quanto primeiro aspecto desenvolvemos reformula odulo sistemas equa oes deste simulador conferindo caracter ısticas modernas inclus paradigma orienta objetos visando contribuir melhor organiza entendimento humano capacidade evolu 
 novos odulos classes facilitam encorajam troca incorpora novos solvers neste outros simuladores semelhantes 
 al disso reformula funcionou facilitadora desenvolvimento estrat egias paraleliza simulador 
 quanto desempenho execu desenvolvemos estrat egias padr oes openmp mpi solu paralelo ultiplos problemas elementos finitos 
 refatora odulo referente sistemas equa oes descrita cap ıtulo facilitou tarefa 
 inclus paradigma orienta objetos tornou natural tarefa criar ultiplas instˆancias mem oria mesma entidade denominada sistema equa oes solu paralelo 
 nesse momento poss ıvel observar escalabilidade design pˆode contribuir escalabilidade execu 
 organiza est atica odigofonte forma modular promoveu agrupamento elementos relacionados encapsulamento abstra oes acabou tamb contribuir facilita desenvolvimento solu oes paralelas melhoraram desempenho simulador 
 beneficiandose resultados obtidos neste trabalho algumas perspectivas trabalhos futuros 
 primeiro lugar importante reconhecer embora novos odulos orienta objetos trazido benef ıcios simulador contribuindo melhor organiza capacidade evolu resultado interven localizada restrita odulo sistemas equa oes 
 assim ressaltamos simulador apresenta neste momento caracter ısticas produto final desenvolvido orienta objetos explora todos recursos deste paradigma exemplo prote dados 
 dessa forma expans emprego orienta objetos outros odulos deste simulador bem maior profunda explora recursos oferecidos tal paradigma surgem perspectivas continua trabalhos 
 quanto estrat egias paraleliza especialmente desenvolvida padr mpi podese dizer continua trabalhos envolve ciclos otimiza podem melhorar desempenho obtido presente momento 
 ainda testes desempenho aqui realizados utilizado solver baseado elimina gauss adequado modelo espec ıfico solu paralela desenvolvida independente solver 
 significa outras situa oes quais uso solver robusto intel pardiso fa ca necess ario exemplo simula oes malhas bidimensionais tridimensionais mesma estrat egia paraleliza poder ser utilizada ainda demandados provavelmente esfor cos otimiza 
 tamb merece lembran ca fato refatora odulo sistemas equa oes inclus orienta objetos possui potencial uso outros simuladores similares utilizam mesma implementa base mef 
 portanto estender benef ıcios classes outros programas tamb perspectiva trabalho pode representar novas possibilidades mesmos 
 alguns simuladores utilizados lncc contam apenas op solver 
 inclus novos odulos classes poder oferecer certa facilidade nova op oes tal quesito 
 referˆencias bibliogr aficas 
 finite element procedures engineering analysis 
 fortran scientists engineers 
 modelagem computacional multiescala reservat orios convencionais folhelhos 
 tese doutorado lncc 
 finite element method linear static dynamic finite element analysis 
 prenticehall international edi 
 james jeffers james reinders 
 intel xeon phi coprocessor high performance programming 
 morgan kaufmann edi 
 david kirk wenmei 
 programming massively parallel processors handson approach 
 patterns parallel programming 
 introduction parallel programming 
 damian rouson jim xia xiaofeng xu 
 scientific software design objectoriented way 
 toledo eduardo ucio mendes garcia 
 axis programa alise olidos axisim etricos carregamento qualquer 
 sibrat simp osio brasileiro sobre tubula aoes vasos press 
 linguagens programa conceitos ecnicas 
 programa modular desenvolvendo programas complexos forma organizada segura 
